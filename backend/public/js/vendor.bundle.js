(self["webpackChunktemplate_feo_react_babel"] = self["webpackChunktemplate_feo_react_babel"] || []).push([["vendor"],{

/***/ "./node_modules/chart.js/auto/auto.esm.js":
/*!************************************************!*\
  !*** ./node_modules/chart.js/auto/auto.esm.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dist_chart_esm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/chart.esm */ "./node_modules/chart.js/dist/chart.esm.js");


_dist_chart_esm__WEBPACK_IMPORTED_MODULE_0__.Chart.register(..._dist_chart_esm__WEBPACK_IMPORTED_MODULE_0__.registerables);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_dist_chart_esm__WEBPACK_IMPORTED_MODULE_0__.Chart);


/***/ }),

/***/ "./node_modules/chart.js/dist/chart.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/chart.js/dist/chart.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaults": () => (/* reexport safe */ _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d),
/* harmony export */   "Animation": () => (/* binding */ Animation),
/* harmony export */   "Animations": () => (/* binding */ Animations),
/* harmony export */   "ArcElement": () => (/* binding */ ArcElement),
/* harmony export */   "BarController": () => (/* binding */ BarController),
/* harmony export */   "BarElement": () => (/* binding */ BarElement),
/* harmony export */   "BasePlatform": () => (/* binding */ BasePlatform),
/* harmony export */   "BasicPlatform": () => (/* binding */ BasicPlatform),
/* harmony export */   "BubbleController": () => (/* binding */ BubbleController),
/* harmony export */   "CategoryScale": () => (/* binding */ CategoryScale),
/* harmony export */   "Chart": () => (/* binding */ Chart),
/* harmony export */   "DatasetController": () => (/* binding */ DatasetController),
/* harmony export */   "Decimation": () => (/* binding */ plugin_decimation),
/* harmony export */   "DomPlatform": () => (/* binding */ DomPlatform),
/* harmony export */   "DoughnutController": () => (/* binding */ DoughnutController),
/* harmony export */   "Element": () => (/* binding */ Element),
/* harmony export */   "Filler": () => (/* binding */ plugin_filler),
/* harmony export */   "Interaction": () => (/* binding */ Interaction),
/* harmony export */   "Legend": () => (/* binding */ plugin_legend),
/* harmony export */   "LineController": () => (/* binding */ LineController),
/* harmony export */   "LineElement": () => (/* binding */ LineElement),
/* harmony export */   "LinearScale": () => (/* binding */ LinearScale),
/* harmony export */   "LogarithmicScale": () => (/* binding */ LogarithmicScale),
/* harmony export */   "PieController": () => (/* binding */ PieController),
/* harmony export */   "PointElement": () => (/* binding */ PointElement),
/* harmony export */   "PolarAreaController": () => (/* binding */ PolarAreaController),
/* harmony export */   "RadarController": () => (/* binding */ RadarController),
/* harmony export */   "RadialLinearScale": () => (/* binding */ RadialLinearScale),
/* harmony export */   "Scale": () => (/* binding */ Scale),
/* harmony export */   "ScatterController": () => (/* binding */ ScatterController),
/* harmony export */   "SubTitle": () => (/* binding */ plugin_subtitle),
/* harmony export */   "Ticks": () => (/* binding */ Ticks),
/* harmony export */   "TimeScale": () => (/* binding */ TimeScale),
/* harmony export */   "TimeSeriesScale": () => (/* binding */ TimeSeriesScale),
/* harmony export */   "Title": () => (/* binding */ plugin_title),
/* harmony export */   "Tooltip": () => (/* binding */ plugin_tooltip),
/* harmony export */   "_adapters": () => (/* binding */ adapters),
/* harmony export */   "_detectPlatform": () => (/* binding */ _detectPlatform),
/* harmony export */   "animator": () => (/* binding */ animator),
/* harmony export */   "controllers": () => (/* binding */ controllers),
/* harmony export */   "elements": () => (/* binding */ elements),
/* harmony export */   "layouts": () => (/* binding */ layouts),
/* harmony export */   "plugins": () => (/* binding */ plugins),
/* harmony export */   "registerables": () => (/* binding */ registerables),
/* harmony export */   "registry": () => (/* binding */ registry),
/* harmony export */   "scales": () => (/* binding */ scales)
/* harmony export */ });
/* harmony import */ var _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/helpers.segment.js */ "./node_modules/chart.js/dist/chunks/helpers.segment.js");
/*!
 * Chart.js v3.5.1
 * https://www.chartjs.org
 * (c) 2021 Chart.js Contributors
 * Released under the MIT License
 */



class Animator {
  constructor() {
    this._request = null;
    this._charts = new Map();
    this._running = false;
    this._lastDate = undefined;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach(fn => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    const me = this;
    if (me._request) {
      return;
    }
    me._running = true;
    me._request = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.r.call(window, () => {
      me._update();
      me._request = null;
      if (me._running) {
        me._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    const me = this;
    let remaining = 0;
    me._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw) {
        chart.draw();
        me._notify(chart, anims, date, 'progress');
      }
      if (!items.length) {
        anims.running = false;
        me._notify(chart, anims, date, 'complete');
        anims.initial = false;
      }
      remaining += items.length;
    });
    me._lastDate = date;
    if (remaining === 0) {
      me._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), 'complete');
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
}
var animator = new Animator();

const transparent = 'transparent';
const interpolators = {
  boolean(from, to, factor) {
    return factor > 0.5 ? to : from;
  },
  color(from, to, factor) {
    const c0 = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.c)(from || transparent);
    const c1 = c0.valid && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.c)(to || transparent);
    return c1 && c1.valid
      ? c1.mix(c0, factor).hexString()
      : to;
  },
  number(from, to, factor) {
    return from + (to - from) * factor;
  }
};
class Animation {
  constructor(cfg, target, prop, to) {
    const currentValue = target[prop];
    to = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a)([cfg.to, to, currentValue, cfg.from]);
    const from = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a)([cfg.from, currentValue, to]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from];
    this._easing = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.e[cfg.easing] || _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.e.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from;
    this._to = to;
    this._promises = undefined;
  }
  active() {
    return this._active;
  }
  update(cfg, to, date) {
    const me = this;
    if (me._active) {
      me._notify(false);
      const currentValue = me._target[me._prop];
      const elapsed = date - me._start;
      const remain = me._duration - elapsed;
      me._start = date;
      me._duration = Math.floor(Math.max(remain, cfg.duration));
      me._total += elapsed;
      me._loop = !!cfg.loop;
      me._to = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a)([cfg.to, to, currentValue, cfg.from]);
      me._from = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a)([cfg.from, currentValue, to]);
    }
  }
  cancel() {
    const me = this;
    if (me._active) {
      me.tick(Date.now());
      me._active = false;
      me._notify(false);
    }
  }
  tick(date) {
    const me = this;
    const elapsed = date - me._start;
    const duration = me._duration;
    const prop = me._prop;
    const from = me._from;
    const loop = me._loop;
    const to = me._to;
    let factor;
    me._active = from !== to && (loop || (elapsed < duration));
    if (!me._active) {
      me._target[prop] = to;
      me._notify(true);
      return;
    }
    if (elapsed < 0) {
      me._target[prop] = from;
      return;
    }
    factor = (elapsed / duration) % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = me._easing(Math.min(1, Math.max(0, factor)));
    me._target[prop] = me._fn(from, to, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({res, rej});
    });
  }
  _notify(resolved) {
    const method = resolved ? 'res' : 'rej';
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
}

const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];
const colors = ['color', 'borderColor', 'backgroundColor'];
_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.set('animation', {
  delay: undefined,
  duration: 1000,
  easing: 'easeOutQuart',
  fn: undefined,
  from: undefined,
  loop: undefined,
  to: undefined,
  type: undefined,
});
const animationOptions = Object.keys(_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.animation);
_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.describe('animation', {
  _fallback: false,
  _indexable: false,
  _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',
});
_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.set('animations', {
  colors: {
    type: 'color',
    properties: colors
  },
  numbers: {
    type: 'number',
    properties: numbers
  },
});
_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.describe('animations', {
  _fallback: 'animation',
});
_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.set('transitions', {
  active: {
    animation: {
      duration: 400
    }
  },
  resize: {
    animation: {
      duration: 0
    }
  },
  show: {
    animations: {
      colors: {
        from: 'transparent'
      },
      visible: {
        type: 'boolean',
        duration: 0
      },
    }
  },
  hide: {
    animations: {
      colors: {
        to: 'transparent'
      },
      visible: {
        type: 'boolean',
        easing: 'linear',
        fn: v => v | 0
      },
    }
  }
});
class Animations {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = new Map();
    this.configure(config);
  }
  configure(config) {
    if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(config)) {
      return;
    }
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach(key => {
      const cfg = config[key];
      if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === '$') {
        continue;
      }
      if (prop === 'options') {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
}
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});
  }
  return options;
}

function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === undefined ? allowedOverflow : 0;
  const max = opts.max === undefined ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l;
  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options) {
  const keys = stack.keys;
  const singleMode = options.mode === 'single';
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(otherValue) && (singleMode || (value === 0 || (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.s)(value) === (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.s)(otherValue)))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || (stacked === undefined && meta.stack !== undefined);
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const {min, max, minDefined, maxDefined} = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive) {
  for (const meta of vScale.getMatchingVisibleMetas('bar').reverse()) {
    const value = stack[meta.index];
    if ((positive && value > 0) || (!positive && value < 0)) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const {chart, _cachedMeta: meta} = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const {iScale, vScale, index: datasetIndex} = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const {[iAxis]: index, [vAxis]: value} = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true);
    stack._bottom = getLastIndexInStack(stack, vScale, false);
  }
}
function getFirstScaleId(chart, axis) {
  const scales = chart.scales;
  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();
}
function createDatasetContext(parent, index) {
  return Object.assign(Object.create(parent),
    {
      active: false,
      dataset: undefined,
      datasetIndex: index,
      index,
      mode: 'default',
      type: 'dataset'
    }
  );
}
function createDataContext(parent, index, element) {
  return Object.assign(Object.create(parent), {
    active: false,
    dataIndex: index,
    parsed: undefined,
    raw: undefined,
    element,
    index,
    mode: 'default',
    type: 'data'
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {
      return;
    }
    delete stacks[axis][datasetIndex];
  }
}
const isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';
const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
class DatasetController {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = undefined;
    this._parsing = false;
    this._data = undefined;
    this._objectData = undefined;
    this._sharedOptions = undefined;
    this._drawStart = undefined;
    this._drawCount = undefined;
    this.enableOptionSharing = false;
    this.$context = undefined;
    this._syncList = [];
    this.initialize();
  }
  initialize() {
    const me = this;
    const meta = me._cachedMeta;
    me.configure();
    me.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    me.addElements();
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const me = this;
    const chart = me.chart;
    const meta = me._cachedMeta;
    const dataset = me.getDataset();
    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;
    const xid = meta.xAxisID = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.xAxisID, getFirstScaleId(chart, 'x'));
    const yid = meta.yAxisID = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.yAxisID, getFirstScaleId(chart, 'y'));
    const rid = meta.rAxisID = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.rAxisID, getFirstScaleId(chart, 'r'));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = me.getScaleForId(xid);
    meta.yScale = me.getScaleForId(yid);
    meta.rScale = me.getScaleForId(rid);
    meta.iScale = me.getScaleForId(iid);
    meta.vScale = me.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale
      ? meta.vScale
      : meta.iScale;
  }
  reset() {
    this._update('reset');
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.u)(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const me = this;
    const dataset = me.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = me._data;
    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(data)) {
      me._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.u)(_data, me);
        const meta = me._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.l)(data, me);
      }
      me._syncList = [];
      me._data = data;
    }
  }
  addElements() {
    const me = this;
    const meta = me._cachedMeta;
    me._dataCheck();
    if (me.datasetElementType) {
      meta.dataset = new me.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const me = this;
    const meta = me._cachedMeta;
    const dataset = me.getDataset();
    let stackChanged = false;
    me._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    me._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(me, meta._parsed);
    }
  }
  configure() {
    const me = this;
    const config = me.chart.config;
    const scopeKeys = config.datasetScopeKeys(me._type);
    const scopes = config.getOptionScopes(me.getDataset(), scopeKeys, true);
    me.options = config.createResolver(scopes, me.getContext());
    me._parsing = me.options.parsing;
  }
  parse(start, count) {
    const me = this;
    const {_cachedMeta: meta, _data: data} = me;
    const {iScale, _stacked} = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (me._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(data[start])) {
        parsed = me.parseArrayData(meta, data, start, count);
      } else if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(data[start])) {
        parsed = me.parseObjectData(meta, data, start, count);
      } else {
        parsed = me.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(me, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const {iScale, vScale} = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index], index),
        [vAxis]: vScale.parse(data[index], index)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const {xScale, yScale} = meta;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse(item[0], index),
        y: yScale.parse(item[1], index)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const {xScale, yScale} = meta;
    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i + start;
      item = data[index];
      parsed[i] = {
        x: xScale.parse((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.f)(item, xAxisKey), index),
        y: yScale.parse((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.f)(item, yAxisKey), index)
      };
    }
    return parsed;
  }
  getParsed(index) {
    return this._cachedMeta._parsed[index];
  }
  getDataElement(index) {
    return this._cachedMeta.data[index];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]
    };
    return applyStack(stack, value, meta.index, {mode});
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      range.min = Math.min(range.min, value);
      range.max = Math.max(range.max, value);
      value = applyStack(stack, parsedValue, this._cachedMeta.index, {all: true});
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const me = this;
    const meta = me._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = me._getOtherScale(scale);
    const stack = canStack && meta._stacked && {keys: getSortedDatasetIndices(me.chart, true), values: null};
    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};
    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);
    let i, value, parsed, otherValue;
    function _skip() {
      parsed = _parsed[i];
      value = parsed[scale.axis];
      otherValue = parsed[otherScale.axis];
      return !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(value) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      me.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        me.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index) {
    const me = this;
    const meta = me._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = me.getParsed(index);
    return {
      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',
      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''
    };
  }
  _update(mode) {
    const me = this;
    const meta = me._cachedMeta;
    me.configure();
    me._cachedDataOpts = {};
    me.update(mode || 'default');
    meta._clip = toClip((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(me.options.clip, defaultClip(meta.xScale, meta.yScale, me.getMaxOverflow())));
  }
  update(mode) {}
  draw() {
    const me = this;
    const ctx = me._ctx;
    const chart = me.chart;
    const meta = me._cachedMeta;
    const elements = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = me._drawStart || 0;
    const count = me._drawCount || (elements.length - start);
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements[i];
      if (element.hidden) {
        continue;
      }
      if (element.active) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index, active) {
    const mode = active ? 'active' : 'default';
    return index === undefined && this._cachedMeta.dataset
      ? this.resolveDatasetElementOptions(mode)
      : this.resolveDataElementOptions(index || 0, mode);
  }
  getContext(index, active, mode) {
    const me = this;
    const dataset = me.getDataset();
    let context;
    if (index >= 0 && index < me._cachedMeta.data.length) {
      const element = me._cachedMeta.data[index];
      context = element.$context ||
        (element.$context = createDataContext(me.getContext(), index, element));
      context.parsed = me.getParsed(index);
      context.raw = dataset.data[index];
      context.index = context.dataIndex = index;
    } else {
      context = me.$context ||
        (me.$context = createDatasetContext(me.chart.getContext(), me.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = me.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index);
  }
  _resolveElementOptions(elementType, mode = 'default', index) {
    const me = this;
    const active = mode === 'active';
    const cache = me._cachedDataOpts;
    const cacheKey = elementType + '-' + mode;
    const cached = cache[cacheKey];
    const sharing = me.enableOptionSharing && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.h)(index);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = me.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(me._type, elementType);
    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];
    const scopes = config.getOptionScopes(me.getDataset(), scopeKeys);
    const names = Object.keys(_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.elements[elementType]);
    const context = () => me.getContext(index, active);
    const values = config.resolveNamedOptions(scopes, names, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index, transition, active) {
    const me = this;
    const chart = me.chart;
    const cache = me._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = me.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(me._type, transition);
      const scopes = config.getOptionScopes(me.getDataset(), scopeKeys);
      options = config.createResolver(scopes, me.getContext(index, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  updateElement(element, index, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index, mode, active) {
    element.active = active;
    const options = this.getStyle(index, active);
    this._resolveAnimations(index, mode, active).update(element, {
      options: (!active && this.getSharedOptions(options)) || options
    });
  }
  removeHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, 'active', false);
  }
  setHoverStyle(element, datasetIndex, index) {
    this._setStyle(element, index, 'active', true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, undefined, 'active', false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, undefined, 'active', true);
    }
  }
  _resyncElements(resetNewElements) {
    const me = this;
    const data = me._data;
    const elements = me._cachedMeta.data;
    for (const [method, arg1, arg2] of me._syncList) {
      me[method](arg1, arg2);
    }
    me._syncList = [];
    const numMeta = elements.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      me.parse(0, count);
    }
    if (numData > numMeta) {
      me._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      me._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const me = this;
    const meta = me._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new me.dataElementType();
    }
    if (me._parsing) {
      move(meta._parsed);
    }
    me.parse(start, count);
    if (resetNewElements) {
      me.updateElements(data, start, count, 'reset');
    }
  }
  updateElements(element, start, count, mode) {}
  _removeElements(start, count) {
    const me = this;
    const meta = me._cachedMeta;
    if (me._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync(['_insertElements', this.getDataset().data.length - count, count]);
  }
  _onDataPop() {
    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);
  }
  _onDataShift() {
    this._sync(['_removeElements', 0, 1]);
  }
  _onDataSplice(start, count) {
    this._sync(['_removeElements', start, count]);
    this._sync(['_insertElements', start, arguments.length - 2]);
  }
  _onDataUnshift() {
    this._sync(['_insertElements', 0, arguments.length]);
  }
}
DatasetController.defaults = {};
DatasetController.prototype.datasetElementType = null;
DatasetController.prototype.dataElementType = null;

function getAllScaleValues(scale) {
  if (!scale._cache.$bar) {
    const metas = scale.getMatchingVisibleMetas('bar');
    let values = [];
    for (let i = 0, ilen = metas.length; i < ilen; i++) {
      values = values.concat(metas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__._)(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(scale) {
  const values = getAllScaleValues(scale);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.h)(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = undefined;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index] - (size / 2)
  };
}
function computeFlexCategoryTraits(index, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index];
  let prev = index > 0 ? pixels[index - 1] : null;
  let next = index < pixels.length - 1 ? pixels[index + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.s)(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = 'left';
    end = 'right';
  } else {
    reverse = properties.base < properties.y;
    start = 'bottom';
    end = 'top';
  }
  if (reverse) {
    top = 'end';
    bottom = 'start';
  } else {
    top = 'start';
    bottom = 'end';
  }
  return {start, end, reverse, top, bottom};
}
function setBorderSkipped(properties, options, stack, index) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  const {start, end, reverse, top, bottom} = borderProps(properties);
  if (edge === 'middle' && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index) {
      edge = top;
    } else if ((stack._bottom || 0) === index) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === 'start' ? start : v === 'end' ? end : v;
}
class BarController extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const {iScale, vScale} = meta;
    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;
    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, iAxisKey), i);
      parsed.push(parseValue((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index) {
    const me = this;
    const meta = me._cachedMeta;
    const {iScale, vScale} = meta;
    const parsed = me.getParsed(index);
    const custom = parsed._custom;
    const value = isFloatBar(custom)
      ? '[' + custom.start + ', ' + custom.end + ']'
      : '' + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    const me = this;
    me.enableOptionSharing = true;
    super.initialize();
    const meta = me._cachedMeta;
    meta.stack = me.getDataset().stack;
  }
  update(mode) {
    const me = this;
    const meta = me._cachedMeta;
    me.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const me = this;
    const reset = mode === 'reset';
    const {index, _cachedMeta: {vScale}} = me;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = me._getRuler();
    const firstOpts = me.resolveDataElementOptions(start, mode);
    const sharedOptions = me.getSharedOptions(firstOpts);
    const includeOptions = me.includeOptions(mode, sharedOptions);
    me.updateSharedOptions(sharedOptions, mode, firstOpts);
    for (let i = start; i < start + count; i++) {
      const parsed = me.getParsed(i);
      const vpixels = reset || (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(parsed[vScale.axis]) ? {base, head: base} : me._calculateBarValuePixels(i);
      const ipixels = me._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || me.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);
      }
      setBorderSkipped(properties, properties.options || bars[i].options, stack, index);
      me.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const me = this;
    const meta = me._cachedMeta;
    const iScale = meta.iScale;
    const metasets = iScale.getMatchingVisibleMetas(me._type);
    const stacked = iScale.options.stacked;
    const ilen = metasets.length;
    const stacks = [];
    let i, item;
    for (i = 0; i < ilen; ++i) {
      item = metasets[i];
      if (!item.controller.options.grouped) {
        continue;
      }
      if (typeof dataIndex !== 'undefined') {
        const val = item.controller.getParsed(dataIndex)[
          item.controller._cachedMeta.vScale.axis
        ];
        if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(val) || isNaN(val)) {
          continue;
        }
      }
      if (stacked === false || stacks.indexOf(item.stack) === -1 ||
				(stacked === undefined && item.stack === undefined)) {
        stacks.push(item.stack);
      }
      if (item.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(undefined);
    }
    return stacks;
  }
  _getStackCount(index) {
    return this._getStacks(undefined, index).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index = (name !== undefined)
      ? stacks.indexOf(name)
      : -1;
    return (index === -1)
      ? stacks.length - 1
      : index;
  }
  _getRuler() {
    const me = this;
    const opts = me.options;
    const meta = me._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(me.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(iScale);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: me._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index) {
    const me = this;
    const {_cachedMeta: {vScale, _stacked}, options: {base: baseValue, minBarLength}} = me;
    const actualBase = baseValue || 0;
    const parsed = me.getParsed(index);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? me.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.s)(value) !== (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.s)(custom.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (me.chart.getDataVisibility(index)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      head = base + size;
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.s)(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index, ruler) {
    const me = this;
    const scale = ruler.scale;
    const options = me.options;
    const skipNull = options.skipNull;
    const maxBarThickness = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? me._getStackCount(index) : ruler.stackCount;
      const range = options.barThickness === 'flex'
        ? computeFlexCategoryTraits(index, ruler, options, stackCount)
        : computeFitCategoryTraits(index, ruler, options, stackCount);
      const stackIndex = me._getStackIndex(me.index, me._cachedMeta.stack, skipNull ? index : undefined);
      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(me.getParsed(index)[scale.axis], index);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const me = this;
    const meta = me._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (me.getParsed(i)[vScale.axis] !== null) {
        rects[i].draw(me._ctx);
      }
    }
  }
}
BarController.id = 'bar';
BarController.defaults = {
  datasetElementType: false,
  dataElementType: 'bar',
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: 'number',
      properties: ['x', 'y', 'base', 'width', 'height']
    }
  }
};
BarController.overrides = {
  scales: {
    _index_: {
      type: 'category',
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: 'linear',
      beginAtZero: true,
    }
  }
};

class BubbleController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parseObjectData(meta, data, start, count) {
    const {xScale, yScale} = meta;
    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;
    const parsed = [];
    let i, ilen, item;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      item = data[i];
      parsed.push({
        x: xScale.parse((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.f)(item, xAxisKey), i),
        y: yScale.parse((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.f)(item, yAxisKey), i),
        _custom: item && item.r && +item.r
      });
    }
    return parsed;
  }
  getMaxOverflow() {
    const {data, _parsed} = this._cachedMeta;
    let max = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size() / 2, _parsed[i]._custom);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index) {
    const me = this;
    const meta = me._cachedMeta;
    const {xScale, yScale} = meta;
    const parsed = me.getParsed(index);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: meta.label,
      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'
    };
  }
  update(mode) {
    const me = this;
    const points = me._cachedMeta.data;
    me.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const me = this;
    const reset = mode === 'reset';
    const {iScale, vScale} = me._cachedMeta;
    const firstOpts = me.resolveDataElementOptions(start, mode);
    const sharedOptions = me.getSharedOptions(firstOpts);
    const includeOptions = me.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && me.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = me.resolveDataElementOptions(i, point.active ? 'active' : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      me.updateElement(point, i, properties, mode);
    }
    me.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  resolveDataElementOptions(index, mode) {
    const parsed = this.getParsed(index);
    let values = super.resolveDataElementOptions(index, mode);
    if (values.$shared) {
      values = Object.assign({}, values, {$shared: false});
    }
    const radius = values.radius;
    if (mode !== 'active') {
      values.radius = 0;
    }
    values.radius += (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(parsed && parsed._custom, radius);
    return values;
  }
}
BubbleController.id = 'bubble';
BubbleController.defaults = {
  datasetElementType: false,
  dataElementType: 'point',
  animations: {
    numbers: {
      type: 'number',
      properties: ['x', 'y', 'borderWidth', 'radius']
    }
  }
};
BubbleController.overrides = {
  scales: {
    x: {
      type: 'linear'
    },
    y: {
      type: 'linear'
    }
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return '';
        }
      }
    }
  }
};

function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.o)(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.o)(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);
    const minX = calcMin(_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.P, startX, endX);
    const minY = calcMin(_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.P + _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {ratioX, ratioY, offsetX, offsetY};
}
class DoughnutController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = undefined;
    this.outerRadius = undefined;
    this.offsetX = undefined;
    this.offsetY = undefined;
  }
  linkScales() {}
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    let i, ilen;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      meta._parsed[i] = +data[i];
    }
  }
  _getRotation() {
    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.rotation - 90);
  }
  _getCircumference() {
    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.circumference);
  }
  _getRotationExtents() {
    let min = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T;
    let max = -_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T;
    const me = this;
    for (let i = 0; i < me.chart.data.datasets.length; ++i) {
      if (me.chart.isDatasetVisible(i)) {
        const controller = me.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min,
    };
  }
  update(mode) {
    const me = this;
    const chart = me.chart;
    const {chartArea} = chart;
    const meta = me._cachedMeta;
    const arcs = meta.data;
    const spacing = me.getMaxBorderWidth() + me.getMaxOffset(arcs) + me.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.k)(me.options.cutout, maxSize), 1);
    const chartWeight = me._getRingWeight(me.index);
    const {circumference, rotation} = me._getRotationExtents();
    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.m)(me.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / me._getVisibleDatasetWeightTotal();
    me.offsetX = offsetX * outerRadius;
    me.offsetY = offsetY * outerRadius;
    meta.total = me.calculateTotal();
    me.outerRadius = outerRadius - radiusLength * me._getRingWeightOffset(me.index);
    me.innerRadius = Math.max(me.outerRadius - radiusLength * chartWeight, 0);
    me.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const me = this;
    const opts = me.options;
    const meta = me._cachedMeta;
    const circumference = me._getCircumference();
    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return me.calculateCircumference(meta._parsed[i] * circumference / _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T);
  }
  updateElements(arcs, start, count, mode) {
    const me = this;
    const reset = mode === 'reset';
    const chart = me.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : me.innerRadius;
    const outerRadius = animateScale ? 0 : me.outerRadius;
    const firstOpts = me.resolveDataElementOptions(start, mode);
    const sharedOptions = me.getSharedOptions(firstOpts);
    const includeOptions = me.includeOptions(mode, sharedOptions);
    let startAngle = me._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += me._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = me._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + me.offsetX,
        y: centerY + me.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || me.resolveDataElementOptions(i, arc.active ? 'active' : mode);
      }
      startAngle += circumference;
      me.updateElement(arc, i, properties, mode);
    }
    me.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index) {
    const me = this;
    const meta = me._cachedMeta;
    const chart = me.chart;
    const labels = chart.data.labels || [];
    const value = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.n)(meta._parsed[index], chart.options.locale);
    return {
      label: labels[index] || '',
      value,
    };
  }
  getMaxBorderWidth(arcs) {
    const me = this;
    let max = 0;
    const chart = me.chart;
    let i, ilen, meta, controller, options;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          if (controller !== me) {
            controller.configure();
          }
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options = controller.resolveDataElementOptions(i);
      if (options.borderAlign !== 'inner') {
        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options = this.resolveDataElementOptions(i);
      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
DoughnutController.id = 'doughnut';
DoughnutController.defaults = {
  datasetElementType: false,
  dataElementType: 'arc',
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: 'number',
      properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']
    },
  },
  cutout: '50%',
  rotation: 0,
  circumference: 360,
  radius: '100%',
  spacing: 0,
  indexAxis: 'r',
};
DoughnutController.descriptors = {
  _scriptable: (name) => name !== 'spacing',
  _indexable: (name) => name !== 'spacing',
};
DoughnutController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const {labels: {pointStyle}} = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle: pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return '';
        },
        label(tooltipItem) {
          let dataLabel = tooltipItem.label;
          const value = ': ' + tooltipItem.formattedValue;
          if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(dataLabel)) {
            dataLabel = dataLabel.slice();
            dataLabel[0] += value;
          } else {
            dataLabel += value;
          }
          return dataLabel;
        }
      }
    }
  }
};

class LineController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  update(mode) {
    const me = this;
    const meta = me._cachedMeta;
    const {dataset: line, data: points = [], _dataset} = meta;
    const animationsDisabled = me.chart._animationsDisabled;
    let {start, count} = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    me._drawStart = start;
    me._drawCount = count;
    if (scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._datasetIndex = me.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = me.resolveDatasetElementOptions(mode);
    if (!me.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = me.options.segment;
    me.updateElement(line, undefined, {
      animated: !animationsDisabled,
      options
    }, mode);
    me.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const me = this;
    const reset = mode === 'reset';
    const {iScale, vScale, _stacked} = me._cachedMeta;
    const firstOpts = me.resolveDataElementOptions(start, mode);
    const sharedOptions = me.getSharedOptions(firstOpts);
    const includeOptions = me.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const spanGaps = me.options.spanGaps;
    const maxGapLength = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.p)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = me.chart._animationsDisabled || reset || mode === 'none';
    let prevParsed = start > 0 && me.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = me.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? me.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && (parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      properties.parsed = parsed;
      if (includeOptions) {
        properties.options = sharedOptions || me.resolveDataElementOptions(i, point.active ? 'active' : mode);
      }
      if (!directUpdate) {
        me.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    me.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const me = this;
    const meta = me._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(me.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(me.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
}
LineController.id = 'line';
LineController.defaults = {
  datasetElementType: 'line',
  dataElementType: 'point',
  showLine: true,
  spanGaps: false,
};
LineController.overrides = {
  scales: {
    _index_: {
      type: 'category',
    },
    _value_: {
      type: 'linear',
    },
  }
};
function getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const {iScale, _parsed} = meta;
    const axis = iScale.axis;
    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
    if (minDefined) {
      start = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(Math.min(
        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(_parsed, iScale.axis, min).lo,
        animationsDisabled ? pointCount : (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(points, axis, iScale.getPixelForValue(min)).lo),
      0, pointCount - 1);
    }
    if (maxDefined) {
      count = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(Math.max(
        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(_parsed, iScale.axis, max).hi + 1,
        animationsDisabled ? 0 : (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(points, axis, iScale.getPixelForValue(max)).hi + 1),
      start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return {start, count};
}
function scaleRangesChanged(meta) {
  const {xScale, yScale, _scaleRanges} = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min
		|| _scaleRanges.xmax !== xScale.max
		|| _scaleRanges.ymin !== yScale.min
		|| _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}

class PolarAreaController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = undefined;
    this.outerRadius = undefined;
  }
  getLabelAndValue(index) {
    const me = this;
    const meta = me._cachedMeta;
    const chart = me.chart;
    const labels = chart.data.labels || [];
    const value = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.n)(meta._parsed[index].r, chart.options.locale);
    return {
      label: labels[index] || '',
      value,
    };
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _updateRadius() {
    const me = this;
    const chart = me.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    me.outerRadius = outerRadius - (radiusLength * me.index);
    me.innerRadius = me.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const me = this;
    const reset = mode === 'reset';
    const chart = me.chart;
    const dataset = me.getDataset();
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = me._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.P;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / me.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += me._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + me._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: me.resolveDataElementOptions(i, arc.active ? 'active' : mode)
      };
      me.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const dataset = this.getDataset();
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index) => {
      if (!isNaN(dataset.data[index]) && this.chart.getDataVisibility(index)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index, mode, defaultAngle) {
    return this.chart.getDataVisibility(index)
      ? (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(this.resolveDataElementOptions(index, mode).angle || defaultAngle)
      : 0;
  }
}
PolarAreaController.id = 'polarArea';
PolarAreaController.defaults = {
  dataElementType: 'arc',
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: 'number',
      properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']
    },
  },
  indexAxis: 'r',
  startAngle: 0,
};
PolarAreaController.overrides = {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const {labels: {pointStyle}} = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                pointStyle: pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    },
    tooltip: {
      callbacks: {
        title() {
          return '';
        },
        label(context) {
          return context.chart.data.labels[context.dataIndex] + ': ' + context.formattedValue;
        }
      }
    }
  },
  scales: {
    r: {
      type: 'radialLinear',
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
};

class PieController extends DoughnutController {
}
PieController.id = 'pie';
PieController.defaults = {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: '100%'
};

class RadarController extends DatasetController {
  getLabelAndValue(index) {
    const me = this;
    const vScale = me._cachedMeta.vScale;
    const parsed = me.getParsed(index);
    return {
      label: vScale.getLabels()[index],
      value: '' + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  update(mode) {
    const me = this;
    const meta = me._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== 'resize') {
      const options = me.resolveDatasetElementOptions(mode);
      if (!me.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      me.updateElement(line, undefined, properties, mode);
    }
    me.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const me = this;
    const dataset = me.getDataset();
    const scale = me._cachedMeta.rScale;
    const reset = mode === 'reset';
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options = me.resolveDataElementOptions(i, point.active ? 'active' : mode);
      const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options
      };
      me.updateElement(point, i, properties, mode);
    }
  }
}
RadarController.id = 'radar';
RadarController.defaults = {
  datasetElementType: 'line',
  dataElementType: 'point',
  indexAxis: 'r',
  showLine: true,
  elements: {
    line: {
      fill: 'start'
    }
  },
};
RadarController.overrides = {
  aspectRatio: 1,
  scales: {
    r: {
      type: 'radialLinear',
    }
  }
};

class ScatterController extends LineController {
}
ScatterController.id = 'scatter';
ScatterController.defaults = {
  showLine: false,
  fill: false
};
ScatterController.overrides = {
  interaction: {
    mode: 'point'
  },
  plugins: {
    tooltip: {
      callbacks: {
        title() {
          return '';
        },
        label(item) {
          return '(' + item.label + ', ' + item.formattedValue + ')';
        }
      }
    }
  },
  scales: {
    x: {
      type: 'linear'
    },
    y: {
      type: 'linear'
    }
  }
};

var controllers = /*#__PURE__*/Object.freeze({
__proto__: null,
BarController: BarController,
BubbleController: BubbleController,
DoughnutController: DoughnutController,
LineController: LineController,
PolarAreaController: PolarAreaController,
PieController: PieController,
RadarController: RadarController,
ScatterController: ScatterController
});

function abstract() {
  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');
}
class DateAdapter {
  constructor(options) {
    this.options = options || {};
  }
  formats() {
    return abstract();
  }
  parse(value, format) {
    return abstract();
  }
  format(timestamp, format) {
    return abstract();
  }
  add(timestamp, amount, unit) {
    return abstract();
  }
  diff(a, b, unit) {
    return abstract();
  }
  startOf(timestamp, unit, weekday) {
    return abstract();
  }
  endOf(timestamp, unit) {
    return abstract();
  }
}
DateAdapter.override = function(members) {
  Object.assign(DateAdapter.prototype, members);
};
var adapters = {
  _date: DateAdapter
};

function getRelativePosition(e, chart) {
  if ('native' in e) {
    return {
      x: e.x,
      y: e.y
    };
  }
  return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.x)(e, chart);
}
function evaluateAllVisibleItems(chart, handler) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  let index, data, element;
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    ({index, data} = metasets[i]);
    for (let j = 0, jlen = data.length; j < jlen; ++j) {
      element = data[j];
      if (!element.skip) {
        handler(element, index, j);
      }
    }
  }
}
function binarySearch(metaset, axis, value, intersect) {
  const {controller, data, _sorted} = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.z : _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === 'function' && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {lo: start.lo, hi: end.hi};
      }
    }
  }
  return {lo: 0, hi: data.length - 1};
}
function optimizedEvaluateItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const {index, data} = metasets[i];
    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf('x') !== -1;
  const useY = axis.indexOf('y') !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition) {
  const items = [];
  if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.y)(position, chart.chartArea, chart._minPadding)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index) {
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({element, datasetIndex, index});
    }
  };
  optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition) {
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  let items = [];
  if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.y)(position, chart.chartArea, chart._minPadding)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index) {
    if (intersect && !element.inRange(position.x, position.y, useFinalPosition)) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.y)(center, chart.chartArea, chart._minPadding) && !element.inRange(position.x, position.y, useFinalPosition)) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [{element, datasetIndex, index}];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({element, datasetIndex, index});
    }
  };
  optimizedEvaluateItems(chart, axis, position, evaluationFunc);
  return items;
}
function getAxisItems(chart, e, options, useFinalPosition) {
  const position = getRelativePosition(e, chart);
  const items = [];
  const axis = options.axis;
  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';
  let intersectsItem = false;
  evaluateAllVisibleItems(chart, (element, datasetIndex, index) => {
    if (element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({element, datasetIndex, index});
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      intersectsItem = true;
    }
  });
  if (options.intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  modes: {
    index(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'x';
      const items = options.intersect
        ? getIntersectItems(chart, position, axis, useFinalPosition)
        : getNearestItems(chart, position, axis, false, useFinalPosition);
      const elements = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index = items[0].index;
        const element = meta.data[index];
        if (element && !element.skip) {
          elements.push({element, datasetIndex: meta.index, index});
        }
      });
      return elements;
    },
    dataset(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'xy';
      let items = options.intersect
        ? getIntersectItems(chart, position, axis, useFinalPosition) :
        getNearestItems(chart, position, axis, false, useFinalPosition);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({element: data[i], datasetIndex, index: i});
        }
      }
      return items;
    },
    point(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'xy';
      return getIntersectItems(chart, position, axis, useFinalPosition);
    },
    nearest(chart, e, options, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options.axis || 'xy';
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition);
    },
    x(chart, e, options, useFinalPosition) {
      options.axis = 'x';
      return getAxisItems(chart, e, options, useFinalPosition);
    },
    y(chart, e, options, useFinalPosition) {
      options.axis = 'y';
      return getAxisItems(chart, e, options, useFinalPosition);
    }
  }
};

const STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];
function filterByPosition(array, position) {
  return array.filter(v => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ?
      v0.index - v1.index :
      v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({position: pos, options: {stack, stackWeight = 1}} = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && (pos + stack),
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts) {
  const stacks = {};
  for (const wrap of layouts) {
    const {stack, pos, stackWeight} = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts, params) {
  const stacks = buildStacks(layouts);
  const {vBoxMaxWidth, hBoxMaxHeight} = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts.length; i < ilen; ++i) {
    layout = layouts[i];
    const {fullSize} = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, 'chartArea'),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const {pos, box} = layout;
  const maxPadding = chartArea.maxPadding;
  if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {size: 0, count: 1};
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal
    ? {same: widthChanged, other: heightChanged}
    : {same: heightChanged, other: widthChanged};
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos('top');
  chartArea.x += updatePos('left');
  updatePos('right');
  updatePos('bottom');
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions) {
    const margin = {left: 0, top: 0, right: 0, bottom: 0};
    positions.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal
    ? marginForPositions(['left', 'right'])
    : marginForPositions(['top', 'bottom']);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(
      layout.width || chartArea.w,
      layout.height || chartArea.h,
      getMargins(layout.horizontal, chartArea)
    );
    const {same, other} = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let {x, y} = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};
    const weight = (layout.stackWeight / stack.weight) || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.h)(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.h)(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.set('layout', {
  padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }
});
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || 'top';
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [{
        z: 0,
        draw(chartArea) {
          item.draw(chartArea);
        }
      }];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index !== -1) {
      chart.boxes.splice(index, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.A)(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(chart.boxes, box => {
      if (typeof box.beforeLayout === 'function') {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>
      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.A)(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w,
    };
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h);
    });
  }
};

class BasePlatform {
  acquireContext(canvas, aspectRatio) {}
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {}
  removeEventListener(chart, type, listener) {}
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
}

class BasicPlatform extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext('2d') || null;
  }
}

const EXPANDO_KEY = '$chartjs';
const EVENT_TYPES = {
  touchstart: 'mousedown',
  touchmove: 'mousemove',
  touchend: 'mouseup',
  pointerenter: 'mouseenter',
  pointerdown: 'mousedown',
  pointermove: 'mousemove',
  pointerup: 'mouseup',
  pointerleave: 'mouseout',
  pointerout: 'mouseout'
};
const isNullOrEmpty = value => value === null || value === '';
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute('height');
  const renderWidth = canvas.getAttribute('width');
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || 'block';
  style.boxSizing = style.boxSizing || 'border-box';
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.E)(canvas, 'width');
    if (displayWidth !== undefined) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === '') {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.E)(canvas, 'height');
      if (displayHeight !== undefined) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
const eventListenerOptions = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.G ? {passive: true} : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const {x, y} = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.x)(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== undefined ? x : null,
    y: y !== undefined ? y : null,
  };
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(canvas);
  const element = container || canvas;
  const observer = new MutationObserver(entries => {
    const parent = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(element);
    entries.forEach(entry => {
      for (let i = 0; i < entry.addedNodes.length; i++) {
        const added = entry.addedNodes[i];
        if (added === element || added === parent) {
          listener(entry.target);
        }
      }
    });
  });
  observer.observe(document, {childList: true, subtree: true});
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(canvas);
  if (!container) {
    return;
  }
  const observer = new MutationObserver(entries => {
    entries.forEach(entry => {
      for (let i = 0; i < entry.removedNodes.length; i++) {
        if (entry.removedNodes[i] === canvas) {
          listener();
          break;
        }
      }
    });
  });
  observer.observe(container, {childList: true});
  return observer;
}
const drpListeningCharts = new Map();
let oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener('resize', onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener('resize', onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(canvas);
  if (!container) {
    return;
  }
  const resize = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.F)((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver(entries => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === 'resize') {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.F)((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart, (args) => {
    const event = args[0];
    return [event, event.offsetX, event.offsetY];
  });
  addListener(canvas, type, proxy);
  return proxy;
}
class DomPlatform extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext('2d');
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    ['height', 'width'].forEach((prop) => {
      const value = initial[prop];
      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = undefined;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.C)(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.D)(canvas);
    return !!(container && container.isConnected);
  }
}

function _detectPlatform(canvas) {
  if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.I)() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {
    return BasicPlatform;
  }
  return DomPlatform;
}

class Element {
  constructor() {
    this.x = undefined;
    this.y = undefined;
    this.active = false;
    this.options = undefined;
    this.$animations = undefined;
  }
  tooltipPosition(useFinalPosition) {
    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);
    return {x, y};
  }
  hasValue() {
    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.p)(this.x) && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.p)(this.y);
  }
  getProps(props, final) {
    const me = this;
    const anims = this.$animations;
    if (!final || !anims) {
      return me;
    }
    const ret = {};
    props.forEach(prop => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : me[prop];
    });
    return ret;
  }
}
Element.defaults = {};
Element.defaultRoutes = undefined;

const formatters = {
  values(value) {
    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(value) ? value : '' + value;
  },
  numeric(tickValue, index, ticks) {
    if (tickValue === 0) {
      return '0';
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e+15) {
        notation = 'scientific';
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.J)(Math.abs(delta));
    const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};
    Object.assign(options, this.options.ticks.format);
    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.n)(tickValue, locale, options);
  },
  logarithmic(tickValue, index, ticks) {
    if (tickValue === 0) {
      return '0';
    }
    const remain = tickValue / (Math.pow(10, Math.floor((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.J)(tickValue))));
    if (remain === 1 || remain === 2 || remain === 5) {
      return formatters.numeric.call(this, tickValue, index, ticks);
    }
    return '';
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {formatters};

_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.set('scale', {
  display: true,
  offset: false,
  reverse: false,
  beginAtZero: false,
  bounds: 'ticks',
  grace: 0,
  grid: {
    display: true,
    lineWidth: 1,
    drawBorder: true,
    drawOnChartArea: true,
    drawTicks: true,
    tickLength: 8,
    tickWidth: (_ctx, options) => options.lineWidth,
    tickColor: (_ctx, options) => options.color,
    offset: false,
    borderDash: [],
    borderDashOffset: 0.0,
    borderWidth: 1
  },
  title: {
    display: false,
    text: '',
    padding: {
      top: 4,
      bottom: 4
    }
  },
  ticks: {
    minRotation: 0,
    maxRotation: 50,
    mirror: false,
    textStrokeWidth: 0,
    textStrokeColor: '',
    padding: 3,
    display: true,
    autoSkip: true,
    autoSkipPadding: 3,
    labelOffset: 0,
    callback: Ticks.formatters.values,
    minor: {},
    major: {},
    align: 'center',
    crossAlign: 'near',
    showLabelBackdrop: false,
    backdropColor: 'rgba(255, 255, 255, 0.75)',
    backdropPadding: 2,
  }
});
_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.route('scale.ticks', 'color', '', 'color');
_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.route('scale.grid', 'color', '', 'borderColor');
_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.route('scale.grid', 'borderColor', '', 'borderColor');
_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.route('scale.title', 'color', '', 'color');
_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.describe('scale', {
  _fallback: false,
  _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',
  _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash',
});
_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.describe('scales', {
  _fallback: 'scale',
});
_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.describe('scale.ticks', {
  _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',
  _indexable: (name) => name !== 'backdropPadding',
});

function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.K)(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(majorStart, 0);
  const end = Math.min((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}

const reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;
const offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex = Math.min(index, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
    }
    lineValue += validIndex < index ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(options.font, fallback);
  const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.A)(options.padding);
  const lines = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(options.text) ? options.text.length : 1;
  return (lines * font.lineHeight) + padding.height;
}
function createScaleContext(parent, scale) {
  return Object.assign(Object.create(parent), {
    scale,
    type: 'scale'
  });
}
function createTickContext(parent, index, tick) {
  return Object.assign(Object.create(parent), {
    tick,
    index,
    type: 'tick'
  });
}
function titleAlign(align, position, reverse) {
  let ret = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Y)(align);
  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const {top, left, bottom, right, chart} = scale;
  const {chartArea, scales} = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(align, left, right);
    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === 'center') {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === 'center') {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(align, bottom, top);
    rotation = position === 'left' ? -_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H : _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H;
  }
  return {titleX, titleY, maxWidth, rotation};
}
class Scale extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = undefined;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.width = undefined;
    this.height = undefined;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = undefined;
    this.maxHeight = undefined;
    this.paddingTop = undefined;
    this.paddingBottom = undefined;
    this.paddingLeft = undefined;
    this.paddingRight = undefined;
    this.axis = undefined;
    this.labelRotation = undefined;
    this.min = undefined;
    this.max = undefined;
    this._range = undefined;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = undefined;
    this._endPixel = undefined;
    this._reversePixels = false;
    this._userMax = undefined;
    this._userMin = undefined;
    this._suggestedMax = undefined;
    this._suggestedMin = undefined;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = undefined;
  }
  init(options) {
    const me = this;
    me.options = options.setContext(me.getContext());
    me.axis = options.axis;
    me._userMin = me.parse(options.min);
    me._userMax = me.parse(options.max);
    me._suggestedMin = me.parse(options.suggestedMin);
    me._suggestedMax = me.parse(options.suggestedMax);
  }
  parse(raw, index) {
    return raw;
  }
  getUserBounds() {
    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;
    _userMin = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(_userMin, Number.POSITIVE_INFINITY);
    _userMax = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(_userMin, _suggestedMin),
      max: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(_userMax, _suggestedMax),
      minDefined: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(_userMin),
      maxDefined: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(_userMax)
    };
  }
  getMinMax(canStack) {
    const me = this;
    let {min, max, minDefined, maxDefined} = me.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {min, max};
    }
    const metas = me.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(me, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    return {
      min: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(min, (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(max, min)),
      max: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(max, (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(min, max))
    };
  }
  getPadding() {
    const me = this;
    return {
      left: me.paddingLeft || 0,
      top: me.paddingTop || 0,
      right: me.paddingRight || 0,
      bottom: me.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(this.options.beforeUpdate, [this]);
  }
  update(maxWidth, maxHeight, margins) {
    const me = this;
    const tickOpts = me.options.ticks;
    const sampleSize = tickOpts.sampleSize;
    me.beforeUpdate();
    me.maxWidth = maxWidth;
    me.maxHeight = maxHeight;
    me._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    me.ticks = null;
    me._labelSizes = null;
    me._gridLineItems = null;
    me._labelItems = null;
    me.beforeSetDimensions();
    me.setDimensions();
    me.afterSetDimensions();
    me._maxLength = me.isHorizontal()
      ? me.width + margins.left + margins.right
      : me.height + margins.top + margins.bottom;
    if (!me._dataLimitsCached) {
      me.beforeDataLimits();
      me.determineDataLimits();
      me.afterDataLimits();
      me._range = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.N)(me, me.options.grace);
      me._dataLimitsCached = true;
    }
    me.beforeBuildTicks();
    me.ticks = me.buildTicks() || [];
    me.afterBuildTicks();
    const samplingEnabled = sampleSize < me.ticks.length;
    me._convertTicksToLabels(samplingEnabled ? sample(me.ticks, sampleSize) : me.ticks);
    me.configure();
    me.beforeCalculateLabelRotation();
    me.calculateLabelRotation();
    me.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {
      me.ticks = autoSkip(me, me.ticks);
      me._labelSizes = null;
    }
    if (samplingEnabled) {
      me._convertTicksToLabels(me.ticks);
    }
    me.beforeFit();
    me.fit();
    me.afterFit();
    me.afterUpdate();
  }
  configure() {
    const me = this;
    let reversePixels = me.options.reverse;
    let startPixel, endPixel;
    if (me.isHorizontal()) {
      startPixel = me.left;
      endPixel = me.right;
    } else {
      startPixel = me.top;
      endPixel = me.bottom;
      reversePixels = !reversePixels;
    }
    me._startPixel = startPixel;
    me._endPixel = endPixel;
    me._reversePixels = reversePixels;
    me._length = endPixel - startPixel;
    me._alignToPixels = me.options.alignToPixels;
  }
  afterUpdate() {
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(this.options.afterUpdate, [this]);
  }
  beforeSetDimensions() {
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(this.options.beforeSetDimensions, [this]);
  }
  setDimensions() {
    const me = this;
    if (me.isHorizontal()) {
      me.width = me.maxWidth;
      me.left = 0;
      me.right = me.width;
    } else {
      me.height = me.maxHeight;
      me.top = 0;
      me.bottom = me.height;
    }
    me.paddingLeft = 0;
    me.paddingTop = 0;
    me.paddingRight = 0;
    me.paddingBottom = 0;
  }
  afterSetDimensions() {
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(this.options.afterSetDimensions, [this]);
  }
  _callHooks(name) {
    const me = this;
    me.chart.notifyPlugins(name, me.getContext());
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(me.options[name], [me]);
  }
  beforeDataLimits() {
    this._callHooks('beforeDataLimits');
  }
  determineDataLimits() {}
  afterDataLimits() {
    this._callHooks('afterDataLimits');
  }
  beforeBuildTicks() {
    this._callHooks('beforeBuildTicks');
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks('afterBuildTicks');
  }
  beforeTickToLabelConversion() {
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(this.options.beforeTickToLabelConversion, [this]);
  }
  generateTickLabels(ticks) {
    const me = this;
    const tickOpts = me.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(tickOpts.callback, [tick.value, i, ticks], me);
    }
  }
  afterTickToLabelConversion() {
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(this.options.afterTickToLabelConversion, [this]);
  }
  beforeCalculateLabelRotation() {
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(this.options.beforeCalculateLabelRotation, [this]);
  }
  calculateLabelRotation() {
    const me = this;
    const options = me.options;
    const tickOpts = options.ticks;
    const numTicks = me.ticks.length;
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {
      me.labelRotation = minRotation;
      return;
    }
    const labelSizes = me._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(me.chart.width - maxLabelWidth, 0, me.maxWidth);
    tickWidth = options.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = me.maxHeight - getTickMarkLength(options.grid)
				- tickOpts.padding - getTitleHeight(options.title, me.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(Math.min(
        Math.asin((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)((labelSizes.highest.height + 6) / tickWidth, -1, 1)),
        Math.asin((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(maxLabelHeight / maxLabelDiagonal, -1, 1))
      ));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    me.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(this.options.afterCalculateLabelRotation, [this]);
  }
  beforeFit() {
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(this.options.beforeFit, [this]);
  }
  fit() {
    const me = this;
    const minSize = {
      width: 0,
      height: 0
    };
    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = me;
    const display = me._isVisible();
    const isHorizontal = me.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = me.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = me.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && me.ticks.length) {
        const {first, last, widest, highest} = me._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(me.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(me.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        me._calculatePadding(first, last, sin, cos);
      }
    }
    me._handleMargins();
    if (isHorizontal) {
      me.width = me._length = chart.width - me._margins.left - me._margins.right;
      me.height = minSize.height;
    } else {
      me.width = minSize.width;
      me.height = me._length = chart.height - me._margins.top - me._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const me = this;
    const {ticks: {align, padding}, position} = me.options;
    const isRotated = me.labelRotation !== 0;
    const labelsBelowTicks = position !== 'top' && me.axis === 'x';
    if (me.isHorizontal()) {
      const offsetLeft = me.getPixelForTick(0) - me.left;
      const offsetRight = me.right - me.getPixelForTick(me.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === 'start') {
        paddingRight = last.width;
      } else if (align === 'end') {
        paddingLeft = first.width;
      } else {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      me.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * me.width / (me.width - offsetLeft), 0);
      me.paddingRight = Math.max((paddingRight - offsetRight + padding) * me.width / (me.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === 'start') {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === 'end') {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      me.paddingTop = paddingTop + padding;
      me.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    const me = this;
    if (me._margins) {
      me._margins.left = Math.max(me.paddingLeft, me._margins.left);
      me._margins.top = Math.max(me.paddingTop, me._margins.top);
      me._margins.right = Math.max(me.paddingRight, me._margins.right);
      me._margins.bottom = Math.max(me.paddingBottom, me._margins.bottom);
    }
  }
  afterFit() {
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(this.options.afterFit, [this]);
  }
  isHorizontal() {
    const {axis, position} = this.options;
    return position === 'top' || position === 'bottom' || axis === 'x';
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    const me = this;
    me.beforeTickToLabelConversion();
    me.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    me.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    const me = this;
    let labelSizes = me._labelSizes;
    if (!labelSizes) {
      const sampleSize = me.options.ticks.sampleSize;
      let ticks = me.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      me._labelSizes = labelSizes = me._computeLabelSizes(ticks, ticks.length);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length) {
    const {ctx, _longestTextCache: caches} = this;
    const widths = [];
    const heights = [];
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; ++i) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(label) && !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {
        width = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Q)(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(nestedLabel) && !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(nestedLabel)) {
            width = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Q)(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights,
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index) {
    return NaN;
  }
  getValueForPixel(pixel) {}
  getPixelForTick(index) {
    const ticks = this.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index].value);
  }
  getPixelForDecimal(decimal) {
    const me = this;
    if (me._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = me._startPixel + decimal * me._length;
    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.R)(me._alignToPixels ? (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.S)(me.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const {min, max} = this;
    return min < 0 && max < 0 ? max :
      min > 0 && max > 0 ? min :
      0;
  }
  getContext(index) {
    const me = this;
    const ticks = me.ticks || [];
    if (index >= 0 && index < ticks.length) {
      const tick = ticks[index];
      return tick.$context ||
				(tick.$context = createTickContext(me.getContext(), index, tick));
    }
    return me.$context ||
			(me.$context = createScaleContext(me.chart.getContext(), me));
  }
  _tickSize() {
    const me = this;
    const optionTicks = me.options.ticks;
    const rot = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(me.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = me._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return me.isHorizontal()
      ? h * cos > w * sin ? w / cos : h / sin
      : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== 'auto') {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const me = this;
    const axis = me.axis;
    const chart = me.chart;
    const options = me.options;
    const {grid, position} = options;
    const offset = grid.offset;
    const isHorizontal = me.isHorizontal();
    const ticks = me.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = grid.setContext(me.getContext());
    const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.S)(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === 'top') {
      borderValue = alignBorderValue(me.bottom);
      ty1 = me.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === 'bottom') {
      borderValue = alignBorderValue(me.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = me.top + tl;
    } else if (position === 'left') {
      borderValue = alignBorderValue(me.right);
      tx1 = me.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === 'right') {
      borderValue = alignBorderValue(me.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = me.left + tl;
    } else if (axis === 'x') {
      if (position === 'center') {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(me.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === 'y') {
      if (position === 'center') {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(me.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const optsAtIndex = grid.setContext(me.getContext(i));
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = grid.borderDash || [];
      const borderDashOffset = optsAtIndex.borderDashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(me, i, offset);
      if (lineValue === undefined) {
        continue;
      }
      alignedLineValue = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.S)(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset,
      });
    }
    me._ticksLength = ticksLength;
    me._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const me = this;
    const axis = me.axis;
    const options = me.options;
    const {position, ticks: optionTicks} = options;
    const isHorizontal = me.isHorizontal();
    const ticks = me.ticks;
    const {align, crossAlign, padding, mirror} = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(me.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = 'middle';
    if (position === 'top') {
      y = me.bottom - hTickAndPadding;
      textAlign = me._getXAxisLabelAlignment();
    } else if (position === 'bottom') {
      y = me.top + hTickAndPadding;
      textAlign = me._getXAxisLabelAlignment();
    } else if (position === 'left') {
      const ret = me._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === 'right') {
      const ret = me._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === 'x') {
      if (position === 'center') {
        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;
      } else if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = me.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = me._getXAxisLabelAlignment();
    } else if (axis === 'y') {
      if (position === 'center') {
        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;
      } else if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = me.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = me._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === 'y') {
      if (align === 'start') {
        textBaseline = 'top';
      } else if (align === 'end') {
        textBaseline = 'bottom';
      }
    }
    const labelSizes = me._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(me.getContext(i));
      pixel = me.getPixelForTick(i) + optionTicks.labelOffset;
      font = me._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      if (isHorizontal) {
        x = pixel;
        if (position === 'top') {
          if (crossAlign === 'near' || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === 'center') {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === 'near' || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === 'center') {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.A)(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = y + textOffset - labelPadding.top;
        let left = x - labelPadding.left;
        switch (textBaseline) {
        case 'middle':
          top -= height / 2;
          break;
        case 'bottom':
          top -= height;
          break;
        }
        switch (textAlign) {
        case 'center':
          left -= width / 2;
          break;
        case 'right':
          left -= width;
          break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor,
        };
      }
      items.push({
        rotation,
        label,
        font,
        color,
        strokeColor,
        strokeWidth,
        textOffset,
        textAlign,
        textBaseline,
        translation: [x, y],
        backdrop,
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const me = this;
    const {position, ticks} = me.options;
    const rotation = -(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(me.labelRotation);
    if (rotation) {
      return position === 'top' ? 'left' : 'right';
    }
    let align = 'center';
    if (ticks.align === 'start') {
      align = 'left';
    } else if (ticks.align === 'end') {
      align = 'right';
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const me = this;
    const {position, ticks: {crossAlign, mirror, padding}} = me.options;
    const labelSizes = me._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === 'left') {
      if (mirror) {
        x = me.right + padding;
        if (crossAlign === 'near') {
          textAlign = 'left';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x += (widest / 2);
        } else {
          textAlign = 'right';
          x += widest;
        }
      } else {
        x = me.right - tickAndPadding;
        if (crossAlign === 'near') {
          textAlign = 'right';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x -= (widest / 2);
        } else {
          textAlign = 'left';
          x = me.left;
        }
      }
    } else if (position === 'right') {
      if (mirror) {
        x = me.left + padding;
        if (crossAlign === 'near') {
          textAlign = 'right';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x -= (widest / 2);
        } else {
          textAlign = 'left';
          x -= widest;
        }
      } else {
        x = me.left + tickAndPadding;
        if (crossAlign === 'near') {
          textAlign = 'left';
        } else if (crossAlign === 'center') {
          textAlign = 'center';
          x += widest / 2;
        } else {
          textAlign = 'right';
          x = me.right;
        }
      }
    } else {
      textAlign = 'right';
    }
    return {textAlign, x};
  }
  _computeLabelArea() {
    const me = this;
    if (me.options.ticks.mirror) {
      return;
    }
    const chart = me.chart;
    const position = me.options.position;
    if (position === 'left' || position === 'right') {
      return {top: 0, left: me.left, bottom: chart.height, right: me.right};
    } if (position === 'top' || position === 'bottom') {
      return {top: me.top, left: 0, bottom: me.bottom, right: chart.width};
    }
  }
  drawBackground() {
    const {ctx, options: {backgroundColor}, left, top, width, height} = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const me = this;
    const grid = me.options.grid;
    if (!me._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = me.ticks;
    const index = ticks.findIndex(t => t.value === value);
    if (index >= 0) {
      const opts = grid.setContext(me.getContext(index));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const me = this;
    const grid = me.options.grid;
    const ctx = me.ctx;
    const items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine(
            {x: item.x1, y: item.y1},
            {x: item.x2, y: item.y2},
            item
          );
        }
        if (grid.drawTicks) {
          drawLine(
            {x: item.tx1, y: item.ty1},
            {x: item.tx2, y: item.ty2},
            {
              color: item.tickColor,
              width: item.tickWidth,
              borderDash: item.tickBorderDash,
              borderDashOffset: item.tickBorderDashOffset
            }
          );
        }
      }
    }
  }
  drawBorder() {
    const me = this;
    const {chart, ctx, options: {grid}} = me;
    const borderOpts = grid.setContext(me.getContext());
    const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(me.getContext(0)).lineWidth;
    const borderValue = me._borderValue;
    let x1, x2, y1, y2;
    if (me.isHorizontal()) {
      x1 = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.S)(chart, me.left, axisWidth) - axisWidth / 2;
      x2 = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.S)(chart, me.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.S)(chart, me.top, axisWidth) - axisWidth / 2;
      y2 = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.S)(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.borderWidth;
    ctx.strokeStyle = borderOpts.borderColor;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const me = this;
    const optionTicks = me.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = me.ctx;
    const area = me._computeLabelArea();
    if (area) {
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.U)(ctx, area);
    }
    const items = me._labelItems || (me._labelItems = me._computeLabelItems(chartArea));
    let i, ilen;
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      const item = items[i];
      const tickFont = item.font;
      const label = item.label;
      if (item.backdrop) {
        ctx.fillStyle = item.backdrop.color;
        ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
      }
      let y = item.textOffset;
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.V)(ctx, label, 0, y, tickFont, item);
    }
    if (area) {
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.W)(ctx);
    }
  }
  drawTitle() {
    const {ctx, options: {position, title, reverse}} = this;
    if (!title.display) {
      return;
    }
    const font = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(title.font);
    const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.A)(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === 'bottom' || position === 'center' || (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {
      offset += padding.bottom;
      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.V)(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: 'middle',
      translation: [titleX, titleY],
    });
  }
  draw(chartArea) {
    const me = this;
    if (!me._isVisible()) {
      return;
    }
    me.drawBackground();
    me.drawGrid(chartArea);
    me.drawBorder();
    me.drawTitle();
    me.drawLabels(chartArea);
  }
  _layers() {
    const me = this;
    const opts = me.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(opts.grid && opts.grid.z, -1);
    if (!me._isVisible() || me.draw !== Scale.prototype.draw) {
      return [{
        z: tz,
        draw(chartArea) {
          me.draw(chartArea);
        }
      }];
    }
    return [{
      z: gz,
      draw(chartArea) {
        me.drawBackground();
        me.drawGrid(chartArea);
        me.drawTitle();
      }
    }, {
      z: gz + 1,
      draw() {
        me.drawBorder();
      }
    }, {
      z: tz,
      draw(chartArea) {
        me.drawLabels(chartArea);
      }
    }];
  }
  getMatchingVisibleMetas(type) {
    const me = this;
    const metas = me.chart.getSortedVisibleDatasetMetas();
    const axisID = me.axis + 'AxisID';
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === me.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index) {
    const opts = this.options.ticks.setContext(this.getContext(index));
    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(opts.font);
  }
  _maxDigits() {
    const me = this;
    const fontSize = me._resolveTickFontOptions(0).lineHeight;
    return (me.isHorizontal() ? me.width : me.height) / fontSize;
  }
}

class TypedRegistry {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const me = this;
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = me.register(proto);
    }
    const items = me.items;
    const id = item.id;
    const scope = me.scope + '.' + id;
    if (!id) {
      throw new Error('class does not have id: ' + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (me.override) {
      _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d[scope]) {
      delete _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d[scope][id];
      if (this.override) {
        delete _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.$[id];
      }
    }
  }
}
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a0)(Object.create(null), [
    parentScope ? _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.get(parentScope) : {},
    _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.get(scope),
    item.defaults
  ]);
  _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach(property => {
    const propertyParts = property.split('.');
    const sourceName = propertyParts.pop();
    const sourceScope = [scope].concat(propertyParts).join('.');
    const parts = routes[property].split('.');
    const targetName = parts.pop();
    const targetScope = parts.join('.');
    _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return 'id' in proto && 'defaults' in proto;
}

class Registry {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);
    this.elements = new TypedRegistry(Element, 'elements');
    this.plugins = new TypedRegistry(Object, 'plugins');
    this.scales = new TypedRegistry(Scale, 'scales');
    this._typedRegistries = [this.controllers, this.scales, this.elements];
  }
  add(...args) {
    this._each('register', args);
  }
  remove(...args) {
    this._each('unregister', args);
  }
  addControllers(...args) {
    this._each('register', args, this.controllers);
  }
  addElements(...args) {
    this._each('register', args, this.elements);
  }
  addPlugins(...args) {
    this._each('register', args, this.plugins);
  }
  addScales(...args) {
    this._each('register', args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, 'controller');
  }
  getElement(id) {
    return this._get(id, this.elements, 'element');
  }
  getPlugin(id) {
    return this._get(id, this.plugins, 'plugin');
  }
  getScale(id) {
    return this._get(id, this.scales, 'scale');
  }
  removeControllers(...args) {
    this._each('unregister', args, this.controllers);
  }
  removeElements(...args) {
    this._each('unregister', args, this.elements);
  }
  removePlugins(...args) {
    this._each('unregister', args, this.plugins);
  }
  removeScales(...args) {
    this._each('unregister', args, this.scales);
  }
  _each(method, args, typedRegistry) {
    const me = this;
    [...args].forEach(arg => {
      const reg = typedRegistry || me._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || (reg === me.plugins && arg.id)) {
        me._exec(method, reg, arg);
      } else {
        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(arg, item => {
          const itemReg = typedRegistry || me._getRegistryForType(item);
          me._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry, component) {
    const camelMethod = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a1)(method);
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(component['before' + camelMethod], [], component);
    registry[method](component);
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(component['after' + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === undefined) {
      throw new Error('"' + id + '" is not a registered ' + type + '.');
    }
    return item;
  }
}
var registry = new Registry();

class PluginService {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    const me = this;
    if (hook === 'beforeInit') {
      me._init = me._createDescriptors(chart, true);
      me._notify(me._init, chart, 'install');
    }
    const descriptors = filter ? me._descriptors(chart).filter(filter) : me._descriptors(chart);
    const result = me._notify(descriptors, chart, hook, args);
    if (hook === 'destroy') {
      me._notify(descriptors, chart, 'stop');
      me._notify(me._init, chart, 'uninstall');
    }
    return result;
  }
  _notify(descriptors, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [chart, args, descriptor.options];
      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(this._cache)) {
      this._oldCache = this._cache;
      this._cache = undefined;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(config.options && config.options.plugins, {});
    const plugins = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors = this._cache;
    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');
    this._notify(diff(descriptors, previousDescriptors), chart, 'start');
  }
}
function allPlugins(config) {
  const plugins = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins.indexOf(plugin) === -1) {
      plugins.push(plugin);
    }
  }
  return plugins;
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, plugins, options, all) {
  const result = [];
  const context = chart.getContext();
  for (let i = 0; i < plugins.length; i++) {
    const plugin = plugins[i];
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, plugin, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, plugin, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  return config.createResolver(scopes, context, [''], {scriptable: false, indexable: false, allKeys: true});
}

function getIndexAxis(type, options) {
  const datasetDefaults = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === '_index_') {
    axis = indexAxis;
  } else if (id === '_value_') {
    axis = indexAxis === 'x' ? 'y' : 'x';
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? '_index_' : '_value_';
}
function axisFromPosition(position) {
  if (position === 'top' || position === 'bottom') {
    return 'x';
  }
  if (position === 'left' || position === 'right') {
    return 'y';
  }
}
function determineAxis(id, scaleOptions) {
  if (id === 'x' || id === 'y') {
    return id;
  }
  return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
}
function mergeScaleConfig(config, options) {
  const chartDefaults = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.$[config.type] || {scales: {}};
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const firstIDs = Object.create(null);
  const scales = Object.create(null);
  Object.keys(configScales).forEach(id => {
    const scaleConf = configScales[id];
    const axis = determineAxis(id, scaleConf);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    firstIDs[axis] = firstIDs[axis] || id;
    scales[id] = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a7)(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
  });
  config.data.datasets.forEach(dataset => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.$[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach(defaultID => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + 'AxisID'] || firstIDs[axis] || axis;
      scales[id] = scales[id] || Object.create(null);
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a7)(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);
    });
  });
  Object.keys(scales).forEach(key => {
    const scale = scales[key];
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a7)(scale, [_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.scales[scale.type], _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.scale]);
  });
  return scales;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
const keyCache = new Map();
const keysCached = new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
const addIfFound = (set, obj, key) => {
  const opts = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, key);
  if (opts !== undefined) {
    set.add(opts);
  }
};
class Config {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = new Map();
    this._resolverCache = new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType,
      () => [[
        `datasets.${datasetType}`,
        ''
      ]]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`,
      () => [
        [
          `datasets.${datasetType}.transitions.${transition}`,
          `transitions.${transition}`,
        ],
        [
          `datasets.${datasetType}`,
          ''
        ]
      ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`,
      () => [[
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ''
      ]]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`,
      () => [[
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || [],
      ]]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const {options, type} = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = new Set();
    keyLists.forEach(keys => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach(key => addIfFound(scopes, mainScope, key));
      }
      keys.forEach(key => addIfFound(scopes, options, key));
      keys.forEach(key => addIfFound(scopes, _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.$[type] || {}, key));
      keys.forEach(key => addIfFound(scopes, _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d, key));
      keys.forEach(key => addIfFound(scopes, _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a2, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const {options, type} = this;
    return [
      options,
      _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.$[type] || {},
      _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {},
      {type},
      _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d,
      _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a2
    ];
  }
  resolveNamedOptions(scopes, names, context, prefixes = ['']) {
    const result = {$shared: true};
    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);
    let options = resolver;
    if (needContext(resolver, names)) {
      result.$shared = false;
      context = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a3)(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a4)(resolver, context, subResolver);
    }
    for (const prop of names) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {
    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);
    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(context)
      ? (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a4)(resolver, context, undefined, descriptorDefaults)
      : resolver;
  }
}
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a5)(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
function needContext(proxy, names) {
  const {isScriptable, isIndexable} = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a6)(proxy);
  for (const prop of names) {
    if ((isScriptable(prop) && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a3)(proxy[prop]))
      || (isIndexable(prop) && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(proxy[prop]))) {
      return true;
    }
  }
  return false;
}

var version = "3.5.1";

const KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];
function positionIsHorizontal(position, axis) {
  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1]
      ? a[l2] - b[l2]
      : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins('afterRender');
  (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(animationOptions && animationOptions.onComplete, [context], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(animationOptions && animationOptions.onProgress, [context], chart);
}
function getCanvas(item) {
  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.I)() && typeof item === 'string') {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
const instances = {};
const getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
class Chart {
  constructor(item, userConfig) {
    const me = this;
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error(
        'Canvas is already in use. Chart with ID \'' + existingChart.id + '\'' +
				' must be destroyed before the canvas can be reused.'
      );
    }
    const options = config.createResolver(config.chartOptionScopes(), me.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    const context = me.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a8)();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = undefined;
    this.boxes = [];
    this.currentDevicePixelRatio = undefined;
    this.chartArea = undefined;
    this._active = [];
    this._lastEvent = undefined;
    this._listeners = {};
    this._responsiveListeners = undefined;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = undefined;
    this.$context = undefined;
    this._doResize = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a9)(() => this.update('resize'), options.resizeDelay || 0);
    instances[me.id] = me;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(me, 'complete', onAnimationsComplete);
    animator.listen(me, 'progress', onAnimationProgress);
    me._initialize();
    if (me.attached) {
      me.update();
    }
  }
  get aspectRatio() {
    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;
    if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  _initialize() {
    const me = this;
    me.notifyPlugins('beforeInit');
    if (me.options.responsive) {
      me.resize();
    } else {
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aa)(me, me.options.devicePixelRatio);
    }
    me.bindEvents();
    me.notifyPlugins('afterInit');
    return me;
  }
  clear() {
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ab)(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {width, height};
    }
  }
  _resize(width, height) {
    const me = this;
    const options = me.options;
    const canvas = me.canvas;
    const aspectRatio = options.maintainAspectRatio && me.aspectRatio;
    const newSize = me.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options.devicePixelRatio || me.platform.getDevicePixelRatio();
    me.width = newSize.width;
    me.height = newSize.height;
    me._aspectRatio = me.aspectRatio;
    if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aa)(me, newRatio, true)) {
      return;
    }
    me.notifyPlugins('resize', {size: newSize});
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(options.onResize, [me, newSize], me);
    if (me.attached) {
      if (me._doResize()) {
        me.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const me = this;
    const options = me.options;
    const scaleOpts = options.scales;
    const scales = me.scales;
    const updated = Object.keys(scales).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(
        Object.keys(scaleOpts).map((id) => {
          const scaleOptions = scaleOpts[id];
          const axis = determineAxis(id, scaleOptions);
          const isRadial = axis === 'r';
          const isHorizontal = axis === 'x';
          return {
            options: scaleOptions,
            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',
            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'
          };
        })
      );
    }
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(scaleOptions.type, item.dtype);
      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales && scales[id].type === scaleType) {
        scale = scales[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: me.ctx,
          chart: me
        });
        scales[scale.id] = scale;
      }
      scale.init(scaleOptions, options);
    });
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales[id];
      }
    });
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(scales, (scale) => {
      layouts.configure(me, scale, scale.options);
      layouts.addBox(me, scale);
    });
  }
  _updateMetasets() {
    const me = this;
    const metasets = me._metasets;
    const numData = me.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        me._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    me._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));
  }
  _removeUnreferencedMetasets() {
    const me = this;
    const {_metasets: metasets, data: {datasets}} = me;
    if (metasets.length > datasets.length) {
      delete me._stacks;
    }
    metasets.forEach((meta, index) => {
      if (datasets.filter(x => x === meta._dataset).length === 0) {
        me._destroyDatasetMeta(index);
      }
    });
  }
  buildOrUpdateControllers() {
    const me = this;
    const newControllers = [];
    const datasets = me.data.datasets;
    let i, ilen;
    me._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = me.getDatasetMeta(i);
      const type = dataset.type || me.config.type;
      if (meta.type && meta.type !== type) {
        me._destroyDatasetMeta(i);
        meta = me.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, me.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = '' + dataset.label;
      meta.visible = me.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const {datasetElementType, dataElementType} = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type];
        Object.assign(ControllerClass.prototype, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(me, i);
        newControllers.push(meta.controller);
      }
    }
    me._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    const me = this;
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(me.data.datasets, (dataset, datasetIndex) => {
      me.getDatasetMeta(datasetIndex).controller.reset();
    }, me);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins('reset');
  }
  update(mode) {
    const me = this;
    const config = me.config;
    config.update();
    me._options = config.createResolver(config.chartOptionScopes(), me.getContext());
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(me.scales, (scale) => {
      layouts.removeBox(me, scale);
    });
    const animsDisabled = me._animationsDisabled = !me.options.animation;
    me.ensureScalesHaveIDs();
    me.buildOrUpdateScales();
    const existingEvents = new Set(Object.keys(me._listeners));
    const newEvents = new Set(me.options.events);
    if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ac)(existingEvents, newEvents) || !!this._responsiveListeners !== me.options.responsive) {
      me.unbindEvents();
      me.bindEvents();
    }
    me._plugins.invalidate();
    if (me.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {
      return;
    }
    const newControllers = me.buildOrUpdateControllers();
    me.notifyPlugins('beforeElementsUpdate');
    let minPadding = 0;
    for (let i = 0, ilen = me.data.datasets.length; i < ilen; i++) {
      const {controller} = me.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    me._minPadding = minPadding;
    me._updateLayout(minPadding);
    if (!animsDisabled) {
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(newControllers, (controller) => {
        controller.reset();
      });
    }
    me._updateDatasets(mode);
    me.notifyPlugins('afterUpdate', {mode});
    me._layers.sort(compare2Level('z', '_idx'));
    if (me._lastEvent) {
      me._eventHandler(me._lastEvent, true);
    }
    me.render();
  }
  _updateLayout(minPadding) {
    const me = this;
    if (me.notifyPlugins('beforeLayout', {cancelable: true}) === false) {
      return;
    }
    layouts.update(me, me.width, me.height, minPadding);
    const area = me.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    me._layers = [];
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(me.boxes, (box) => {
      if (noArea && box.position === 'chartArea') {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      me._layers.push(...box._layers());
    }, me);
    me._layers.forEach((item, index) => {
      item._idx = index;
    });
    me.notifyPlugins('afterLayout');
  }
  _updateDatasets(mode) {
    const me = this;
    const isFunction = typeof mode === 'function';
    if (me.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {
      return;
    }
    for (let i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
      me._updateDataset(i, isFunction ? mode({datasetIndex: i}) : mode);
    }
    me.notifyPlugins('afterDatasetsUpdate', {mode});
  }
  _updateDataset(index, mode) {
    const me = this;
    const meta = me.getDatasetMeta(index);
    const args = {meta, index, mode, cancelable: true};
    if (me.notifyPlugins('beforeDatasetUpdate', args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    me.notifyPlugins('afterDatasetUpdate', args);
  }
  render() {
    const me = this;
    if (me.notifyPlugins('beforeRender', {cancelable: true}) === false) {
      return;
    }
    if (animator.has(me)) {
      if (me.attached && !animator.running(me)) {
        animator.start(me);
      }
    } else {
      me.draw();
      onAnimationsComplete({chart: me});
    }
  }
  draw() {
    const me = this;
    let i;
    if (me._resizeBeforeDraw) {
      const {width, height} = me._resizeBeforeDraw;
      me._resize(width, height);
      me._resizeBeforeDraw = null;
    }
    me.clear();
    if (me.width <= 0 || me.height <= 0) {
      return;
    }
    if (me.notifyPlugins('beforeDraw', {cancelable: true}) === false) {
      return;
    }
    const layers = me._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(me.chartArea);
    }
    me._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(me.chartArea);
    }
    me.notifyPlugins('afterDraw');
  }
  _getSortedDatasetMetas(filterVisible) {
    const me = this;
    const metasets = me._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    const me = this;
    if (me.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {
      return;
    }
    const metasets = me.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      me._drawDataset(metasets[i]);
    }
    me.notifyPlugins('afterDatasetsDraw');
  }
  _drawDataset(meta) {
    const me = this;
    const ctx = me.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = me.chartArea;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (me.notifyPlugins('beforeDatasetDraw', args) === false) {
      return;
    }
    if (useClip) {
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.U)(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? me.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? me.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.W)(ctx);
    }
    args.cancelable = false;
    me.notifyPlugins('afterDatasetDraw', args);
  }
  getElementsAtEventForMode(e, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === 'function') {
      return method(this, e, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const me = this;
    const dataset = me.data.datasets[datasetIndex];
    const metasets = me._metasets;
    let meta = metasets.filter(x => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = {chart: this, type: 'chart'});
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index) {
    this._hiddenIndices[index] = !this._hiddenIndices[index];
  }
  getDataVisibility(index) {
    return !this._hiddenIndices[index];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const me = this;
    const mode = visible ? 'show' : 'hide';
    const meta = me.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(undefined, mode);
    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.h)(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      me.update();
    } else {
      me.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {visible});
      me.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const me = this;
    const meta = me._metasets && me._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
      delete me._metasets[datasetIndex];
    }
  }
  destroy() {
    const me = this;
    const {canvas, ctx} = me;
    let i, ilen;
    me.stop();
    animator.remove(me);
    for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
      me._destroyDatasetMeta(i);
    }
    me.config.clearCache();
    if (canvas) {
      me.unbindEvents();
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ab)(canvas, ctx);
      me.platform.releaseContext(ctx);
      me.canvas = null;
      me.ctx = null;
    }
    me.notifyPlugins('destroy');
    delete instances[me.id];
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const me = this;
    const listeners = me._listeners;
    const platform = me.platform;
    const _add = (type, listener) => {
      platform.addEventListener(me, type, listener);
      listeners[type] = listener;
    };
    const listener = function(e, x, y) {
      e.offsetX = x;
      e.offsetY = y;
      me._eventHandler(e);
    };
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(me.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    const me = this;
    if (!me._responsiveListeners) {
      me._responsiveListeners = {};
    }
    const listeners = me._responsiveListeners;
    const platform = me.platform;
    const _add = (type, listener) => {
      platform.addEventListener(me, type, listener);
      listeners[type] = listener;
    };
    const _remove = (type, listener) => {
      if (listeners[type]) {
        platform.removeEventListener(me, type, listener);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (me.canvas) {
        me.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove('attach', attached);
      me.attached = true;
      me.resize();
      _add('resize', listener);
      _add('detach', detached);
    };
    detached = () => {
      me.attached = false;
      _remove('resize', listener);
      _add('attach', attached);
    };
    if (platform.isAttached(me.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    const me = this;
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(me._listeners, (listener, type) => {
      me.platform.removeEventListener(me, type, listener);
    });
    me._listeners = {};
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(me._responsiveListeners, (listener, type) => {
      me.platform.removeEventListener(me, type, listener);
    });
    me._responsiveListeners = undefined;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? 'set' : 'remove';
    let meta, item, i, ilen;
    if (mode === 'dataset') {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller['_' + prefix + 'DatasetHoverStyle']();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const me = this;
    const lastActive = me._active || [];
    const active = activeElements.map(({datasetIndex, index}) => {
      const meta = me.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error('No dataset found at index ' + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index,
      };
    });
    const changed = !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ad)(active, lastActive);
    if (changed) {
      me._active = active;
      me._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  _updateHoverStyles(active, lastActive, replay) {
    const me = this;
    const hoverOptions = me.options.hover;
    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      me.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      me.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const me = this;
    const args = {event: e, replay, cancelable: true};
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.type);
    if (me.notifyPlugins('beforeEvent', args, eventFilter) === false) {
      return;
    }
    const changed = me._handleEvent(e, replay);
    args.cancelable = false;
    me.notifyPlugins('afterEvent', args, eventFilter);
    if (changed || args.changed) {
      me.render();
    }
    return me;
  }
  _handleEvent(e, replay) {
    const me = this;
    const {_active: lastActive = [], options} = me;
    const hoverOptions = options.hover;
    const useFinalPosition = replay;
    let active = [];
    let changed = false;
    let lastEvent = null;
    if (e.type !== 'mouseout') {
      active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
      lastEvent = e.type === 'click' ? me._lastEvent : e;
    }
    me._lastEvent = null;
    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.y)(e, me.chartArea, me._minPadding)) {
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(options.onHover, [e, active, me], me);
      if (e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu') {
        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(options.onClick, [e, active, me], me);
      }
    }
    changed = !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ad)(active, lastActive);
    if (changed || replay) {
      me._active = active;
      me._updateHoverStyles(active, lastActive, replay);
    }
    me._lastEvent = lastEvent;
    return changed;
  }
}
const invalidatePlugins = () => (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(Chart.instances, (chart) => chart._plugins.invalidate());
const enumerable = true;
Object.defineProperties(Chart, {
  defaults: {
    enumerable,
    value: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d
  },
  instances: {
    enumerable,
    value: instances
  },
  overrides: {
    enumerable,
    value: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.$
  },
  registry: {
    enumerable,
    value: registry
  },
  version: {
    enumerable,
    value: version
  },
  getChart: {
    enumerable,
    value: getChart
  },
  register: {
    enumerable,
    value: (...items) => {
      registry.add(...items);
      invalidatePlugins();
    }
  },
  unregister: {
    enumerable,
    value: (...items) => {
      registry.remove(...items);
      invalidatePlugins();
    }
  }
});

function clipArc(ctx, element, endAngle) {
  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H, startAngle - _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.af)(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(o.innerStart, 0, innerLimit),
    innerEnd: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(o.innerEnd, 0, innerLimit),
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta),
  };
}
function pathArc(ctx, element, offset, spacing, end) {
  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;
    spacingOffset = (alpha - adjustedAngle) / 2;
  }
  const beta = Math.max(0.001, alpha * outerRadius - offset / _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.P) / outerRadius;
  const angleOffset = (alpha - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
  if (outerEnd > 0) {
    const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H);
  }
  const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
  ctx.lineTo(p4.x, p4.y);
  if (innerEnd > 0) {
    const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H, innerEndAdjustedAngle + Math.PI);
  }
  ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), startAngle + (innerStart / innerRadius), true);
  if (innerStart > 0) {
    const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H);
  }
  const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
  ctx.lineTo(p8.x, p8.y);
  if (outerStart > 0) {
    const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
    ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H, outerStartAdjustedAngle);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing) {
  const {fullCircles, startAngle, circumference} = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, startAngle + _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + circumference % _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T;
      if (circumference % _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T === 0) {
        endAngle += _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T;
      }
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle);
  ctx.fill();
  return endAngle;
}
function drawFullCircleBorders(ctx, element, inner) {
  const {x, y, startAngle, pixelMargin, fullCircles} = element;
  const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
  const innerRadius = element.innerRadius + pixelMargin;
  let i;
  if (inner) {
    clipArc(ctx, element, startAngle + _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T);
  }
  ctx.beginPath();
  ctx.arc(x, y, innerRadius, startAngle + _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T, startAngle, true);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle, startAngle + _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T);
  for (i = 0; i < fullCircles; ++i) {
    ctx.stroke();
  }
}
function drawBorder(ctx, element, offset, spacing, endAngle) {
  const {options} = element;
  const inner = options.borderAlign === 'inner';
  if (!options.borderWidth) {
    return;
  }
  if (inner) {
    ctx.lineWidth = options.borderWidth * 2;
    ctx.lineJoin = 'round';
  } else {
    ctx.lineWidth = options.borderWidth;
    ctx.lineJoin = 'bevel';
  }
  if (element.fullCircles) {
    drawFullCircleBorders(ctx, element, inner);
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  pathArc(ctx, element, offset, spacing, endAngle);
  ctx.stroke();
}
class ArcElement extends Element {
  constructor(cfg) {
    super();
    this.options = undefined;
    this.circumference = undefined;
    this.startAngle = undefined;
    this.endAngle = undefined;
    this.innerRadius = undefined;
    this.outerRadius = undefined;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps(['x', 'y'], useFinalPosition);
    const {angle, distance} = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ae)(point, {x: chartX, y: chartY});
    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([
      'startAngle',
      'endAngle',
      'innerRadius',
      'outerRadius',
      'circumference'
    ], useFinalPosition);
    const rAdjust = this.options.spacing / 2;
    const betweenAngles = circumference >= _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T || (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.o)(angle, startAngle, endAngle);
    const withinRadius = (distance >= innerRadius + rAdjust && distance <= outerRadius + rAdjust);
    return (betweenAngles && withinRadius);
  }
  getCenterPoint(useFinalPosition) {
    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([
      'x',
      'y',
      'startAngle',
      'endAngle',
      'innerRadius',
      'outerRadius',
      'circumference',
    ], useFinalPosition);
    const {offset, spacing} = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const me = this;
    const {options, circumference} = me;
    const offset = (options.offset || 0) / 2;
    const spacing = (options.spacing || 0) / 2;
    me.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;
    me.fullCircles = circumference > _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T ? Math.floor(circumference / _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T) : 0;
    if (circumference === 0 || me.innerRadius < 0 || me.outerRadius < 0) {
      return;
    }
    ctx.save();
    let radiusOffset = 0;
    if (offset) {
      radiusOffset = offset / 2;
      const halfAngle = (me.startAngle + me.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
      if (me.circumference >= _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.P) {
        radiusOffset = offset;
      }
    }
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    const endAngle = drawArc(ctx, me, radiusOffset, spacing);
    drawBorder(ctx, me, radiusOffset, spacing, endAngle);
    ctx.restore();
  }
}
ArcElement.id = 'arc';
ArcElement.defaults = {
  borderAlign: 'center',
  borderColor: '#fff',
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: undefined,
};
ArcElement.defaultRoutes = {
  backgroundColor: 'backgroundColor'
};

function setStyle(ctx, options, style = options) {
  ctx.lineCap = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDash, options.borderDash));
  ctx.lineDashOffset = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.am;
  }
  if (options.tension || options.cubicInterpolationMode === 'monotone') {
    return _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.an;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;
  const {start: segmentStart, end: segmentEnd} = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const {points, options} = line;
  const {count, start, loop, ilen} = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let {move = true, reverse} = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const {count, start, ilen} = pathVars(points, segment, params);
  const {move = true, reverse} = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aj;
  }
  if (options.tension || options.cubicInterpolationMode === 'monotone') {
    return _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ak;
  }
  return _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.al;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const {segments, options} = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
const usePath2D = typeof Path2D === 'function';
function draw(ctx, line, start, count) {
  if (usePath2D && line.segments.length === 1) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
class LineElement extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = undefined;
    this._loop = undefined;
    this._fullLoop = undefined;
    this._path = undefined;
    this._points = undefined;
    this._segments = undefined;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = undefined;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const me = this;
    const options = me.options;
    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !me._pointsUpdated) {
      const loop = options.spanGaps ? me._loop : me._fullLoop;
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ag)(me._points, options, chartArea, loop, indexAxis);
      me._pointsUpdated = true;
    }
  }
  set points(points) {
    const me = this;
    me._points = points;
    delete me._segments;
    delete me._path;
    me._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ah)(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const me = this;
    const options = me.options;
    const value = point[property];
    const points = me.points;
    const segments = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ai)(me, {property, start: value, end: value});
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const {start, end} = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const me = this;
    const segments = me.segments;
    const segmentMethod = _getSegmentMethod(me);
    let loop = me._loop;
    start = start || 0;
    count = count || (me.points.length - start);
    for (const segment of segments) {
      loop &= segmentMethod(ctx, me, segment, {start, end: start + count - 1});
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const me = this;
    const options = me.options || {};
    const points = me.points || [];
    if (!points.length || !options.borderWidth) {
      return;
    }
    ctx.save();
    draw(ctx, me, start, count);
    ctx.restore();
    if (me.animated) {
      me._pointsUpdated = false;
      me._path = undefined;
    }
  }
}
LineElement.id = 'line';
LineElement.defaults = {
  borderCapStyle: 'butt',
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: 'miter',
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: 'default',
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0,
};
LineElement.defaultRoutes = {
  backgroundColor: 'backgroundColor',
  borderColor: 'borderColor'
};
LineElement.descriptors = {
  _scriptable: true,
  _indexable: (name) => name !== 'borderDash' && name !== 'fill',
};

function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const {[axis]: value} = el.getProps([axis], useFinalPosition);
  return (Math.abs(pos - value) < options.radius + options.hitRadius);
}
class PointElement extends Element {
  constructor(cfg) {
    super();
    this.options = undefined;
    this.parsed = undefined;
    this.skip = undefined;
    this.stop = undefined;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);
    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, 'x', useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, 'y', useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);
    return {x, y};
  }
  size(options) {
    options = options || this.options || {};
    let radius = options.radius || 0;
    radius = Math.max(radius, radius && options.hoverRadius || 0);
    const borderWidth = radius && options.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const me = this;
    const options = me.options;
    if (me.skip || options.radius < 0.1 || !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.y)(me, area, me.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ao)(ctx, options, me.x, me.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
}
PointElement.id = 'point';
PointElement.defaults = {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: 'circle',
  radius: 3,
  rotation: 0
};
PointElement.defaultRoutes = {
  backgroundColor: 'backgroundColor',
  borderColor: 'borderColor'
};

function getBarBounds(bar, useFinalPosition) {
  const {x, y, base, width, height} = bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return {left, top, right, bottom};
}
function skipOrLimit(skip, value, min, max) {
  return skip ? 0 : (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip = bar.borderSkipped;
  const o = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aq)(value);
  return {
    t: skipOrLimit(skip.top, o.top, 0, maxH),
    r: skipOrLimit(skip.right, o.right, 0, maxW),
    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);
  const value = bar.options.borderRadius;
  const o = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ar)(value);
  const maxR = Math.min(maxW, maxH);
  const skip = bar.borderSkipped;
  const enableBorder = enableBorderRadius || (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds
		&& (skipX || x >= bounds.left && x <= bounds.right)
		&& (skipY || y >= bounds.top && y <= bounds.bottom);
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
class BarElement extends Element {
  constructor(cfg) {
    super();
    this.options = undefined;
    this.horizontal = undefined;
    this.base = undefined;
    this.width = undefined;
    this.height = undefined;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const options = this.options;
    const {inner, outer} = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ap : addNormalRectPath;
    const inflateAmount = 0.33;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = options.borderColor;
      ctx.fill('evenodd');
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount, outer));
    ctx.fillStyle = options.backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const {x, y, base, horizontal} = this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === 'x' ? this.width / 2 : this.height / 2;
  }
}
BarElement.id = 'bar';
BarElement.defaults = {
  borderSkipped: 'start',
  borderWidth: 0,
  borderRadius: 0,
  enableBorderRadius: true,
  pointStyle: undefined
};
BarElement.defaultRoutes = {
  backgroundColor: 'backgroundColor',
  borderColor: 'borderColor'
};

var elements = /*#__PURE__*/Object.freeze({
__proto__: null,
ArcElement: ArcElement,
LineElement: LineElement,
PointElement: PointElement,
BarElement: BarElement
});

function lttbDecimation(data, start, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const {x: pointAx, y: pointAy} = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs(
        (pointAx - avgX) * (data[j].y - pointAy) -
        (pointAx - data[j].x) * (avgY - pointAy)
      );
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i = start; i < start + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(minIndex) && !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX,
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, 'data', {value: data});
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const {iScale} = meta;
  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
  if (minDefined) {
    start = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return {start, count};
}
var plugin_decimation = {
  id: 'decimation',
  defaults: {
    algorithm: 'min-max',
    enabled: false,
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const {_data, indexAxis} = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a)([indexAxis, chart.options.indexAxis]) === 'y') {
        return;
      }
      if (meta.type !== 'line') {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, 'data', {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
      case 'lttb':
        decimated = lttbDecimation(data, start, count, availableWidth, options);
        break;
      case 'min-max':
        decimated = minMaxDecimation(data, start, count, availableWidth);
        break;
      default:
        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};

function getLineByIndex(chart, index) {
  const meta = chart.getDatasetMeta(index);
  const visible = meta && chart.isDatasetVisible(index);
  return visible ? meta.dataset : null;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(fillOption && fillOption.target, fillOption);
  if (fill === undefined) {
    fill = !!options.backgroundColor;
  }
  if (fill === false || fill === null) {
    return false;
  }
  if (fill === true) {
    return 'origin';
  }
  return fill;
}
function decodeFill(line, index, count) {
  const fill = parseFillOption(line);
  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {
    return isNaN(fill.value) ? false : fill;
  }
  let target = parseFloat(fill);
  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(target) && Math.floor(target) === target) {
    if (fill[0] === '-' || fill[0] === '+') {
      target = index + target;
    }
    if (target === index || target < 0 || target >= count) {
      return false;
    }
    return target;
  }
  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;
}
function computeLinearBoundary(source) {
  const {scale = {}, fill} = source;
  let target = null;
  let horizontal;
  if (fill === 'start') {
    target = scale.bottom;
  } else if (fill === 'end') {
    target = scale.top;
  } else if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {
    target = scale.getPixelForValue(fill.value);
  } else if (scale.getBasePixel) {
    target = scale.getBasePixel();
  }
  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(target)) {
    horizontal = scale.isHorizontal();
    return {
      x: horizontal ? target : null,
      y: horizontal ? null : target
    };
  }
  return null;
}
class simpleArc {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const {x, y, radius} = this;
    bounds = bounds || {start: 0, end: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T};
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const {x, y, radius} = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
}
function computeCircularBoundary(source) {
  const {scale, fill} = source;
  const options = scale.options;
  const length = scale.getLabels().length;
  const target = [];
  const start = options.reverse ? scale.max : scale.min;
  const end = options.reverse ? scale.min : scale.max;
  let i, center, value;
  if (fill === 'start') {
    value = start;
  } else if (fill === 'end') {
    value = end;
  } else if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {
    value = fill.value;
  } else {
    value = scale.getBaseValue();
  }
  if (options.grid.circular) {
    center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value));
  }
  return target;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function findSegmentEnd(start, end, points) {
  for (;end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function pointsFromSegments(boundary, line) {
  const {x = null, y = null} = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({start, end}) => {
    end = findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({x: first.x, y});
      points.push({x: last.x, y});
    } else if (x !== null) {
      points.push({x, y: first.y});
      points.push({x, y: last.y});
    }
  });
  return points;
}
function buildStackLine(source) {
  const {chart, scale, index, line} = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(chart, index);
  linesBelow.push(createBoundaryLine({x: null, y: scale.bottom}, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({points, options: {}});
}
const isLineAndNotInHideAnimation = (meta) => meta.type === 'line' && !meta.hidden;
function getLinesBelow(chart, index) {
  const below = [];
  const metas = chart.getSortedVisibleDatasetMetas();
  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];
    if (meta.index === index) {
      break;
    }
    if (isLineAndNotInHideAnimation(meta)) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const {first, last, point} = findPoint(line, sourcePoint, 'x');
    if (!point || (first && last)) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (pointValue >= firstValue && pointValue <= lastValue) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return {first, last, point};
}
function getTarget(source) {
  const {chart, fill, line} = source;
  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {
    return getLineByIndex(chart, fill);
  }
  if (fill === 'stack') {
    return buildStackLine(source);
  }
  if (fill === 'shape') {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return createBoundaryLine(boundary, line);
}
function createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: {tension: 0},
    _loop,
    _fullLoop: _loop
  }) : null;
}
function resolveTarget(sources, index, propagate) {
  const source = sources[index];
  let fill = source.fill;
  const visited = [index];
  let target;
  if (!propagate) {
    return fill;
  }
  while (fill !== false && visited.indexOf(fill) === -1) {
    if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {
      return fill;
    }
    target = sources[fill];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill;
    }
    visited.push(fill);
    fill = target.fill;
  }
  return false;
}
function _clip(ctx, target, clipY) {
  ctx.beginPath();
  target.path(ctx);
  ctx.lineTo(target.last().x, clipY);
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === 'angle') {
    start = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.at)(start);
    end = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.at)(end);
  }
  return {property, start, end};
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let {start, end} = segment;
    end = findSegmentEnd(start, end, points);
    const bounds = getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ai)(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.as)(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, 'start', Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, 'end', Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function clipBounds(ctx, scale, bounds) {
  const {top, bottom} = scale.chart.chartArea;
  const {property, start, end} = bounds || {};
  if (property === 'x') {
    ctx.beginPath();
    ctx.rect(start, top, end - start, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
function _fill(ctx, cfg) {
  const {line, target, property, color, scale} = cfg;
  const segments = _segments(line, target, property);
  for (const {source: src, target: tgt, start, end} of segments) {
    const {style: {backgroundColor = color} = {}} = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, notShape && getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? 'evenodd' : 'nonzero');
    ctx.restore();
  }
}
function doFill(ctx, cfg) {
  const {line, target, above, below, area, scale} = cfg;
  const property = line._loop ? 'angle' : cfg.axis;
  ctx.save();
  if (property === 'x' && below !== above) {
    _clip(ctx, target, area.top);
    _fill(ctx, {line, target, color: above, scale, property});
    ctx.restore();
    ctx.save();
    _clip(ctx, target, area.bottom);
  }
  _fill(ctx, {line, target, color: below, scale, property});
  ctx.restore();
}
function drawfill(ctx, source, area) {
  const target = getTarget(source);
  const {line, scale, axis} = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color = lineOpts.backgroundColor;
  const {above = color, below = color} = fillOption || {};
  if (target && line.points.length) {
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.U)(ctx, area);
    doFill(ctx, {line, target, above, below, area, scale, axis});
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.W)(ctx);
  }
}
var plugin_filler = {
  id: 'filler',
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source;
    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: decodeFill(line, i, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line,
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i = 0; i < count; ++i) {
      source = sources[i];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = resolveTarget(sources, i, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw = options.drawTime === 'beforeDraw';
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw) {
        drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== 'beforeDatasetsDraw') {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (source) {
        drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!source || source.fill === false || options.drawTime !== 'beforeDatasetDraw') {
      return;
    }
    drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: 'beforeDatasetDraw'
  }
};

const getBoxSize = (labelOpts, fontSize) => {
  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
class Legend extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = undefined;
    this.columnSizes = undefined;
    this.lineWidths = undefined;
    this.maxHeight = undefined;
    this.maxWidth = undefined;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.height = undefined;
    this.width = undefined;
    this._margins = undefined;
    this.position = undefined;
    this.weight = undefined;
    this.fullSize = undefined;
  }
  update(maxWidth, maxHeight, margins) {
    const me = this;
    me.maxWidth = maxWidth;
    me.maxHeight = maxHeight;
    me._margins = margins;
    me.setDimensions();
    me.buildLabels();
    me.fit();
  }
  setDimensions() {
    const me = this;
    if (me.isHorizontal()) {
      me.width = me.maxWidth;
      me.left = me._margins.left;
      me.right = me.width;
    } else {
      me.height = me.maxHeight;
      me.top = me._margins.top;
      me.bottom = me.height;
    }
  }
  buildLabels() {
    const me = this;
    const labelOpts = me.options.labels || {};
    let legendItems = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(labelOpts.generateLabels, [me.chart], me) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, me.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, me.chart.data));
    }
    if (me.options.reverse) {
      legendItems.reverse();
    }
    me.legendItems = legendItems;
  }
  fit() {
    const me = this;
    const {options, ctx} = me;
    if (!options.display) {
      me.width = me.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = me._computeTitleHeight();
    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (me.isHorizontal()) {
      width = me.maxWidth;
      height = me._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = me.maxHeight;
      width = me._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    }
    me.width = Math.min(width, options.maxWidth || me.maxWidth);
    me.height = Math.min(height, options.maxHeight || me.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const me = this;
    const {ctx, maxWidth, options: {labels: {padding}}} = me;
    const hitboxes = me.legendHitBoxes = [];
    const lineWidths = me.lineWidths = [0];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    let row = -1;
    let top = -lineHeight;
    me.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
    const me = this;
    const {ctx, maxHeight, options: {labels: {padding}}} = me;
    const hitboxes = me.legendHitBoxes = [];
    const columnSizes = me.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    me.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({width: currentColWidth, height: currentColHeight});
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({width: currentColWidth, height: currentColHeight});
    return totalWidth;
  }
  adjustHitBoxes() {
    const me = this;
    if (!me.options.display) {
      return;
    }
    const titleHeight = me._computeTitleHeight();
    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = me;
    const rtlHelper = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.au)(rtl, me.left, me.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(align, me.left + padding, me.right - me.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(align, me.left + padding, me.right - me.lineWidths[row]);
        }
        hitbox.top += me.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(align, me.top + titleHeight + padding, me.bottom - me.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(align, me.top + titleHeight + padding, me.bottom - me.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += me.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === 'top' || this.options.position === 'bottom';
  }
  draw() {
    const me = this;
    if (me.options.display) {
      const ctx = me.ctx;
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.U)(ctx, me);
      me._draw();
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.W)(ctx);
    }
  }
  _draw() {
    const me = this;
    const {options: opts, columnSizes, lineWidths, ctx} = me;
    const {align, labels: labelOpts} = opts;
    const defaultColor = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.color;
    const rtlHelper = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.au)(opts.rtl, me.left, me.width);
    const labelFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(labelOpts.font);
    const {color: fontColor, padding} = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    me.drawTitle();
    ctx.textAlign = rtlHelper.textAlign('left');
    ctx.textBaseline = 'middle';
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineWidth, 1);
      ctx.fillStyle = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.fillStyle, defaultColor);
      ctx.lineCap = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineCap, 'butt');
      ctx.lineDashOffset = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDashOffset, 0);
      ctx.lineJoin = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineJoin, 'miter');
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxWidth * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ao)(ctx, drawOptions, centerX, centerY);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ar)(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some(v => v !== 0)) {
          (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ap)(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius,
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.V)(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = me.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(align, me.left + padding, me.right - lineWidths[0]),
        y: me.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: me.left + padding,
        y: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(align, me.top + titleHeight + padding, me.bottom - columnSizes[0].height),
        line: 0
      };
    }
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.av)(me.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    me.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor || fontColor;
      ctx.fillStyle = legendItem.fontColor || fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(me.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > me.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(align, me.left + padding, me.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > me.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(align, me.top + titleHeight + padding, me.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aw)(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : me.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ax)(me.ctx, opts.textDirection);
  }
  drawTitle() {
    const me = this;
    const opts = me.options;
    const titleOpts = opts.title;
    const titleFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(titleOpts.font);
    const titlePadding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.A)(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.au)(opts.rtl, me.left, me.width);
    const ctx = me.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = me.left;
    let maxWidth = me.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...me.lineWidths);
      y = me.top + topPaddingPlusHalfFontSize;
      left = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(opts.align, left, me.right - maxWidth);
    } else {
      const maxHeight = me.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(opts.align, me.top, me.bottom - maxHeight - opts.labels.padding - me._computeTitleHeight());
    }
    const x = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Y)(position));
    ctx.textBaseline = 'middle';
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.V)(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(titleOpts.font);
    const titlePadding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.A)(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    const me = this;
    let i, hitBox, lh;
    if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
      lh = me.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
          return me.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const me = this;
    const opts = me.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = me._getLegendItemAt(e.x, e.y);
    if (e.type === 'mousemove') {
      const previous = me._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(opts.onLeave, [e, previous, me], me);
      }
      me._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(opts.onHover, [e, hoveredItem, me], me);
      }
    } else if (hoveredItem) {
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(opts.onClick, [e, hoveredItem, me], me);
    }
  }
}
function isListened(type, opts) {
  if (type === 'mousemove' && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === 'click' || type === 'mouseup')) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: 'legend',
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: 'top',
    align: 'center',
    fullSize: true,
    reverse: false,
    weight: 1000,
    onClick(e, legendItem, legend) {
      const index = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index)) {
        ci.hide(index);
        legendItem.hidden = true;
      } else {
        ci.show(index);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const {labels: {usePointStyle, pointStyle, textAlign, color}} = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
          const borderWidth = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.A)(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: 0,
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: 'center',
      text: '',
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith('on'),
    labels: {
      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),
    }
  },
};

class Title extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = undefined;
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.width = undefined;
    this.height = undefined;
    this.position = undefined;
    this.weight = undefined;
    this.fullSize = undefined;
  }
  update(maxWidth, maxHeight) {
    const me = this;
    const opts = me.options;
    me.left = 0;
    me.top = 0;
    if (!opts.display) {
      me.width = me.height = me.right = me.bottom = 0;
      return;
    }
    me.width = me.right = maxWidth;
    me.height = me.bottom = maxHeight;
    const lineCount = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(opts.text) ? opts.text.length : 1;
    me._padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.A)(opts.padding);
    const textSize = lineCount * (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(opts.font).lineHeight + me._padding.height;
    if (me.isHorizontal()) {
      me.height = textSize;
    } else {
      me.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === 'top' || pos === 'bottom';
  }
  _drawArgs(offset) {
    const {top, left, bottom, right, options} = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options.position === 'left') {
        titleX = left + offset;
        titleY = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(align, bottom, top);
        rotation = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.P * -0.5;
      } else {
        titleX = right - offset;
        titleY = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Z)(align, top, bottom);
        rotation = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.P * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {titleX, titleY, maxWidth, rotation};
  }
  draw() {
    const me = this;
    const ctx = me.ctx;
    const opts = me.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + me._padding.top;
    const {titleX, titleY, maxWidth, rotation} = me._drawArgs(offset);
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.V)(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.Y)(opts.align),
      textBaseline: 'middle',
      translation: [titleX, titleY],
    });
  }
}
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: 'title',
  _element: Title,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: 'center',
    display: false,
    font: {
      weight: 'bold',
    },
    fullSize: true,
    padding: 10,
    position: 'top',
    text: '',
    weight: 2000
  },
  defaultRoutes: {
    color: 'color'
  },
  descriptors: {
    _scriptable: true,
    _indexable: false,
  },
};

const map = new WeakMap();
var plugin_subtitle = {
  id: 'subtitle',
  start(chart, _args, options) {
    const title = new Title({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map.get(chart));
    map.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: 'center',
    display: false,
    font: {
      weight: 'normal',
    },
    fullSize: true,
    padding: 0,
    position: 'top',
    text: '',
    weight: 1500
  },
  defaultRoutes: {
    color: 'color'
  },
  descriptors: {
    _scriptable: true,
    _indexable: false,
  },
};

const positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let x = 0;
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x += pos.x;
        y += pos.y;
        ++count;
      }
    }
    return {
      x: x / count,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.az)(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
    return str.split('\n');
  }
  return str;
}
function createTooltipItem(chart, item) {
  const {element, datasetIndex, index} = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const {label, value} = controller.getLabelAndValue(index);
  return {
    chart,
    label,
    parsed: controller.getParsed(index),
    raw: chart.data.datasets[datasetIndex].data[index],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options) {
  const ctx = tooltip._chart.ctx;
  const {body, footer, title} = tooltip;
  const {boxWidth, boxHeight} = options;
  const bodyFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(options.bodyFont);
  const titleFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(options.titleFont);
  const footerFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.A)(options.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight
			+ (titleLineCount - 1) * options.titleSpacing
			+ options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight
			+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight
			+ (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop
			+ footerLineCount * footerFont.lineHeight
			+ (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? (boxWidth + 2) : 0;
  (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(body, (bodyItem) => {
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(bodyItem.before, maxLineWidth);
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(bodyItem.lines, maxLineWidth);
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {width, height};
}
function determineYAlign(chart, size) {
  const {y, height} = size;
  if (y < height / 2) {
    return 'top';
  } else if (y > (chart.height - height / 2)) {
    return 'bottom';
  }
  return 'center';
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const {x, width} = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === 'left' && x + width + caret > chart.width) {
    return true;
  }
  if (xAlign === 'right' && x - width - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const {x, width} = size;
  const {width: chartWidth, chartArea: {left, right}} = chart;
  let xAlign = 'center';
  if (yAlign === 'center') {
    xAlign = x <= (left + right) / 2 ? 'left' : 'right';
  } else if (x <= width / 2) {
    xAlign = 'left';
  } else if (x >= chartWidth - width / 2) {
    xAlign = 'right';
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = 'center';
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let {x, width} = size;
  if (xAlign === 'right') {
    x -= width;
  } else if (xAlign === 'center') {
    x -= (width / 2);
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let {y, height} = size;
  if (yAlign === 'top') {
    y += paddingAndSize;
  } else if (yAlign === 'bottom') {
    y -= height + paddingAndSize;
  } else {
    y -= (height / 2);
  }
  return y;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const {caretSize, caretPadding, cornerRadius} = options;
  const {xAlign, yAlign} = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const radiusAndPadding = cornerRadius + caretPadding;
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === 'center') {
    if (xAlign === 'left') {
      x += paddingAndSize;
    } else if (xAlign === 'right') {
      x -= paddingAndSize;
    }
  } else if (xAlign === 'left') {
    x -= radiusAndPadding;
  } else if (xAlign === 'right') {
    x += radiusAndPadding;
  }
  return {
    x: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(x, 0, chart.width - size.width),
    y: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options) {
  const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.A)(options.padding);
  return align === 'center'
    ? tooltip.x + tooltip.width / 2
    : align === 'right'
      ? tooltip.x + tooltip.width - padding.right
      : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback) {
  return pushOrConcat([], splitNewlines(callback));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return Object.assign(Object.create(parent), {
    tooltip,
    tooltipItems,
    type: 'tooltip'
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
class Tooltip extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._chart = config._chart;
    this._eventPosition = undefined;
    this._size = undefined;
    this._cachedAnimations = undefined;
    this._tooltipItems = [];
    this.$animations = undefined;
    this.$context = undefined;
    this.options = config.options;
    this.dataPoints = undefined;
    this.title = undefined;
    this.beforeBody = undefined;
    this.body = undefined;
    this.afterBody = undefined;
    this.footer = undefined;
    this.xAlign = undefined;
    this.yAlign = undefined;
    this.x = undefined;
    this.y = undefined;
    this.height = undefined;
    this.width = undefined;
    this.caretX = undefined;
    this.caretY = undefined;
    this.labelColors = undefined;
    this.labelPointStyles = undefined;
    this.labelTextColors = undefined;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = undefined;
    this.$context = undefined;
  }
  _resolveAnimations() {
    const me = this;
    const cached = me._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = me._chart;
    const options = me.options.setContext(me.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(me._chart, opts);
    if (opts._cacheable) {
      me._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    const me = this;
    return me.$context ||
			(me.$context = createTooltipContext(me._chart.getContext(), me, me._tooltipItems));
  }
  getTitle(context, options) {
    const me = this;
    const {callbacks} = options;
    const beforeTitle = callbacks.beforeTitle.apply(me, [context]);
    const title = callbacks.title.apply(me, [context]);
    const afterTitle = callbacks.afterTitle.apply(me, [context]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [tooltipItems]));
  }
  getBody(tooltipItems, options) {
    const me = this;
    const {callbacks} = options;
    const bodyItems = [];
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(me, context)));
      pushOrConcat(bodyItem.lines, scoped.label.call(me, context));
      pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(me, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [tooltipItems]));
  }
  getFooter(tooltipItems, options) {
    const me = this;
    const {callbacks} = options;
    const beforeFooter = callbacks.beforeFooter.apply(me, [tooltipItems]);
    const footer = callbacks.footer.apply(me, [tooltipItems]);
    const afterFooter = callbacks.afterFooter.apply(me, [tooltipItems]);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const me = this;
    const active = me._active;
    const data = me._chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(me._chart, active[i]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
    }
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(scoped.labelColor.call(me, context));
      labelPointStyles.push(scoped.labelPointStyle.call(me, context));
      labelTextColors.push(scoped.labelTextColor.call(me, context));
    });
    me.labelColors = labelColors;
    me.labelPointStyles = labelPointStyles;
    me.labelTextColors = labelTextColors;
    me.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const me = this;
    const options = me.options.setContext(me.getContext());
    const active = me._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (me.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(me, active, me._eventPosition);
      tooltipItems = me._createItems(options);
      me.title = me.getTitle(tooltipItems, options);
      me.beforeBody = me.getBeforeBody(tooltipItems, options);
      me.body = me.getBody(tooltipItems, options);
      me.afterBody = me.getAfterBody(tooltipItems, options);
      me.footer = me.getFooter(tooltipItems, options);
      const size = me._size = getTooltipSize(me, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(me._chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, me._chart);
      me.xAlign = alignment.xAlign;
      me.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    me._tooltipItems = tooltipItems;
    me.$context = undefined;
    if (properties) {
      me._resolveAnimations().update(me, properties);
    }
    if (changed && options.external) {
      options.external.call(me, {chart: me._chart, tooltip: me, replay});
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const {xAlign, yAlign} = this;
    const {cornerRadius, caretSize} = options;
    const {x: ptX, y: ptY} = tooltipPoint;
    const {width, height} = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === 'center') {
      y2 = ptY + (height / 2);
      if (xAlign === 'left') {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === 'left') {
        x2 = ptX + cornerRadius + (caretSize);
      } else if (xAlign === 'right') {
        x2 = ptX + width - cornerRadius - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === 'top') {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {x1, x2, x3, y1, y2, y3};
  }
  drawTitle(pt, ctx, options) {
    const me = this;
    const title = me.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.au)(options.rtl, me.x, me.width);
      pt.x = getAlignedX(me, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = 'middle';
      titleFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options) {
    const me = this;
    const labelColors = me.labelColors[i];
    const labelPointStyle = me.labelPointStyles[i];
    const {boxHeight, boxWidth} = options;
    const bodyFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(options.bodyFont);
    const colorX = getAlignedX(me, 'left', options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ao)(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColors.borderColor;
      ctx.fillStyle = labelColors.backgroundColor;
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ao)(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = labelColors.borderWidth || 1;
      ctx.strokeStyle = labelColors.borderColor;
      ctx.setLineDash(labelColors.borderDash || []);
      ctx.lineDashOffset = labelColors.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
      const borderRadius = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ar)(labelColors.borderRadius);
      if (Object.values(borderRadius).some(v => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ap)(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius,
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.beginPath();
        (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ap)(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius,
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColors.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = me.labelTextColors[i];
  }
  drawBody(pt, ctx, options) {
    const me = this;
    const {body} = me;
    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth} = options;
    const bodyFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.au)(options.rtl, me.x, me.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = 'middle';
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(me, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(me.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'
      ? bodyAlign === 'center' ? (boxWidth / 2 + 1) : (boxWidth + 2)
      : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = me.labelTextColors[i];
      ctx.fillStyle = textColor;
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        me._drawColorBox(ctx, pt, i, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.B)(me.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const me = this;
    const footer = me.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.au)(options.rtl, me.x, me.width);
      pt.x = getAlignedX(me, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = 'middle';
      footerFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const {xAlign, yAlign} = this;
    const {x, y} = pt;
    const {width, height} = tooltipSize;
    const radius = options.cornerRadius;
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    if (yAlign === 'top') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    if (yAlign === 'center' && xAlign === 'right') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    if (yAlign === 'bottom') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    if (yAlign === 'center' && xAlign === 'left') {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const me = this;
    const chart = me._chart;
    const anims = me.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(me, me._active, me._eventPosition);
      if (!position) {
        return;
      }
      const size = me._size = getTooltipSize(me, options);
      const positionAndSize = Object.assign({}, position, me._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        me.xAlign = alignment.xAlign;
        me.yAlign = alignment.yAlign;
        me.width = size.width;
        me.height = size.height;
        me.caretX = position.x;
        me.caretY = position.y;
        me._resolveAnimations().update(me, point);
      }
    }
  }
  draw(ctx) {
    const me = this;
    const options = me.options.setContext(me.getContext());
    let opacity = me.opacity;
    if (!opacity) {
      return;
    }
    me._updateAnimationTarget(options);
    const tooltipSize = {
      width: me.width,
      height: me.height
    };
    const pt = {
      x: me.x,
      y: me.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.A)(options.padding);
    const hasTooltipContent = me.title.length || me.beforeBody.length || me.body.length || me.afterBody.length || me.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      me.drawBackground(pt, ctx, tooltipSize, options);
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, options.textDirection);
      pt.y += padding.top;
      me.drawTitle(pt, ctx, options);
      me.drawBody(pt, ctx, options);
      me.drawFooter(pt, ctx, options);
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ax)(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const me = this;
    const lastActive = me._active;
    const active = activeElements.map(({datasetIndex, index}) => {
      const meta = me._chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error('Cannot find a dataset at index ' + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index],
        index,
      };
    });
    const changed = !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ad)(lastActive, active);
    const positionChanged = me._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      me._active = active;
      me._eventPosition = eventPosition;
      me.update(true);
    }
  }
  handleEvent(e, replay) {
    const me = this;
    const options = me.options;
    const lastActive = me._active || [];
    let changed = false;
    let active = [];
    if (e.type !== 'mouseout') {
      active = me._chart.getElementsAtEventForMode(e, options.mode, options, replay);
      if (options.reverse) {
        active.reverse();
      }
    }
    const positionChanged = me._positionChanged(active, e);
    changed = replay || !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ad)(active, lastActive) || positionChanged;
    if (changed) {
      me._active = active;
      if (options.enabled || options.external) {
        me._eventPosition = {
          x: e.x,
          y: e.y
        };
        me.update(true, replay);
      }
    }
    return changed;
  }
  _positionChanged(active, e) {
    const {caretX, caretY, options} = this;
    const position = positioners[options.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
}
Tooltip.positioners = positioners;
var plugin_tooltip = {
  id: 'tooltip',
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({_chart: chart, options});
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    const args = {
      tooltip
    };
    if (chart.notifyPlugins('beforeTooltipDraw', args) === false) {
      return;
    }
    if (tooltip) {
      tooltip.draw(chart.ctx);
    }
    chart.notifyPlugins('afterTooltipDraw', args);
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: 'average',
    backgroundColor: 'rgba(0,0,0,0.8)',
    titleColor: '#fff',
    titleFont: {
      weight: 'bold',
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: 'left',
    bodyColor: '#fff',
    bodySpacing: 2,
    bodyFont: {
    },
    bodyAlign: 'left',
    footerColor: '#fff',
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: 'bold',
    },
    footerAlign: 'left',
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: '#fff',
    displayColors: true,
    borderColor: 'rgba(0,0,0,0)',
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: 'easeOutQuart',
    },
    animations: {
      numbers: {
        type: 'number',
        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],
      },
      opacity: {
        easing: 'linear',
        duration: 200
      }
    },
    callbacks: {
      beforeTitle: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ay,
      title(tooltipItems) {
        if (tooltipItems.length > 0) {
          const item = tooltipItems[0];
          const labels = item.chart.data.labels;
          const labelCount = labels ? labels.length : 0;
          if (this && this.options && this.options.mode === 'dataset') {
            return item.dataset.label || '';
          } else if (item.label) {
            return item.label;
          } else if (labelCount > 0 && item.dataIndex < labelCount) {
            return labels[item.dataIndex];
          }
        }
        return '';
      },
      afterTitle: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ay,
      beforeBody: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ay,
      beforeLabel: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ay,
      label(tooltipItem) {
        if (this && this.options && this.options.mode === 'dataset') {
          return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;
        }
        let label = tooltipItem.dataset.label || '';
        if (label) {
          label += ': ';
        }
        const value = tooltipItem.formattedValue;
        if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(value)) {
          label += value;
        }
        return label;
      },
      labelColor(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          borderColor: options.borderColor,
          backgroundColor: options.backgroundColor,
          borderWidth: options.borderWidth,
          borderDash: options.borderDash,
          borderDashOffset: options.borderDashOffset,
          borderRadius: 0,
        };
      },
      labelTextColor() {
        return this.options.bodyColor;
      },
      labelPointStyle(tooltipItem) {
        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
        const options = meta.controller.getStyle(tooltipItem.dataIndex);
        return {
          pointStyle: options.pointStyle,
          rotation: options.rotation,
        };
      },
      afterLabel: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ay,
      afterBody: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ay,
      beforeFooter: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ay,
      footer: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ay,
      afterFooter: _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.ay
    }
  },
  defaultRoutes: {
    bodyFont: 'font',
    footerFont: 'font',
    titleFont: 'font'
  },
  descriptors: {
    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false,
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: 'animation'
    }
  },
  additionalOptionScopes: ['interaction']
};

var plugins = /*#__PURE__*/Object.freeze({
__proto__: null,
Decimation: plugin_decimation,
Filler: plugin_filler,
Legend: plugin_legend,
SubTitle: plugin_subtitle,
Title: plugin_title,
Tooltip: plugin_tooltip
});

const addIfString = (labels, raw, index) => typeof raw === 'string'
  ? labels.push(raw) - 1
  : isNaN(raw) ? null : index;
function findOrAddLabel(labels, raw, index) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index : first;
}
const validIndex = (index, max) => index === null ? null : (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(Math.round(index), 0, max);
class CategoryScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = undefined;
    this._valueRange = 0;
  }
  parse(raw, index) {
    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index = isFinite(index) && labels[index] === raw ? index
      : findOrAddLabel(labels, raw, (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(index, raw));
    return validIndex(index, labels.length - 1);
  }
  determineDataLimits() {
    const me = this;
    const {minDefined, maxDefined} = me.getUserBounds();
    let {min, max} = me.getMinMax(true);
    if (me.options.bounds === 'ticks') {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = me.getLabels().length - 1;
      }
    }
    me.min = min;
    me.max = max;
  }
  buildTicks() {
    const me = this;
    const min = me.min;
    const max = me.max;
    const offset = me.options.offset;
    const ticks = [];
    let labels = me.getLabels();
    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);
    me._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    me._startValue = me.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({value});
    }
    return ticks;
  }
  getLabelForValue(value) {
    const me = this;
    const labels = me.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  configure() {
    const me = this;
    super.configure();
    if (!me.isHorizontal()) {
      me._reversePixels = !me._reversePixels;
    }
  }
  getPixelForValue(value) {
    const me = this;
    if (typeof value !== 'number') {
      value = me.parse(value);
    }
    return value === null ? NaN : me.getPixelForDecimal((value - me._startValue) / me._valueRange);
  }
  getPixelForTick(index) {
    const me = this;
    const ticks = me.ticks;
    if (index < 0 || index > ticks.length - 1) {
      return null;
    }
    return me.getPixelForValue(ticks[index].value);
  }
  getValueForPixel(pixel) {
    const me = this;
    return Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
CategoryScale.id = 'category';
CategoryScale.defaults = {
  ticks: {
    callback: CategoryScale.prototype.getLabelForValue
  }
};

function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const {min: rmin, max: rmax} = dataRange;
  const minDefined = !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(min);
  const maxDefined = !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(max);
  const countDefined = !(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aB)((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [{value: rmin}, {value: rmax}];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aB)(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === 'ticks') {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aC)((max - min) / step, spacing / 1000)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aD)(numSpaces, Math.round(numSpaces), spacing / 1000)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aE)(spacing),
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aE)(niceMin)
  );
  factor = Math.pow(10, (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({value: min});
      if (niceMin < min) {
        j++;
      }
      if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aD)(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    ticks.push({value: Math.round((niceMin + j * spacing) * factor) / factor});
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aD)(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({value: max});
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({value: niceMax});
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {
  const rad = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
  const length = 0.75 * minSpacing * ('' + value).length;
  return Math.min(minSpacing / ratio, length);
}
class LinearScaleBase extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = undefined;
    this.end = undefined;
    this._startValue = undefined;
    this._endValue = undefined;
    this._valueRange = 0;
  }
  parse(raw, index) {
    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(raw)) {
      return null;
    }
    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const me = this;
    const {beginAtZero} = me.options;
    const {minDefined, maxDefined} = me.getUserBounds();
    let {min, max} = me;
    const setMin = v => (min = minDefined ? min : v);
    const setMax = v => (max = maxDefined ? max : v);
    if (beginAtZero) {
      const minSign = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.s)(min);
      const maxSign = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.s)(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = 1;
      if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
        offset = Math.abs(max * 0.05);
      }
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    me.min = min;
    me.max = max;
  }
  getTickLimit() {
    const me = this;
    const tickOpts = me.options.ticks;
    let {maxTicksLimit, stepSize} = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
    } else {
      maxTicks = me.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const me = this;
    const opts = me.options;
    const tickOpts = opts.ticks;
    let maxTicks = me.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: me._maxDigits(),
      horizontal: me.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = me._range || me;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === 'ticks') {
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aA)(ticks, me, 'value');
    }
    if (opts.reverse) {
      ticks.reverse();
      me.start = me.max;
      me.end = me.min;
    } else {
      me.start = me.min;
      me.end = me.max;
    }
    return ticks;
  }
  configure() {
    const me = this;
    const ticks = me.ticks;
    let start = me.min;
    let end = me.max;
    super.configure();
    if (me.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    me._startValue = start;
    me._endValue = end;
    me._valueRange = end - start;
  }
  getLabelForValue(value) {
    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.n)(value, this.chart.options.locale);
  }
}

class LinearScale extends LinearScaleBase {
  determineDataLimits() {
    const me = this;
    const {min, max} = me.getMinMax(true);
    me.min = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? min : 0;
    me.max = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? max : 1;
    me.handleTickRangeOptions();
  }
  computeTickLimit() {
    const me = this;
    const horizontal = me.isHorizontal();
    const length = horizontal ? me.width : me.height;
    const minRotation = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(me.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;
    const tickFont = me._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
}
LinearScale.id = 'linear';
LinearScale.defaults = {
  ticks: {
    callback: Ticks.formatters.numeric
  }
};

function isMajor(tickVal) {
  const remain = tickVal / (Math.pow(10, Math.floor((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.J)(tickVal))));
  return remain === 1;
}
function generateTicks(generationOptions, dataRange) {
  const endExp = Math.floor((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.J)(dataRange.max));
  const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
  const ticks = [];
  let tickVal = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(generationOptions.min, Math.pow(10, Math.floor((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.J)(dataRange.min))));
  let exp = Math.floor((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.J)(tickVal));
  let significand = Math.floor(tickVal / Math.pow(10, exp));
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  do {
    ticks.push({value: tickVal, major: isMajor(tickVal)});
    ++significand;
    if (significand === 10) {
      significand = 1;
      ++exp;
      precision = exp >= 0 ? 1 : precision;
    }
    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
  } while (exp < endExp || (exp === endExp && significand < endSignificand));
  const lastTick = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.L)(generationOptions.max, tickVal);
  ticks.push({value: lastTick, major: isMajor(tickVal)});
  return ticks;
}
class LogarithmicScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = undefined;
    this.end = undefined;
    this._startValue = undefined;
    this._valueRange = 0;
  }
  parse(raw, index) {
    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);
    if (value === 0) {
      this._zero = true;
      return undefined;
    }
    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const me = this;
    const {min, max} = me.getMinMax(true);
    me.min = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? Math.max(0, min) : null;
    me.max = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? Math.max(0, max) : null;
    if (me.options.beginAtZero) {
      me._zero = true;
    }
    me.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const me = this;
    const {minDefined, maxDefined} = me.getUserBounds();
    let min = me.min;
    let max = me.max;
    const setMin = v => (min = minDefined ? min : v);
    const setMax = v => (max = maxDefined ? max : v);
    const exp = (v, m) => Math.pow(10, Math.floor((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.J)(v)) + m);
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(exp(min, -1));
        setMax(exp(max, +1));
      }
    }
    if (min <= 0) {
      setMin(exp(max, -1));
    }
    if (max <= 0) {
      setMax(exp(min, +1));
    }
    if (me._zero && me.min !== me._suggestedMin && min === exp(me.min, 0)) {
      setMin(exp(min, -1));
    }
    me.min = min;
    me.max = max;
  }
  buildTicks() {
    const me = this;
    const opts = me.options;
    const generationOptions = {
      min: me._userMin,
      max: me._userMax
    };
    const ticks = generateTicks(generationOptions, me);
    if (opts.bounds === 'ticks') {
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aA)(ticks, me, 'value');
    }
    if (opts.reverse) {
      ticks.reverse();
      me.start = me.max;
      me.end = me.min;
    } else {
      me.start = me.min;
      me.end = me.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === undefined ? '0' : (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.n)(value, this.chart.options.locale);
  }
  configure() {
    const me = this;
    const start = me.min;
    super.configure();
    me._startValue = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.J)(start);
    me._valueRange = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.J)(me.max) - (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.J)(start);
  }
  getPixelForValue(value) {
    const me = this;
    if (value === undefined || value === 0) {
      value = me.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return me.getPixelForDecimal(value === me.min
      ? 0
      : ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.J)(value) - me._startValue) / me._valueRange);
  }
  getValueForPixel(pixel) {
    const me = this;
    const decimal = me.getDecimalForPixel(pixel);
    return Math.pow(10, me._startValue + decimal * me._valueRange);
  }
}
LogarithmicScale.id = 'logarithmic';
LogarithmicScale.defaults = {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
};

function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.A)(tickOpts.backdropPadding);
    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(tickOpts.font && tickOpts.font.size, _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.d.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label : [label];
  return {
    w: (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aF)(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - (size / 2),
      end: pos + (size / 2)
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const furthestLimits = {
    l: 0,
    r: scale.width,
    t: 0,
    b: scale.height - scale.paddingTop
  };
  const furthestAngles = {};
  const labelSizes = [];
  const padding = [];
  const valueCount = scale.getLabels().length;
  for (let i = 0; i < valueCount; i++) {
    const opts = scale.options.pointLabels.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i]);
    const plFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = scale.getIndexAngle(i);
    const angle = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(angleRadians);
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    if (hLimits.start < furthestLimits.l) {
      furthestLimits.l = hLimits.start;
      furthestAngles.l = angleRadians;
    }
    if (hLimits.end > furthestLimits.r) {
      furthestLimits.r = hLimits.end;
      furthestAngles.r = angleRadians;
    }
    if (vLimits.start < furthestLimits.t) {
      furthestLimits.t = vLimits.start;
      furthestAngles.t = angleRadians;
    }
    if (vLimits.end > furthestLimits.b) {
      furthestLimits.b = vLimits.end;
      furthestAngles.b = angleRadians;
    }
  }
  scale._setReductions(scale.drawingArea, furthestLimits, furthestAngles);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale.getLabels().length;
  const opts = scale.options;
  const tickBackdropHeight = getTickBackdropHeight(opts);
  const outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);
  for (let i = 0; i < valueCount; i++) {
    const extra = (i === 0 ? tickBackdropHeight / 2 : 0);
    const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i]);
    const angle = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.O)(scale.getIndexAngle(i));
    const size = labelSizes[i];
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    items.push({
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    });
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return 'center';
  } else if (angle < 180) {
    return 'left';
  }
  return 'right';
}
function leftForTextAlign(x, w, align) {
  if (align === 'right') {
    x -= w;
  } else if (align === 'center') {
    x -= (w / 2);
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= (h / 2);
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabels(scale, labelCount) {
  const {ctx, options: {pointLabels}} = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    const plFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(optsAtIndex.font);
    const {x, y, textAlign, left, top, right, bottom} = scale._pointLabelItems[i];
    const {backdropColor} = optsAtIndex;
    if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(backdropColor)) {
      const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.A)(optsAtIndex.backdropPadding);
      ctx.fillStyle = backdropColor;
      ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);
    }
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.V)(
      ctx,
      scale._pointLabels[i],
      x,
      y + (plFont.lineHeight / 2),
      plFont,
      {
        color: optsAtIndex.color,
        textAlign: textAlign,
        textBaseline: 'middle'
      }
    );
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const {ctx} = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const {color, lineWidth} = gridLineOpts;
  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(gridLineOpts.borderDash);
  ctx.lineDashOffset = gridLineOpts.borderDashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function numberOrZero(param) {
  return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.p)(param) ? param : 0;
}
function createPointLabelContext(parent, index, label) {
  return Object.assign(Object.create(parent), {
    label,
    index,
    type: 'pointLabel'
  });
}
class RadialLinearScale extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = undefined;
    this.yCenter = undefined;
    this.drawingArea = undefined;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const me = this;
    me.width = me.maxWidth;
    me.height = me.maxHeight;
    me.paddingTop = getTickBackdropHeight(me.options) / 2;
    me.xCenter = Math.floor(me.width / 2);
    me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
    me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
  }
  determineDataLimits() {
    const me = this;
    const {min, max} = me.getMinMax(false);
    me.min = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : 0;
    me.max = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : 0;
    me.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    const me = this;
    LinearScaleBase.prototype.generateTickLabels.call(me, ticks);
    me._pointLabels = me.getLabels().map((value, index) => {
      const label = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(me.options.pointLabels.callback, [value, index], me);
      return label || label === 0 ? label : '';
    });
  }
  fit() {
    const me = this;
    const opts = me.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(me);
    } else {
      me.setCenterPoint(0, 0, 0, 0);
    }
  }
  _setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {
    const me = this;
    let radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
    let radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
    let radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
    let radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
    radiusReductionLeft = numberOrZero(radiusReductionLeft);
    radiusReductionRight = numberOrZero(radiusReductionRight);
    radiusReductionTop = numberOrZero(radiusReductionTop);
    radiusReductionBottom = numberOrZero(radiusReductionBottom);
    me.drawingArea = Math.max(largestPossibleRadius / 2, Math.min(
      Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
      Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2)));
    me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    const me = this;
    const maxRight = me.width - rightMovement - me.drawingArea;
    const maxLeft = leftMovement + me.drawingArea;
    const maxTop = topMovement + me.drawingArea;
    const maxBottom = (me.height - me.paddingTop) - bottomMovement - me.drawingArea;
    me.xCenter = Math.floor(((maxLeft + maxRight) / 2) + me.left);
    me.yCenter = Math.floor(((maxTop + maxBottom) / 2) + me.top + me.paddingTop);
  }
  getIndexAngle(index) {
    const angleMultiplier = _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.T / this.getLabels().length;
    const startAngle = this.options.startAngle || 0;
    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.at)(index * angleMultiplier + (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    const me = this;
    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(value)) {
      return NaN;
    }
    const scalingFactor = me.drawingArea / (me.max - me.min);
    if (me.options.reverse) {
      return (me.max - value) * scalingFactor;
    }
    return (value - me.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(distance)) {
      return NaN;
    }
    const me = this;
    const scaledDistance = distance / (me.drawingArea / (me.max - me.min));
    return me.options.reverse ? me.max - scaledDistance : me.min + scaledDistance;
  }
  getPointLabelContext(index) {
    const me = this;
    const pointLabels = me._pointLabels || [];
    if (index >= 0 && index < pointLabels.length) {
      const pointLabel = pointLabels[index];
      return createPointLabelContext(me.getContext(), index, pointLabel);
    }
  }
  getPointPosition(index, distanceFromCenter) {
    const me = this;
    const angle = me.getIndexAngle(index) - _chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.H;
    return {
      x: Math.cos(angle) * distanceFromCenter + me.xCenter,
      y: Math.sin(angle) * distanceFromCenter + me.yCenter,
      angle
    };
  }
  getPointPositionForValue(index, value) {
    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index) {
    return this.getPointPositionForValue(index || 0, this.getBaseValue());
  }
  getPointLabelPosition(index) {
    const {left, top, right, bottom} = this._pointLabelItems[index];
    return {
      left,
      top,
      right,
      bottom,
    };
  }
  drawBackground() {
    const me = this;
    const {backgroundColor, grid: {circular}} = me.options;
    if (backgroundColor) {
      const ctx = me.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(me, me.getDistanceFromCenterForValue(me._endValue), circular, me.getLabels().length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const me = this;
    const ctx = me.ctx;
    const opts = me.options;
    const {angleLines, grid} = opts;
    const labelCount = me.getLabels().length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(me, labelCount);
    }
    if (grid.display) {
      me.ticks.forEach((tick, index) => {
        if (index !== 0) {
          offset = me.getDistanceFromCenterForValue(tick.value);
          const optsAtIndex = grid.setContext(me.getContext(index - 1));
          drawRadiusLine(me, optsAtIndex, offset, labelCount);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = me.getLabels().length - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(me.getPointLabelContext(i));
        const {color, lineWidth} = optsAtIndex;
        if (!lineWidth || !color) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);
        position = me.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(me.xCenter, me.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {}
  drawLabels() {
    const me = this;
    const ctx = me.ctx;
    const opts = me.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = me.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(me.xCenter, me.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    me.ticks.forEach((tick, index) => {
      if (index === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(me.getContext(index));
      const tickFont = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.X)(optsAtIndex.font);
      offset = me.getDistanceFromCenterForValue(me.ticks[index].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.A)(optsAtIndex.backdropPadding);
        ctx.fillRect(
          -width / 2 - padding.left,
          -offset - tickFont.size / 2 - padding.top,
          width + padding.width,
          tickFont.size + padding.height
        );
      }
      (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.V)(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color,
      });
    });
    ctx.restore();
  }
  drawTitle() {}
}
RadialLinearScale.id = 'radialLinear';
RadialLinearScale.defaults = {
  display: true,
  animate: true,
  position: 'chartArea',
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0.0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: undefined,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5
  }
};
RadialLinearScale.defaultRoutes = {
  'angleLines.color': 'borderColor',
  'pointLabels.color': 'color',
  'ticks.color': 'color'
};
RadialLinearScale.descriptors = {
  angleLines: {
    _fallback: 'grid'
  }
};

const INTERVALS = {
  millisecond: {common: true, size: 1, steps: 1000},
  second: {common: true, size: 1000, steps: 60},
  minute: {common: true, size: 60000, steps: 60},
  hour: {common: true, size: 3600000, steps: 24},
  day: {common: true, size: 86400000, steps: 30},
  week: {common: false, size: 604800000, steps: 4},
  month: {common: true, size: 2.628e9, steps: 12},
  quarter: {common: false, size: 7.884e9, steps: 4},
  year: {common: true, size: 3.154e10}
};
const UNITS = (Object.keys(INTERVALS));
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.j)(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const {parser, round, isoWeekday} = scale._parseOpts;
  let value = input;
  if (typeof parser === 'function') {
    value = parser(value);
  }
  if (!(0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {
    value = typeof parser === 'string'
      ? adapter.parse(value, parser)
      : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round) {
    value = round === 'week' && ((0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.p)(isoWeekday) || isoWeekday === true)
      ? adapter.startOf(value, 'isoWeek', isoWeekday)
      : adapter.startOf(value, round);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const {lo, hi} = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aH)(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index = map[major];
    if (index >= 0) {
      ticks[index].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
}
class TimeScale extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = 'day';
    this._majorUnit = undefined;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = undefined;
  }
  init(scaleOpts, opts) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.a7)(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index) {
    if (raw === undefined) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const me = this;
    const options = me.options;
    const adapter = me._adapter;
    const unit = options.time.unit || 'day';
    let {min, max, minDefined, maxDefined} = me.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(me._getLabelBounds());
      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {
        _applyBounds(me.getMinMax(false));
      }
    }
    min = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    me.min = Math.min(min, max - 1);
    me.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {min, max};
  }
  buildTicks() {
    const me = this;
    const options = me.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === 'labels' ? me.getLabelTimestamps() : me._generate();
    if (options.bounds === 'ticks' && timestamps.length) {
      me.min = me._userMin || timestamps[0];
      me.max = me._userMax || timestamps[timestamps.length - 1];
    }
    const min = me.min;
    const max = me.max;
    const ticks = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.aG)(timestamps, min, max);
    me._unit = timeOpts.unit || (tickOpts.autoSkip
      ? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, me._getLabelCapacity(min))
      : determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));
    me._majorUnit = !tickOpts.major.enabled || me._unit === 'year' ? undefined
      : determineMajorUnit(me._unit);
    me.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(me, ticks, me._majorUnit);
  }
  initOffsets(timestamps) {
    const me = this;
    let start = 0;
    let end = 0;
    let first, last;
    if (me.options.offset && timestamps.length) {
      first = me.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (me.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = me.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - me.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(start, 0, limit);
    end = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.q)(end, 0, limit);
    me._offsets = {start, end, factor: 1 / (start + 1 + end)};
  }
  _generate() {
    const me = this;
    const adapter = me._adapter;
    const min = me.min;
    const max = me.max;
    const options = me.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, me._getLabelCapacity(min));
    const stepSize = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.v)(timeOpts.stepSize, 1);
    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
    const hasWeekday = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.p)(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, 'isoWeek', weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);
    if (adapter.diff(max, min, minor) > 100000 * stepSize) {
      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);
    }
    const timestamps = options.ticks.source === 'data' && me.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options.bounds === 'ticks' || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);
  }
  getLabelForValue(value) {
    const me = this;
    const adapter = me._adapter;
    const timeOpts = me.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  _tickFormatFunction(time, index, ticks, format) {
    const me = this;
    const options = me.options;
    const formats = options.time.displayFormats;
    const unit = me._unit;
    const majorUnit = me._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index];
    const major = majorUnit && majorFormat && tick && tick.major;
    const label = me._adapter.format(time, format || (major ? majorFormat : minorFormat));
    const formatter = options.ticks.callback;
    return formatter ? (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.M)(formatter, [label, index, ticks], me) : label;
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    const me = this;
    return value === null ? NaN : (value - me.min) / (me.max - me.min);
  }
  getPixelForValue(value) {
    const me = this;
    const offsets = me._offsets;
    const pos = me.getDecimalForValue(value);
    return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const me = this;
    const offsets = me._offsets;
    const pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return me.min + pos * (me.max - me.min);
  }
  _getLabelSize(label) {
    const me = this;
    const ticksOpts = me.options.ticks;
    const tickLabelWidth = me.ctx.measureText(label).width;
    const angle = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.t)(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = me._resolveTickFontOptions(0).size;
    return {
      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),
      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)
    };
  }
  _getLabelCapacity(exampleTime) {
    const me = this;
    const timeOpts = me.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = me._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format);
    const size = me._getLabelSize(exampleLabel);
    const capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    const me = this;
    let timestamps = me._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = me.getMatchingVisibleMetas();
    if (me._normalized && metas.length) {
      return (me._cache.data = metas[0].controller.getAllParsedValues(me));
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(me));
    }
    return (me._cache.data = me.normalize(timestamps));
  }
  getLabelTimestamps() {
    const me = this;
    const timestamps = me._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = me.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(me, labels[i]));
    }
    return (me._cache.labels = me._normalized ? timestamps : me.normalize(timestamps));
  }
  normalize(values) {
    return (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__._)(values.sort(sorter));
  }
}
TimeScale.id = 'time';
TimeScale.defaults = {
  bounds: 'data',
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: 'millisecond',
    displayFormats: {}
  },
  ticks: {
    source: 'auto',
    major: {
      enabled: false
    }
  }
};

function interpolate(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({lo, hi} = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(table, 'pos', val));
    }
    ({pos: prevSource, time: prevTarget} = table[lo]);
    ({pos: nextSource, time: nextTarget} = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({lo, hi} = (0,_chunks_helpers_segment_js__WEBPACK_IMPORTED_MODULE_0__.w)(table, 'time', val));
    }
    ({time: prevSource, pos: prevTarget} = table[lo]);
    ({time: nextSource, pos: nextTarget} = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
class TimeSeriesScale extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = undefined;
    this._tableRange = undefined;
  }
  initOffsets() {
    const me = this;
    const timestamps = me._getTimestampsForTable();
    const table = me._table = me.buildLookupTable(timestamps);
    me._minPos = interpolate(table, me.min);
    me._tableRange = interpolate(table, me.max) - me._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const {min, max} = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {time: min, pos: 0},
        {time: max, pos: 1}
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({time: curr, pos: i / (ilen - 1)});
      }
    }
    return table;
  }
  _getTimestampsForTable() {
    const me = this;
    let timestamps = me._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = me.getDataTimestamps();
    const label = me.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = me.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = me._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const me = this;
    const offsets = me._offsets;
    const decimal = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate(me._table, decimal * me._tableRange + me._minPos, true);
  }
}
TimeSeriesScale.id = 'timeseries';
TimeSeriesScale.defaults = TimeScale.defaults;

var scales = /*#__PURE__*/Object.freeze({
__proto__: null,
CategoryScale: CategoryScale,
LinearScale: LinearScale,
LogarithmicScale: LogarithmicScale,
RadialLinearScale: RadialLinearScale,
TimeScale: TimeScale,
TimeSeriesScale: TimeSeriesScale
});

const registerables = [
  controllers,
  elements,
  plugins,
  scales,
];




/***/ }),

/***/ "./node_modules/chart.js/dist/chunks/helpers.segment.js":
/*!**************************************************************!*\
  !*** ./node_modules/chart.js/dist/chunks/helpers.segment.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$": () => (/* binding */ overrides),
/* harmony export */   "A": () => (/* binding */ toPadding),
/* harmony export */   "B": () => (/* binding */ each),
/* harmony export */   "C": () => (/* binding */ getMaximumSize),
/* harmony export */   "D": () => (/* binding */ _getParentNode),
/* harmony export */   "E": () => (/* binding */ readUsedSize),
/* harmony export */   "F": () => (/* binding */ throttled),
/* harmony export */   "G": () => (/* binding */ supportsEventListenerOptions),
/* harmony export */   "H": () => (/* binding */ HALF_PI),
/* harmony export */   "I": () => (/* binding */ _isDomSupported),
/* harmony export */   "J": () => (/* binding */ log10),
/* harmony export */   "K": () => (/* binding */ _factorize),
/* harmony export */   "L": () => (/* binding */ finiteOrDefault),
/* harmony export */   "M": () => (/* binding */ callback),
/* harmony export */   "N": () => (/* binding */ _addGrace),
/* harmony export */   "O": () => (/* binding */ toDegrees),
/* harmony export */   "P": () => (/* binding */ PI),
/* harmony export */   "Q": () => (/* binding */ _measureText),
/* harmony export */   "R": () => (/* binding */ _int16Range),
/* harmony export */   "S": () => (/* binding */ _alignPixel),
/* harmony export */   "T": () => (/* binding */ TAU),
/* harmony export */   "U": () => (/* binding */ clipArea),
/* harmony export */   "V": () => (/* binding */ renderText),
/* harmony export */   "W": () => (/* binding */ unclipArea),
/* harmony export */   "X": () => (/* binding */ toFont),
/* harmony export */   "Y": () => (/* binding */ _toLeftRightCenter),
/* harmony export */   "Z": () => (/* binding */ _alignStartEnd),
/* harmony export */   "_": () => (/* binding */ _arrayUnique),
/* harmony export */   "a": () => (/* binding */ resolve),
/* harmony export */   "a0": () => (/* binding */ merge),
/* harmony export */   "a1": () => (/* binding */ _capitalize),
/* harmony export */   "a2": () => (/* binding */ descriptors),
/* harmony export */   "a3": () => (/* binding */ isFunction),
/* harmony export */   "a4": () => (/* binding */ _attachContext),
/* harmony export */   "a5": () => (/* binding */ _createResolver),
/* harmony export */   "a6": () => (/* binding */ _descriptors),
/* harmony export */   "a7": () => (/* binding */ mergeIf),
/* harmony export */   "a8": () => (/* binding */ uid),
/* harmony export */   "a9": () => (/* binding */ debounce),
/* harmony export */   "aA": () => (/* binding */ _setMinAndMaxByKey),
/* harmony export */   "aB": () => (/* binding */ niceNum),
/* harmony export */   "aC": () => (/* binding */ almostWhole),
/* harmony export */   "aD": () => (/* binding */ almostEquals),
/* harmony export */   "aE": () => (/* binding */ _decimalPlaces),
/* harmony export */   "aF": () => (/* binding */ _longestText),
/* harmony export */   "aG": () => (/* binding */ _filterBetween),
/* harmony export */   "aH": () => (/* binding */ _lookup),
/* harmony export */   "aI": () => (/* binding */ getHoverColor),
/* harmony export */   "aJ": () => (/* binding */ clone$1),
/* harmony export */   "aK": () => (/* binding */ _merger),
/* harmony export */   "aL": () => (/* binding */ _mergerIf),
/* harmony export */   "aM": () => (/* binding */ _deprecated),
/* harmony export */   "aN": () => (/* binding */ toFontString),
/* harmony export */   "aO": () => (/* binding */ splineCurve),
/* harmony export */   "aP": () => (/* binding */ splineCurveMonotone),
/* harmony export */   "aQ": () => (/* binding */ getStyle),
/* harmony export */   "aR": () => (/* binding */ fontString),
/* harmony export */   "aS": () => (/* binding */ toLineHeight),
/* harmony export */   "aT": () => (/* binding */ PITAU),
/* harmony export */   "aU": () => (/* binding */ INFINITY),
/* harmony export */   "aV": () => (/* binding */ RAD_PER_DEG),
/* harmony export */   "aW": () => (/* binding */ QUARTER_PI),
/* harmony export */   "aX": () => (/* binding */ TWO_THIRDS_PI),
/* harmony export */   "aY": () => (/* binding */ _angleDiff),
/* harmony export */   "aa": () => (/* binding */ retinaScale),
/* harmony export */   "ab": () => (/* binding */ clearCanvas),
/* harmony export */   "ac": () => (/* binding */ setsEqual),
/* harmony export */   "ad": () => (/* binding */ _elementsEqual),
/* harmony export */   "ae": () => (/* binding */ getAngleFromPoint),
/* harmony export */   "af": () => (/* binding */ _readValueToProps),
/* harmony export */   "ag": () => (/* binding */ _updateBezierControlPoints),
/* harmony export */   "ah": () => (/* binding */ _computeSegments),
/* harmony export */   "ai": () => (/* binding */ _boundSegments),
/* harmony export */   "aj": () => (/* binding */ _steppedInterpolation),
/* harmony export */   "ak": () => (/* binding */ _bezierInterpolation),
/* harmony export */   "al": () => (/* binding */ _pointInLine),
/* harmony export */   "am": () => (/* binding */ _steppedLineTo),
/* harmony export */   "an": () => (/* binding */ _bezierCurveTo),
/* harmony export */   "ao": () => (/* binding */ drawPoint),
/* harmony export */   "ap": () => (/* binding */ addRoundedRectPath),
/* harmony export */   "aq": () => (/* binding */ toTRBL),
/* harmony export */   "ar": () => (/* binding */ toTRBLCorners),
/* harmony export */   "as": () => (/* binding */ _boundSegment),
/* harmony export */   "at": () => (/* binding */ _normalizeAngle),
/* harmony export */   "au": () => (/* binding */ getRtlAdapter),
/* harmony export */   "av": () => (/* binding */ overrideTextDirection),
/* harmony export */   "aw": () => (/* binding */ _textX),
/* harmony export */   "ax": () => (/* binding */ restoreTextDirection),
/* harmony export */   "ay": () => (/* binding */ noop),
/* harmony export */   "az": () => (/* binding */ distanceBetweenPoints),
/* harmony export */   "b": () => (/* binding */ isArray),
/* harmony export */   "c": () => (/* binding */ color),
/* harmony export */   "d": () => (/* binding */ defaults),
/* harmony export */   "e": () => (/* binding */ effects),
/* harmony export */   "f": () => (/* binding */ resolveObjectKey),
/* harmony export */   "g": () => (/* binding */ isNumberFinite),
/* harmony export */   "h": () => (/* binding */ defined),
/* harmony export */   "i": () => (/* binding */ isObject),
/* harmony export */   "j": () => (/* binding */ isNullOrUndef),
/* harmony export */   "k": () => (/* binding */ toPercentage),
/* harmony export */   "l": () => (/* binding */ listenArrayEvents),
/* harmony export */   "m": () => (/* binding */ toDimension),
/* harmony export */   "n": () => (/* binding */ formatNumber),
/* harmony export */   "o": () => (/* binding */ _angleBetween),
/* harmony export */   "p": () => (/* binding */ isNumber),
/* harmony export */   "q": () => (/* binding */ _limitValue),
/* harmony export */   "r": () => (/* binding */ requestAnimFrame),
/* harmony export */   "s": () => (/* binding */ sign),
/* harmony export */   "t": () => (/* binding */ toRadians),
/* harmony export */   "u": () => (/* binding */ unlistenArrayEvents),
/* harmony export */   "v": () => (/* binding */ valueOrDefault),
/* harmony export */   "w": () => (/* binding */ _lookupByKey),
/* harmony export */   "x": () => (/* binding */ getRelativePosition),
/* harmony export */   "y": () => (/* binding */ _isPointInArea),
/* harmony export */   "z": () => (/* binding */ _rlookupByKey)
/* harmony export */ });
/*!
 * Chart.js v3.5.1
 * https://www.chartjs.org
 * (c) 2021 Chart.js Contributors
 * Released under the MIT License
 */
function fontString(pixelSize, fontStyle, fontFamily) {
  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
}
const requestAnimFrame = (function() {
  if (typeof window === 'undefined') {
    return function(callback) {
      return callback();
    };
  }
  return window.requestAnimationFrame;
}());
function throttled(fn, thisArg, updateFn) {
  const updateArgs = updateFn || ((args) => Array.prototype.slice.call(args));
  let ticking = false;
  let args = [];
  return function(...rest) {
    args = updateArgs(rest);
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, args);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function() {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay);
    } else {
      fn();
    }
    return delay;
  };
}
const _toLeftRightCenter = (align) => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';
const _alignStartEnd = (align, start, end) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;
const _textX = (align, left, right, rtl) => {
  const check = rtl ? 'left' : 'right';
  return align === check ? right : align === 'center' ? (left + right) / 2 : left;
};

function noop() {}
const uid = (function() {
  let id = 0;
  return function() {
    return id++;
  };
}());
function isNullOrUndef(value) {
  return value === null || typeof value === 'undefined';
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === '[object Object]';
}
const isNumberFinite = (value) => (typeof value === 'number' || value instanceof Number) && isFinite(+value);
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === 'undefined' ? defaultValue : value;
}
const toPercentage = (value, dimension) =>
  typeof value === 'string' && value.endsWith('%') ?
    parseFloat(value) / 100
    : value / dimension;
const toDimension = (value, dimension) =>
  typeof value === 'string' && value.endsWith('%') ?
    parseFloat(value) / 100 * dimension
    : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === 'function') {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone$1(source) {
  if (isArray(source)) {
    return source.map(clone$1);
  }
  if (isObject(source)) {
    const target = Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone$1(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone$1(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [source];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  for (let i = 0; i < ilen; ++i) {
    source = sources[i];
    if (!isObject(source)) {
      continue;
    }
    const keys = Object.keys(source);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, source, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {merger: _mergerIf});
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone$1(sval);
  }
}
function _deprecated(scope, value, previous, current) {
  if (value !== undefined) {
    console.warn(scope + ': "' + previous +
			'" is deprecated. Please use "' + current + '" instead');
  }
}
const emptyString = '';
const dot = '.';
function indexOfDotOrLength(key, start) {
  const idx = key.indexOf(dot, start);
  return idx === -1 ? key.length : idx;
}
function resolveObjectKey(obj, key) {
  if (key === emptyString) {
    return obj;
  }
  let pos = 0;
  let idx = indexOfDotOrLength(key, pos);
  while (obj && idx > pos) {
    obj = obj[key.substr(pos, idx - pos)];
    pos = idx + 1;
    idx = indexOfDotOrLength(key, pos);
  }
  return obj;
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
const defined = (value) => typeof value !== 'undefined';
const isFunction = (value) => typeof value === 'function';
const setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};

const PI = Math.PI;
const TAU = 2 * PI;
const PITAU = TAU + PI;
const INFINITY = Number.POSITIVE_INFINITY;
const RAD_PER_DEG = PI / 180;
const HALF_PI = PI / 2;
const QUARTER_PI = PI / 4;
const TWO_THIRDS_PI = PI * 2 / 3;
const log10 = Math.log10;
const sign = Math.sign;
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < (-0.5 * PI)) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || (sameAngleIsFullCircle && s === e)
    || (angleToStart > angleToEnd && startToAngle < endToAngle);
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}

const atEdge = (t) => t === 0 || t === 1;
const elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
const effects = {
  linear: t => t,
  easeInQuad: t => t * t,
  easeOutQuad: t => -t * (t - 2),
  easeInOutQuad: t => ((t /= 0.5) < 1)
    ? 0.5 * t * t
    : -0.5 * ((--t) * (t - 2) - 1),
  easeInCubic: t => t * t * t,
  easeOutCubic: t => (t -= 1) * t * t + 1,
  easeInOutCubic: t => ((t /= 0.5) < 1)
    ? 0.5 * t * t * t
    : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: t => t * t * t * t,
  easeOutQuart: t => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: t => ((t /= 0.5) < 1)
    ? 0.5 * t * t * t * t
    : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: t => t * t * t * t * t,
  easeOutQuint: t => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: t => ((t /= 0.5) < 1)
    ? 0.5 * t * t * t * t * t
    : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: t => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: t => Math.sin(t * HALF_PI),
  easeInOutSine: t => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: t => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: t => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: t => atEdge(t) ? t : t < 0.5
    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))
    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: t => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: t => ((t /= 0.5) < 1)
    ? -0.5 * (Math.sqrt(1 - t * t) - 1)
    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: t => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: t => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t :
      t < 0.5
        ? 0.5 * elasticIn(t * 2, s, p)
        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
  },
  easeInBounce: t => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < (1 / d)) {
      return m * t * t;
    }
    if (t < (2 / d)) {
      return m * (t -= (1.5 / d)) * t + 0.75;
    }
    if (t < (2.5 / d)) {
      return m * (t -= (2.25 / d)) * t + 0.9375;
    }
    return m * (t -= (2.625 / d)) * t + 0.984375;
  },
  easeInOutBounce: t => (t < 0.5)
    ? effects.easeInBounce(t * 2) * 0.5
    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,
};

/*!
 * @kurkle/color v0.1.9
 * https://github.com/kurkle/color#readme
 * (c) 2020 Jukka Kurkela
 * Released under the MIT License
 */
const map = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};
const hex = '0123456789ABCDEF';
const h1 = (b) => hex[b & 0xF];
const h2 = (b) => hex[(b & 0xF0) >> 4] + hex[b & 0xF];
const eq = (b) => (((b & 0xF0) >> 4) === (b & 0xF));
function isShort(v) {
	return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
}
function hexParse(str) {
	var len = str.length;
	var ret;
	if (str[0] === '#') {
		if (len === 4 || len === 5) {
			ret = {
				r: 255 & map[str[1]] * 17,
				g: 255 & map[str[2]] * 17,
				b: 255 & map[str[3]] * 17,
				a: len === 5 ? map[str[4]] * 17 : 255
			};
		} else if (len === 7 || len === 9) {
			ret = {
				r: map[str[1]] << 4 | map[str[2]],
				g: map[str[3]] << 4 | map[str[4]],
				b: map[str[5]] << 4 | map[str[6]],
				a: len === 9 ? (map[str[7]] << 4 | map[str[8]]) : 255
			};
		}
	}
	return ret;
}
function hexString(v) {
	var f = isShort(v) ? h1 : h2;
	return v
		? '#' + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : '')
		: v;
}
function round(v) {
	return v + 0.5 | 0;
}
const lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
	return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
	return lim(round(v * 255), 0, 255);
}
function b2n(v) {
	return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
	return lim(round(v * 100), 0, 100);
}
const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
	const m = RGB_RE.exec(str);
	let a = 255;
	let r, g, b;
	if (!m) {
		return;
	}
	if (m[7] !== r) {
		const v = +m[7];
		a = 255 & (m[8] ? p2b(v) : v * 255);
	}
	r = +m[1];
	g = +m[3];
	b = +m[5];
	r = 255 & (m[2] ? p2b(r) : r);
	g = 255 & (m[4] ? p2b(g) : g);
	b = 255 & (m[6] ? p2b(b) : b);
	return {
		r: r,
		g: g,
		b: b,
		a: a
	};
}
function rgbString(v) {
	return v && (
		v.a < 255
			? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`
			: `rgb(${v.r}, ${v.g}, ${v.b})`
	);
}
const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
	const a = s * Math.min(l, 1 - l);
	const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
	return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
	const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
	return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
	const rgb = hsl2rgbn(h, 1, 0.5);
	let i;
	if (w + b > 1) {
		i = 1 / (w + b);
		w *= i;
		b *= i;
	}
	for (i = 0; i < 3; i++) {
		rgb[i] *= 1 - w - b;
		rgb[i] += w;
	}
	return rgb;
}
function rgb2hsl(v) {
	const range = 255;
	const r = v.r / range;
	const g = v.g / range;
	const b = v.b / range;
	const max = Math.max(r, g, b);
	const min = Math.min(r, g, b);
	const l = (max + min) / 2;
	let h, s, d;
	if (max !== min) {
		d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		h = max === r
			? ((g - b) / d) + (g < b ? 6 : 0)
			: max === g
				? (b - r) / d + 2
				: (r - g) / d + 4;
		h = h * 60 + 0.5;
	}
	return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
	return (
		Array.isArray(a)
			? f(a[0], a[1], a[2])
			: f(a, b, c)
	).map(n2b);
}
function hsl2rgb(h, s, l) {
	return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
	return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
	return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
	return (h % 360 + 360) % 360;
}
function hueParse(str) {
	const m = HUE_RE.exec(str);
	let a = 255;
	let v;
	if (!m) {
		return;
	}
	if (m[5] !== v) {
		a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
	}
	const h = hue(+m[2]);
	const p1 = +m[3] / 100;
	const p2 = +m[4] / 100;
	if (m[1] === 'hwb') {
		v = hwb2rgb(h, p1, p2);
	} else if (m[1] === 'hsv') {
		v = hsv2rgb(h, p1, p2);
	} else {
		v = hsl2rgb(h, p1, p2);
	}
	return {
		r: v[0],
		g: v[1],
		b: v[2],
		a: a
	};
}
function rotate(v, deg) {
	var h = rgb2hsl(v);
	h[0] = hue(h[0] + deg);
	h = hsl2rgb(h);
	v.r = h[0];
	v.g = h[1];
	v.b = h[2];
}
function hslString(v) {
	if (!v) {
		return;
	}
	const a = rgb2hsl(v);
	const h = a[0];
	const s = n2p(a[1]);
	const l = n2p(a[2]);
	return v.a < 255
		? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`
		: `hsl(${h}, ${s}%, ${l}%)`;
}
const map$1 = {
	x: 'dark',
	Z: 'light',
	Y: 're',
	X: 'blu',
	W: 'gr',
	V: 'medium',
	U: 'slate',
	A: 'ee',
	T: 'ol',
	S: 'or',
	B: 'ra',
	C: 'lateg',
	D: 'ights',
	R: 'in',
	Q: 'turquois',
	E: 'hi',
	P: 'ro',
	O: 'al',
	N: 'le',
	M: 'de',
	L: 'yello',
	F: 'en',
	K: 'ch',
	G: 'arks',
	H: 'ea',
	I: 'ightg',
	J: 'wh'
};
const names = {
	OiceXe: 'f0f8ff',
	antiquewEte: 'faebd7',
	aqua: 'ffff',
	aquamarRe: '7fffd4',
	azuY: 'f0ffff',
	beige: 'f5f5dc',
	bisque: 'ffe4c4',
	black: '0',
	blanKedOmond: 'ffebcd',
	Xe: 'ff',
	XeviTet: '8a2be2',
	bPwn: 'a52a2a',
	burlywood: 'deb887',
	caMtXe: '5f9ea0',
	KartYuse: '7fff00',
	KocTate: 'd2691e',
	cSO: 'ff7f50',
	cSnflowerXe: '6495ed',
	cSnsilk: 'fff8dc',
	crimson: 'dc143c',
	cyan: 'ffff',
	xXe: '8b',
	xcyan: '8b8b',
	xgTMnPd: 'b8860b',
	xWay: 'a9a9a9',
	xgYF: '6400',
	xgYy: 'a9a9a9',
	xkhaki: 'bdb76b',
	xmagFta: '8b008b',
	xTivegYF: '556b2f',
	xSange: 'ff8c00',
	xScEd: '9932cc',
	xYd: '8b0000',
	xsOmon: 'e9967a',
	xsHgYF: '8fbc8f',
	xUXe: '483d8b',
	xUWay: '2f4f4f',
	xUgYy: '2f4f4f',
	xQe: 'ced1',
	xviTet: '9400d3',
	dAppRk: 'ff1493',
	dApskyXe: 'bfff',
	dimWay: '696969',
	dimgYy: '696969',
	dodgerXe: '1e90ff',
	fiYbrick: 'b22222',
	flSOwEte: 'fffaf0',
	foYstWAn: '228b22',
	fuKsia: 'ff00ff',
	gaRsbSo: 'dcdcdc',
	ghostwEte: 'f8f8ff',
	gTd: 'ffd700',
	gTMnPd: 'daa520',
	Way: '808080',
	gYF: '8000',
	gYFLw: 'adff2f',
	gYy: '808080',
	honeyMw: 'f0fff0',
	hotpRk: 'ff69b4',
	RdianYd: 'cd5c5c',
	Rdigo: '4b0082',
	ivSy: 'fffff0',
	khaki: 'f0e68c',
	lavFMr: 'e6e6fa',
	lavFMrXsh: 'fff0f5',
	lawngYF: '7cfc00',
	NmoncEffon: 'fffacd',
	ZXe: 'add8e6',
	ZcSO: 'f08080',
	Zcyan: 'e0ffff',
	ZgTMnPdLw: 'fafad2',
	ZWay: 'd3d3d3',
	ZgYF: '90ee90',
	ZgYy: 'd3d3d3',
	ZpRk: 'ffb6c1',
	ZsOmon: 'ffa07a',
	ZsHgYF: '20b2aa',
	ZskyXe: '87cefa',
	ZUWay: '778899',
	ZUgYy: '778899',
	ZstAlXe: 'b0c4de',
	ZLw: 'ffffe0',
	lime: 'ff00',
	limegYF: '32cd32',
	lRF: 'faf0e6',
	magFta: 'ff00ff',
	maPon: '800000',
	VaquamarRe: '66cdaa',
	VXe: 'cd',
	VScEd: 'ba55d3',
	VpurpN: '9370db',
	VsHgYF: '3cb371',
	VUXe: '7b68ee',
	VsprRggYF: 'fa9a',
	VQe: '48d1cc',
	VviTetYd: 'c71585',
	midnightXe: '191970',
	mRtcYam: 'f5fffa',
	mistyPse: 'ffe4e1',
	moccasR: 'ffe4b5',
	navajowEte: 'ffdead',
	navy: '80',
	Tdlace: 'fdf5e6',
	Tive: '808000',
	TivedBb: '6b8e23',
	Sange: 'ffa500',
	SangeYd: 'ff4500',
	ScEd: 'da70d6',
	pOegTMnPd: 'eee8aa',
	pOegYF: '98fb98',
	pOeQe: 'afeeee',
	pOeviTetYd: 'db7093',
	papayawEp: 'ffefd5',
	pHKpuff: 'ffdab9',
	peru: 'cd853f',
	pRk: 'ffc0cb',
	plum: 'dda0dd',
	powMrXe: 'b0e0e6',
	purpN: '800080',
	YbeccapurpN: '663399',
	Yd: 'ff0000',
	Psybrown: 'bc8f8f',
	PyOXe: '4169e1',
	saddNbPwn: '8b4513',
	sOmon: 'fa8072',
	sandybPwn: 'f4a460',
	sHgYF: '2e8b57',
	sHshell: 'fff5ee',
	siFna: 'a0522d',
	silver: 'c0c0c0',
	skyXe: '87ceeb',
	UXe: '6a5acd',
	UWay: '708090',
	UgYy: '708090',
	snow: 'fffafa',
	sprRggYF: 'ff7f',
	stAlXe: '4682b4',
	tan: 'd2b48c',
	teO: '8080',
	tEstN: 'd8bfd8',
	tomato: 'ff6347',
	Qe: '40e0d0',
	viTet: 'ee82ee',
	JHt: 'f5deb3',
	wEte: 'ffffff',
	wEtesmoke: 'f5f5f5',
	Lw: 'ffff00',
	LwgYF: '9acd32'
};
function unpack() {
	const unpacked = {};
	const keys = Object.keys(names);
	const tkeys = Object.keys(map$1);
	let i, j, k, ok, nk;
	for (i = 0; i < keys.length; i++) {
		ok = nk = keys[i];
		for (j = 0; j < tkeys.length; j++) {
			k = tkeys[j];
			nk = nk.replace(k, map$1[k]);
		}
		k = parseInt(names[ok], 16);
		unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];
	}
	return unpacked;
}
let names$1;
function nameParse(str) {
	if (!names$1) {
		names$1 = unpack();
		names$1.transparent = [0, 0, 0, 0];
	}
	const a = names$1[str.toLowerCase()];
	return a && {
		r: a[0],
		g: a[1],
		b: a[2],
		a: a.length === 4 ? a[3] : 255
	};
}
function modHSL(v, i, ratio) {
	if (v) {
		let tmp = rgb2hsl(v);
		tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
		tmp = hsl2rgb(tmp);
		v.r = tmp[0];
		v.g = tmp[1];
		v.b = tmp[2];
	}
}
function clone(v, proto) {
	return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
	var v = {r: 0, g: 0, b: 0, a: 255};
	if (Array.isArray(input)) {
		if (input.length >= 3) {
			v = {r: input[0], g: input[1], b: input[2], a: 255};
			if (input.length > 3) {
				v.a = n2b(input[3]);
			}
		}
	} else {
		v = clone(input, {r: 0, g: 0, b: 0, a: 1});
		v.a = n2b(v.a);
	}
	return v;
}
function functionParse(str) {
	if (str.charAt(0) === 'r') {
		return rgbParse(str);
	}
	return hueParse(str);
}
class Color {
	constructor(input) {
		if (input instanceof Color) {
			return input;
		}
		const type = typeof input;
		let v;
		if (type === 'object') {
			v = fromObject(input);
		} else if (type === 'string') {
			v = hexParse(input) || nameParse(input) || functionParse(input);
		}
		this._rgb = v;
		this._valid = !!v;
	}
	get valid() {
		return this._valid;
	}
	get rgb() {
		var v = clone(this._rgb);
		if (v) {
			v.a = b2n(v.a);
		}
		return v;
	}
	set rgb(obj) {
		this._rgb = fromObject(obj);
	}
	rgbString() {
		return this._valid ? rgbString(this._rgb) : this._rgb;
	}
	hexString() {
		return this._valid ? hexString(this._rgb) : this._rgb;
	}
	hslString() {
		return this._valid ? hslString(this._rgb) : this._rgb;
	}
	mix(color, weight) {
		const me = this;
		if (color) {
			const c1 = me.rgb;
			const c2 = color.rgb;
			let w2;
			const p = weight === w2 ? 0.5 : weight;
			const w = 2 * p - 1;
			const a = c1.a - c2.a;
			const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
			w2 = 1 - w1;
			c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;
			c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;
			c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;
			c1.a = p * c1.a + (1 - p) * c2.a;
			me.rgb = c1;
		}
		return me;
	}
	clone() {
		return new Color(this.rgb);
	}
	alpha(a) {
		this._rgb.a = n2b(a);
		return this;
	}
	clearer(ratio) {
		const rgb = this._rgb;
		rgb.a *= 1 - ratio;
		return this;
	}
	greyscale() {
		const rgb = this._rgb;
		const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
		rgb.r = rgb.g = rgb.b = val;
		return this;
	}
	opaquer(ratio) {
		const rgb = this._rgb;
		rgb.a *= 1 + ratio;
		return this;
	}
	negate() {
		const v = this._rgb;
		v.r = 255 - v.r;
		v.g = 255 - v.g;
		v.b = 255 - v.b;
		return this;
	}
	lighten(ratio) {
		modHSL(this._rgb, 2, ratio);
		return this;
	}
	darken(ratio) {
		modHSL(this._rgb, 2, -ratio);
		return this;
	}
	saturate(ratio) {
		modHSL(this._rgb, 1, ratio);
		return this;
	}
	desaturate(ratio) {
		modHSL(this._rgb, 1, -ratio);
		return this;
	}
	rotate(deg) {
		rotate(this._rgb, deg);
		return this;
	}
}
function index_esm(input) {
	return new Color(input);
}

const isPatternOrGradient = (value) => value instanceof CanvasGradient || value instanceof CanvasPattern;
function color(value) {
  return isPatternOrGradient(value) ? value : index_esm(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value)
    ? value
    : index_esm(value).saturate(0.5).darken(0.1).hexString();
}

const overrides = Object.create(null);
const descriptors = Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split('.');
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === 'string') {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ''), scope);
}
class Defaults {
  constructor(_descriptors) {
    this.animation = undefined;
    this.backgroundColor = 'rgba(0,0,0,0.1)';
    this.borderColor = 'rgba(0,0,0,0.1)';
    this.color = '#666';
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      'mousemove',
      'mouseout',
      'click',
      'touchstart',
      'touchmove'
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: 'normal',
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = 'x';
    this.interaction = {
      mode: 'nearest',
      intersect: true
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = undefined;
    this.scales = {};
    this.showLine = true;
    this.describe(_descriptors);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = '_' + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
}
var defaults = new Defaults({
  _scriptable: (name) => !name.startsWith('on'),
  _indexable: (name) => name !== 'events',
  hover: {
    _fallback: 'interaction'
  },
  interaction: {
    _scriptable: false,
    _indexable: false,
  }
});

function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + ' ' : '')
		+ (font.weight ? font.weight + ' ' : '')
		+ font.size + 'px '
		+ font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== undefined && thing !== null && isArray(thing) !== true) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext('2d');
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x, y) {
  let type, xOffset, yOffset, size, cornerRadius;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === 'object') {
    type = style.toString();
    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
  default:
    ctx.arc(x, y, radius, 0, TAU);
    ctx.closePath();
    break;
  case 'triangle':
    ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
    rad += TWO_THIRDS_PI;
    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
    rad += TWO_THIRDS_PI;
    ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
    ctx.closePath();
    break;
  case 'rectRounded':
    cornerRadius = radius * 0.516;
    size = radius - cornerRadius;
    xOffset = Math.cos(rad + QUARTER_PI) * size;
    yOffset = Math.sin(rad + QUARTER_PI) * size;
    ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
    ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
    ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
    ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
    ctx.closePath();
    break;
  case 'rect':
    if (!rotation) {
      size = Math.SQRT1_2 * radius;
      ctx.rect(x - size, y - size, 2 * size, 2 * size);
      break;
    }
    rad += QUARTER_PI;
  case 'rectRot':
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + yOffset, y - xOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    ctx.lineTo(x - yOffset, y + xOffset);
    ctx.closePath();
    break;
  case 'crossRot':
    rad += QUARTER_PI;
  case 'cross':
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    ctx.moveTo(x + yOffset, y - xOffset);
    ctx.lineTo(x - yOffset, y + xOffset);
    break;
  case 'star':
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    ctx.moveTo(x + yOffset, y - xOffset);
    ctx.lineTo(x - yOffset, y + xOffset);
    rad += QUARTER_PI;
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    ctx.moveTo(x + yOffset, y - xOffset);
    ctx.lineTo(x - yOffset, y + xOffset);
    break;
  case 'line':
    xOffset = Math.cos(rad) * radius;
    yOffset = Math.sin(rad) * radius;
    ctx.moveTo(x - xOffset, y - yOffset);
    ctx.lineTo(x + xOffset, y + yOffset);
    break;
  case 'dash':
    ctx.moveTo(x, y);
    ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
    break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&
		point.y > area.top - margin && point.y < area.bottom + margin);
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === 'middle') {
    const midpoint = (previous.x + target.x) / 2.0;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === 'after' !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(
    flip ? previous.cp1x : previous.cp2x,
    flip ? previous.cp1y : previous.cp2y,
    flip ? target.cp2x : target.cp1x,
    flip ? target.cp2y : target.cp1y,
    target.x,
    target.y);
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [text];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += font.lineHeight;
  }
  ctx.restore();
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function addRoundedRectPath(ctx, rect) {
  const {x, y, w, h, radius} = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}

const LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
const FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
function toLineHeight(value, size) {
  const matches = ('' + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === 'normal') {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
  case 'px':
    return value;
  case '%':
    value /= 100;
    break;
  }
  return size * value;
}
const numberOrZero = v => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value)
    ? objProps
      ? prop => valueOrDefault(value[prop], value[props[prop]])
      : prop => value[prop]
    : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});
}
function toTRBLCorners(value) {
  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === 'string') {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !('' + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = '';
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ''
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === undefined) {
      continue;
    }
    if (context !== undefined && typeof value === 'function') {
      value = value(context);
      cacheable = false;
    }
    if (index !== undefined && isArray(value)) {
      value = value[index % value.length];
      cacheable = false;
    }
    if (value !== undefined) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace) {
  const {min, max} = minmax;
  return {
    min: min - Math.abs(toDimension(grace, min)),
    max: max + toDimension(grace, max)
  };
}

function _lookup(table, value, cmp) {
  cmp = cmp || ((index) => table[index] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = (lo + hi) >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {lo, hi};
}
const _lookupByKey = (table, key, value) =>
  _lookup(table, value, index => table[index][key] < value);
const _rlookupByKey = (table, key, value) =>
  _lookup(table, value, index => table[index][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length
    ? values.slice(start, end)
    : values;
}
const arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, '_chartjs', {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [listener]
    }
  });
  arrayEvents.forEach((key) => {
    const method = '_onData' + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === 'function') {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index = listeners.indexOf(listener);
  if (index !== -1) {
    listeners.splice(index, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set = new Set();
  let i, ilen;
  for (i = 0, ilen = items.length; i < ilen; ++i) {
    set.add(items[i]);
  }
  if (set.size === ilen) {
    return items;
  }
  return Array.from(set);
}

function _createResolver(scopes, prefixes = [''], rootScopes = scopes, fallback, getTarget = () => scopes[0]) {
  if (!defined(fallback)) {
    fallback = _resolve('_fallback', scopes);
  }
  const cache = {
    [Symbol.toStringTag]: 'Object',
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: rootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback),
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    get(target, prop) {
      return _cached(target, prop,
        () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      storage[prop] = value;
      delete target[prop];
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    get(target, prop, receiver) {
      return _cached(target, prop,
        () => _resolveWithContext(target, prop, receiver));
    },
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys
        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined
        : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults = {scriptable: true, indexable: true}) {
  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
const needsSubResolver = (prop, value) => isObject(value) && prop !== 'adapters';
function _cached(target, prop, resolve) {
  let value = target[prop];
  if (defined(value)) {
    return value;
  }
  value = resolve();
  if (defined(value)) {
    target[prop] = value;
  }
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
  }
  return value;
}
function _resolveScriptable(prop, value, target, receiver) {
  const {_proxy, _context, _subProxy, _stack} = target;
  if (_stack.has(prop)) {
    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);
  }
  _stack.add(prop);
  value = value(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (isObject(value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;
  if (defined(_context.index) && isIndexable(prop)) {
    value = value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter(s => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
const getScope = (key, parent) => key === true ? parent
  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;
function addScopes(set, parentScopes, key, parentFallback) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set.add(scope);
      const fallback = resolveFallback(scope._fallback, key, scope);
      if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [...parentScopes, ...rootScopes];
  const set = new Set();
  set.add(value);
  let key = addScopesFromKey(set, allScopes, prop, fallback || prop);
  if (key === null) {
    return false;
  }
  if (defined(fallback) && fallback !== prop) {
    key = addScopesFromKey(set, allScopes, fallback, key);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set), [''], rootScopes, fallback,
    () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set, allScopes, key, fallback) {
  while (key) {
    key = addScopes(set, allScopes, key, fallback);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target;
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (defined(value)) {
      return needsSubResolver(prop, value)
        ? createSubResolver(scopes, proxy, prop, value)
        : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (defined(value)) {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set = new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {
      set.add(key);
    }
  }
  return Array.from(set);
}

const EPSILON = Number.EPSILON || 1e-14;
const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
const getValueAxis = (indexAxis) => indexAxis === 'x' ? 'y' : 'x';
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = 'x') {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = 'x') {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i]
      : !pointAfter ? deltaK[i - 1]
      : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0
      : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === 'monotone') {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(
        prev,
        point,
        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],
        options.tension
      );
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}

function _isDomSupported() {
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === '[object ShadowRoot]') {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === 'string') {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf('%') !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
const getComputedStyle = (element) => window.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle(el).getPropertyValue(property);
}
const positions = ['top', 'right', 'bottom', 'left'];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? '-' + suffix : '';
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(evt, canvas) {
  const e = evt.native || evt;
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const {offsetX, offsetY} = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return {x, y, box};
}
function getRelativePosition(evt, chart) {
  const {canvas, currentDevicePixelRatio} = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === 'border-box';
  const paddings = getPositionedStyle(style, 'padding');
  const borders = getPositionedStyle(style, 'border', 'width');
  const {x, y, box} = getCanvasPosition(evt, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let {width, height} = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === undefined || height === undefined) {
    const container = _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');
      const containerPadding = getPositionedStyle(containerStyle, 'padding');
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
const round1 = v => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, 'margin');
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let {width, height} = containerSize;
  if (style.boxSizing === 'content-box') {
    const borders = getPositionedStyle(style, 'border', 'width');
    const paddings = getPositionedStyle(style, 'padding');
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = deviceHeight / pixelRatio;
  chart.width = deviceWidth / pixelRatio;
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio
      || canvas.height !== deviceHeight
      || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
const supportsEventListenerOptions = (function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener('test', null, options);
    window.removeEventListener('test', null, options);
  } catch (e) {
  }
  return passiveSupported;
}());
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : undefined;
}

function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y
    : mode === 'after' ? t < 1 ? p1.y : p2.y
    : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = {x: p1.cp2x, y: p1.cp2y};
  const cp2 = {x: p2.cp1x, y: p2.cp1y};
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}

const intlCache = new Map();
function getNumberFormat(locale, options) {
  options = options || {};
  const cacheKey = locale + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options) {
  return getNumberFormat(locale, options).format(num);
}

const getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === 'center') {
        return align;
      }
      return align === 'right' ? 'left' : 'right';
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    },
  };
};
const getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    },
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === 'ltr' || direction === 'rtl') {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue('direction'),
      style.getPropertyPriority('direction'),
    ];
    style.setProperty('direction', direction, 'important');
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== undefined) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty('direction', original[0], original[1]);
  }
}

function propertyFn(property) {
  if (property === 'angle') {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle,
    };
  }
  return {
    between: (n, s, e) => n >= Math.min(s, e) && n <= Math.max(e, s),
    compare: (a, b) => a - b,
    normalize: x => x
  };
}
function normalizeSegment({start, end, count, loop, style}) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const {property, start: startBound, end: endBound} = bounds;
  const {between, normalize} = propertyFn(property);
  const count = points.length;
  let {start, end, loop} = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return {start, end, loop, style: segment.style};
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [segment];
  }
  const {property, start: startBound, end: endBound} = bounds;
  const count = points.length;
  const {compare, between, normalize} = propertyFn(property);
  const {start, end, loop, style} = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({start: subStart, end, loop, count, style}));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return {start, end};
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({start: start % count, end: (end - 1) % count, loop});
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({start: start % count, end: last % count, loop});
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const baseStyle = readStyle(line.options);
  const count = points.length;
  const result = [];
  let start = segments[0].start;
  let i = start;
  for (const segment of segments) {
    let prevStyle = baseStyle;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext({
        type: 'segment',
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex: line._datasetIndex
      }));
      if (styleChanged(style, prevStyle)) {
        result.push({start: start, end: i - 1, loop: segment.loop, style: prevStyle});
        prevStyle = style;
        start = i - 1;
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      result.push({start, end: i - 1, loop: segment.loop, style});
      start = i - 1;
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
}




/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/idb/build/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/idb/build/esm/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unwrap": () => (/* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.u),
/* harmony export */   "wrap": () => (/* reexport safe */ _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w),
/* harmony export */   "deleteDB": () => (/* binding */ deleteDB),
/* harmony export */   "openDB": () => (/* binding */ openDB)
/* harmony export */ });
/* harmony import */ var _wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrap-idb-value.js */ "./node_modules/idb/build/esm/wrap-idb-value.js");



/**
 * Open a database.
 *
 * @param name Name of the database.
 * @param version Schema version.
 * @param callbacks Additional callbacks.
 */
function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
    const request = indexedDB.open(name, version);
    const openPromise = (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request);
    if (upgrade) {
        request.addEventListener('upgradeneeded', (event) => {
            upgrade((0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.result), event.oldVersion, event.newVersion, (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request.transaction));
        });
    }
    if (blocked)
        request.addEventListener('blocked', () => blocked());
    openPromise
        .then((db) => {
        if (terminated)
            db.addEventListener('close', () => terminated());
        if (blocking)
            db.addEventListener('versionchange', () => blocking());
    })
        .catch(() => { });
    return openPromise;
}
/**
 * Delete a database.
 *
 * @param name Name of the database.
 */
function deleteDB(name, { blocked } = {}) {
    const request = indexedDB.deleteDatabase(name);
    if (blocked)
        request.addEventListener('blocked', () => blocked());
    return (0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.w)(request).then(() => undefined);
}

const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];
const writeMethods = ['put', 'add', 'delete', 'clear'];
const cachedMethods = new Map();
function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase &&
        !(prop in target) &&
        typeof prop === 'string')) {
        return;
    }
    if (cachedMethods.get(prop))
        return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, '');
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||
        !(isWrite || readMethods.includes(targetFuncName))) {
        return;
    }
    const method = async function (storeName, ...args) {
        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(
        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
        let target = tx.store;
        if (useIndex)
            target = target.index(args.shift());
        // Must reject if op rejects.
        // If it's a write operation, must reject if tx.done rejects.
        // Must reject with op rejection first.
        // Must resolve with op value.
        // Must handle both promises (no unhandled rejections)
        return (await Promise.all([
            target[targetFuncName](...args),
            isWrite && tx.done,
        ]))[0];
    };
    cachedMethods.set(prop, method);
    return method;
}
(0,_wrap_idb_value_js__WEBPACK_IMPORTED_MODULE_0__.r)((oldTraps) => ({
    ...oldTraps,
    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),
}));




/***/ }),

/***/ "./node_modules/idb/build/esm/wrap-idb-value.js":
/*!******************************************************!*\
  !*** ./node_modules/idb/build/esm/wrap-idb-value.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "a": () => (/* binding */ reverseTransformCache),
/* harmony export */   "i": () => (/* binding */ instanceOfAny),
/* harmony export */   "r": () => (/* binding */ replaceTraps),
/* harmony export */   "u": () => (/* binding */ unwrap),
/* harmony export */   "w": () => (/* binding */ wrap)
/* harmony export */ });
const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);

let idbProxyableTypes;
let cursorAdvanceMethods;
// This is a function to prevent it throwing up in node environments.
function getIdbProxyableTypes() {
    return (idbProxyableTypes ||
        (idbProxyableTypes = [
            IDBDatabase,
            IDBObjectStore,
            IDBIndex,
            IDBCursor,
            IDBTransaction,
        ]));
}
// This is a function to prevent it throwing up in node environments.
function getCursorAdvanceMethods() {
    return (cursorAdvanceMethods ||
        (cursorAdvanceMethods = [
            IDBCursor.prototype.advance,
            IDBCursor.prototype.continue,
            IDBCursor.prototype.continuePrimaryKey,
        ]));
}
const cursorRequestMap = new WeakMap();
const transactionDoneMap = new WeakMap();
const transactionStoreNamesMap = new WeakMap();
const transformCache = new WeakMap();
const reverseTransformCache = new WeakMap();
function promisifyRequest(request) {
    const promise = new Promise((resolve, reject) => {
        const unlisten = () => {
            request.removeEventListener('success', success);
            request.removeEventListener('error', error);
        };
        const success = () => {
            resolve(wrap(request.result));
            unlisten();
        };
        const error = () => {
            reject(request.error);
            unlisten();
        };
        request.addEventListener('success', success);
        request.addEventListener('error', error);
    });
    promise
        .then((value) => {
        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval
        // (see wrapFunction).
        if (value instanceof IDBCursor) {
            cursorRequestMap.set(value, request);
        }
        // Catching to avoid "Uncaught Promise exceptions"
    })
        .catch(() => { });
    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This
    // is because we create many promises from a single IDBRequest.
    reverseTransformCache.set(promise, request);
    return promise;
}
function cacheDonePromiseForTransaction(tx) {
    // Early bail if we've already created a done promise for this transaction.
    if (transactionDoneMap.has(tx))
        return;
    const done = new Promise((resolve, reject) => {
        const unlisten = () => {
            tx.removeEventListener('complete', complete);
            tx.removeEventListener('error', error);
            tx.removeEventListener('abort', error);
        };
        const complete = () => {
            resolve();
            unlisten();
        };
        const error = () => {
            reject(tx.error || new DOMException('AbortError', 'AbortError'));
            unlisten();
        };
        tx.addEventListener('complete', complete);
        tx.addEventListener('error', error);
        tx.addEventListener('abort', error);
    });
    // Cache it for later retrieval.
    transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
    get(target, prop, receiver) {
        if (target instanceof IDBTransaction) {
            // Special handling for transaction.done.
            if (prop === 'done')
                return transactionDoneMap.get(target);
            // Polyfill for objectStoreNames because of Edge.
            if (prop === 'objectStoreNames') {
                return target.objectStoreNames || transactionStoreNamesMap.get(target);
            }
            // Make tx.store return the only store in the transaction, or undefined if there are many.
            if (prop === 'store') {
                return receiver.objectStoreNames[1]
                    ? undefined
                    : receiver.objectStore(receiver.objectStoreNames[0]);
            }
        }
        // Else transform whatever we get back.
        return wrap(target[prop]);
    },
    set(target, prop, value) {
        target[prop] = value;
        return true;
    },
    has(target, prop) {
        if (target instanceof IDBTransaction &&
            (prop === 'done' || prop === 'store')) {
            return true;
        }
        return prop in target;
    },
};
function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
    // Due to expected object equality (which is enforced by the caching in `wrap`), we
    // only create one new func per func.
    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.
    if (func === IDBDatabase.prototype.transaction &&
        !('objectStoreNames' in IDBTransaction.prototype)) {
        return function (storeNames, ...args) {
            const tx = func.call(unwrap(this), storeNames, ...args);
            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
            return wrap(tx);
        };
    }
    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In
    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the
    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense
    // with real promises, so each advance methods returns a new promise for the cursor object, or
    // undefined if the end of the cursor has been reached.
    if (getCursorAdvanceMethods().includes(func)) {
        return function (...args) {
            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
            // the original object.
            func.apply(unwrap(this), args);
            return wrap(cursorRequestMap.get(this));
        };
    }
    return function (...args) {
        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
        // the original object.
        return wrap(func.apply(unwrap(this), args));
    };
}
function transformCachableValue(value) {
    if (typeof value === 'function')
        return wrapFunction(value);
    // This doesn't return, it just creates a 'done' promise for the transaction,
    // which is later returned for transaction.done (see idbObjectHandler).
    if (value instanceof IDBTransaction)
        cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
        return new Proxy(value, idbProxyTraps);
    // Return the same value back if we're not going to transform it.
    return value;
}
function wrap(value) {
    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because
    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.
    if (value instanceof IDBRequest)
        return promisifyRequest(value);
    // If we've already transformed this value before, reuse the transformed value.
    // This is faster, but it also provides object equality.
    if (transformCache.has(value))
        return transformCache.get(value);
    const newValue = transformCachableValue(value);
    // Not all types are transformed.
    // These may be primitive types, so they can't be WeakMap keys.
    if (newValue !== value) {
        transformCache.set(value, newValue);
        reverseTransformCache.set(newValue, value);
    }
    return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);




/***/ }),

/***/ "./node_modules/moment/locale/af.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/af.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Afrikaans [af]
//! author : Werner Mollentze : https://github.com/wernerm

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var af = moment.defineLocale('af', {
        months: 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
        weekdays: 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split(
            '_'
        ),
        weekdaysShort: 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
        weekdaysMin: 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
        meridiemParse: /vm|nm/i,
        isPM: function (input) {
            return /^nm$/i.test(input);
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'vm' : 'VM';
            } else {
                return isLower ? 'nm' : 'NM';
            }
        },
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Vandag om] LT',
            nextDay: '[Môre om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[Gister om] LT',
            lastWeek: '[Laas] dddd [om] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'oor %s',
            past: '%s gelede',
            s: "'n paar sekondes",
            ss: '%d sekondes',
            m: "'n minuut",
            mm: '%d minute',
            h: "'n uur",
            hh: '%d ure',
            d: "'n dag",
            dd: '%d dae',
            M: "'n maand",
            MM: '%d maande',
            y: "'n jaar",
            yy: '%d jaar',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function (number) {
            return (
                number +
                (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
            ); // Thanks to Joris Röling : https://github.com/jjupiter
        },
        week: {
            dow: 1, // Maandag is die eerste dag van die week.
            doy: 4, // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
        },
    });

    return af;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-dz.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-dz.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Algeria) [ar-dz]
//! author : Amine Roukh: https://github.com/Amine27
//! author : Abdel Said: https://github.com/abdelsaid
//! author : Ahmed Elkhatib
//! author : forabi https://github.com/forabi
//! author : Noureddine LOUAHEDJ : https://github.com/noureddinem

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var pluralForm = function (n) {
            return n === 0
                ? 0
                : n === 1
                ? 1
                : n === 2
                ? 2
                : n % 100 >= 3 && n % 100 <= 10
                ? 3
                : n % 100 >= 11
                ? 4
                : 5;
        },
        plurals = {
            s: [
                'أقل من ثانية',
                'ثانية واحدة',
                ['ثانيتان', 'ثانيتين'],
                '%d ثوان',
                '%d ثانية',
                '%d ثانية',
            ],
            m: [
                'أقل من دقيقة',
                'دقيقة واحدة',
                ['دقيقتان', 'دقيقتين'],
                '%d دقائق',
                '%d دقيقة',
                '%d دقيقة',
            ],
            h: [
                'أقل من ساعة',
                'ساعة واحدة',
                ['ساعتان', 'ساعتين'],
                '%d ساعات',
                '%d ساعة',
                '%d ساعة',
            ],
            d: [
                'أقل من يوم',
                'يوم واحد',
                ['يومان', 'يومين'],
                '%d أيام',
                '%d يومًا',
                '%d يوم',
            ],
            M: [
                'أقل من شهر',
                'شهر واحد',
                ['شهران', 'شهرين'],
                '%d أشهر',
                '%d شهرا',
                '%d شهر',
            ],
            y: [
                'أقل من عام',
                'عام واحد',
                ['عامان', 'عامين'],
                '%d أعوام',
                '%d عامًا',
                '%d عام',
            ],
        },
        pluralize = function (u) {
            return function (number, withoutSuffix, string, isFuture) {
                var f = pluralForm(number),
                    str = plurals[u][pluralForm(number)];
                if (f === 2) {
                    str = str[withoutSuffix ? 0 : 1];
                }
                return str.replace(/%d/i, number);
            };
        },
        months = [
            'جانفي',
            'فيفري',
            'مارس',
            'أفريل',
            'ماي',
            'جوان',
            'جويلية',
            'أوت',
            'سبتمبر',
            'أكتوبر',
            'نوفمبر',
            'ديسمبر',
        ];

    var arDz = moment.defineLocale('ar-dz', {
        months: months,
        monthsShort: months,
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'D/\u200FM/\u200FYYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        meridiemParse: /ص|م/,
        isPM: function (input) {
            return 'م' === input;
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ص';
            } else {
                return 'م';
            }
        },
        calendar: {
            sameDay: '[اليوم عند الساعة] LT',
            nextDay: '[غدًا عند الساعة] LT',
            nextWeek: 'dddd [عند الساعة] LT',
            lastDay: '[أمس عند الساعة] LT',
            lastWeek: 'dddd [عند الساعة] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'بعد %s',
            past: 'منذ %s',
            s: pluralize('s'),
            ss: pluralize('s'),
            m: pluralize('m'),
            mm: pluralize('m'),
            h: pluralize('h'),
            hh: pluralize('h'),
            d: pluralize('d'),
            dd: pluralize('d'),
            M: pluralize('M'),
            MM: pluralize('M'),
            y: pluralize('y'),
            yy: pluralize('y'),
        },
        postformat: function (string) {
            return string.replace(/,/g, '،');
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return arDz;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-kw.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-kw.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Kuwait) [ar-kw]
//! author : Nusret Parlak: https://github.com/nusretparlak

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var arKw = moment.defineLocale('ar-kw', {
        months: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split(
            '_'
        ),
        monthsShort: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split(
            '_'
        ),
        weekdays: 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'في %s',
            past: 'منذ %s',
            s: 'ثوان',
            ss: '%d ثانية',
            m: 'دقيقة',
            mm: '%d دقائق',
            h: 'ساعة',
            hh: '%d ساعات',
            d: 'يوم',
            dd: '%d أيام',
            M: 'شهر',
            MM: '%d أشهر',
            y: 'سنة',
            yy: '%d سنوات',
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 12, // The week that contains Jan 12th is the first week of the year.
        },
    });

    return arKw;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-ly.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-ly.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Lybia) [ar-ly]
//! author : Ali Hmer: https://github.com/kikoanis

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            1: '1',
            2: '2',
            3: '3',
            4: '4',
            5: '5',
            6: '6',
            7: '7',
            8: '8',
            9: '9',
            0: '0',
        },
        pluralForm = function (n) {
            return n === 0
                ? 0
                : n === 1
                ? 1
                : n === 2
                ? 2
                : n % 100 >= 3 && n % 100 <= 10
                ? 3
                : n % 100 >= 11
                ? 4
                : 5;
        },
        plurals = {
            s: [
                'أقل من ثانية',
                'ثانية واحدة',
                ['ثانيتان', 'ثانيتين'],
                '%d ثوان',
                '%d ثانية',
                '%d ثانية',
            ],
            m: [
                'أقل من دقيقة',
                'دقيقة واحدة',
                ['دقيقتان', 'دقيقتين'],
                '%d دقائق',
                '%d دقيقة',
                '%d دقيقة',
            ],
            h: [
                'أقل من ساعة',
                'ساعة واحدة',
                ['ساعتان', 'ساعتين'],
                '%d ساعات',
                '%d ساعة',
                '%d ساعة',
            ],
            d: [
                'أقل من يوم',
                'يوم واحد',
                ['يومان', 'يومين'],
                '%d أيام',
                '%d يومًا',
                '%d يوم',
            ],
            M: [
                'أقل من شهر',
                'شهر واحد',
                ['شهران', 'شهرين'],
                '%d أشهر',
                '%d شهرا',
                '%d شهر',
            ],
            y: [
                'أقل من عام',
                'عام واحد',
                ['عامان', 'عامين'],
                '%d أعوام',
                '%d عامًا',
                '%d عام',
            ],
        },
        pluralize = function (u) {
            return function (number, withoutSuffix, string, isFuture) {
                var f = pluralForm(number),
                    str = plurals[u][pluralForm(number)];
                if (f === 2) {
                    str = str[withoutSuffix ? 0 : 1];
                }
                return str.replace(/%d/i, number);
            };
        },
        months = [
            'يناير',
            'فبراير',
            'مارس',
            'أبريل',
            'مايو',
            'يونيو',
            'يوليو',
            'أغسطس',
            'سبتمبر',
            'أكتوبر',
            'نوفمبر',
            'ديسمبر',
        ];

    var arLy = moment.defineLocale('ar-ly', {
        months: months,
        monthsShort: months,
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'D/\u200FM/\u200FYYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        meridiemParse: /ص|م/,
        isPM: function (input) {
            return 'م' === input;
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ص';
            } else {
                return 'م';
            }
        },
        calendar: {
            sameDay: '[اليوم عند الساعة] LT',
            nextDay: '[غدًا عند الساعة] LT',
            nextWeek: 'dddd [عند الساعة] LT',
            lastDay: '[أمس عند الساعة] LT',
            lastWeek: 'dddd [عند الساعة] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'بعد %s',
            past: 'منذ %s',
            s: pluralize('s'),
            ss: pluralize('s'),
            m: pluralize('m'),
            mm: pluralize('m'),
            h: pluralize('h'),
            hh: pluralize('h'),
            d: pluralize('d'),
            dd: pluralize('d'),
            M: pluralize('M'),
            MM: pluralize('M'),
            y: pluralize('y'),
            yy: pluralize('y'),
        },
        preparse: function (string) {
            return string.replace(/،/g, ',');
        },
        postformat: function (string) {
            return string
                .replace(/\d/g, function (match) {
                    return symbolMap[match];
                })
                .replace(/,/g, '،');
        },
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12, // The week that contains Jan 12th is the first week of the year.
        },
    });

    return arLy;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-ma.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-ma.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Morocco) [ar-ma]
//! author : ElFadili Yassine : https://github.com/ElFadiliY
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var arMa = moment.defineLocale('ar-ma', {
        months: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split(
            '_'
        ),
        monthsShort: 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split(
            '_'
        ),
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'في %s',
            past: 'منذ %s',
            s: 'ثوان',
            ss: '%d ثانية',
            m: 'دقيقة',
            mm: '%d دقائق',
            h: 'ساعة',
            hh: '%d ساعات',
            d: 'يوم',
            dd: '%d أيام',
            M: 'شهر',
            MM: '%d أشهر',
            y: 'سنة',
            yy: '%d سنوات',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return arMa;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-sa.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-sa.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Saudi Arabia) [ar-sa]
//! author : Suhail Alkowaileet : https://github.com/xsoh

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            1: '١',
            2: '٢',
            3: '٣',
            4: '٤',
            5: '٥',
            6: '٦',
            7: '٧',
            8: '٨',
            9: '٩',
            0: '٠',
        },
        numberMap = {
            '١': '1',
            '٢': '2',
            '٣': '3',
            '٤': '4',
            '٥': '5',
            '٦': '6',
            '٧': '7',
            '٨': '8',
            '٩': '9',
            '٠': '0',
        };

    var arSa = moment.defineLocale('ar-sa', {
        months: 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split(
            '_'
        ),
        monthsShort: 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split(
            '_'
        ),
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        meridiemParse: /ص|م/,
        isPM: function (input) {
            return 'م' === input;
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ص';
            } else {
                return 'م';
            }
        },
        calendar: {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'في %s',
            past: 'منذ %s',
            s: 'ثوان',
            ss: '%d ثانية',
            m: 'دقيقة',
            mm: '%d دقائق',
            h: 'ساعة',
            hh: '%d ساعات',
            d: 'يوم',
            dd: '%d أيام',
            M: 'شهر',
            MM: '%d أشهر',
            y: 'سنة',
            yy: '%d سنوات',
        },
        preparse: function (string) {
            return string
                .replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                    return numberMap[match];
                })
                .replace(/،/g, ',');
        },
        postformat: function (string) {
            return string
                .replace(/\d/g, function (match) {
                    return symbolMap[match];
                })
                .replace(/,/g, '،');
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return arSa;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar-tn.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ar-tn.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale  :  Arabic (Tunisia) [ar-tn]
//! author : Nader Toukabri : https://github.com/naderio

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var arTn = moment.defineLocale('ar-tn', {
        months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split(
            '_'
        ),
        monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split(
            '_'
        ),
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[اليوم على الساعة] LT',
            nextDay: '[غدا على الساعة] LT',
            nextWeek: 'dddd [على الساعة] LT',
            lastDay: '[أمس على الساعة] LT',
            lastWeek: 'dddd [على الساعة] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'في %s',
            past: 'منذ %s',
            s: 'ثوان',
            ss: '%d ثانية',
            m: 'دقيقة',
            mm: '%d دقائق',
            h: 'ساعة',
            hh: '%d ساعات',
            d: 'يوم',
            dd: '%d أيام',
            M: 'شهر',
            MM: '%d أشهر',
            y: 'سنة',
            yy: '%d سنوات',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return arTn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ar.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ar.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic [ar]
//! author : Abdel Said: https://github.com/abdelsaid
//! author : Ahmed Elkhatib
//! author : forabi https://github.com/forabi

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            1: '١',
            2: '٢',
            3: '٣',
            4: '٤',
            5: '٥',
            6: '٦',
            7: '٧',
            8: '٨',
            9: '٩',
            0: '٠',
        },
        numberMap = {
            '١': '1',
            '٢': '2',
            '٣': '3',
            '٤': '4',
            '٥': '5',
            '٦': '6',
            '٧': '7',
            '٨': '8',
            '٩': '9',
            '٠': '0',
        },
        pluralForm = function (n) {
            return n === 0
                ? 0
                : n === 1
                ? 1
                : n === 2
                ? 2
                : n % 100 >= 3 && n % 100 <= 10
                ? 3
                : n % 100 >= 11
                ? 4
                : 5;
        },
        plurals = {
            s: [
                'أقل من ثانية',
                'ثانية واحدة',
                ['ثانيتان', 'ثانيتين'],
                '%d ثوان',
                '%d ثانية',
                '%d ثانية',
            ],
            m: [
                'أقل من دقيقة',
                'دقيقة واحدة',
                ['دقيقتان', 'دقيقتين'],
                '%d دقائق',
                '%d دقيقة',
                '%d دقيقة',
            ],
            h: [
                'أقل من ساعة',
                'ساعة واحدة',
                ['ساعتان', 'ساعتين'],
                '%d ساعات',
                '%d ساعة',
                '%d ساعة',
            ],
            d: [
                'أقل من يوم',
                'يوم واحد',
                ['يومان', 'يومين'],
                '%d أيام',
                '%d يومًا',
                '%d يوم',
            ],
            M: [
                'أقل من شهر',
                'شهر واحد',
                ['شهران', 'شهرين'],
                '%d أشهر',
                '%d شهرا',
                '%d شهر',
            ],
            y: [
                'أقل من عام',
                'عام واحد',
                ['عامان', 'عامين'],
                '%d أعوام',
                '%d عامًا',
                '%d عام',
            ],
        },
        pluralize = function (u) {
            return function (number, withoutSuffix, string, isFuture) {
                var f = pluralForm(number),
                    str = plurals[u][pluralForm(number)];
                if (f === 2) {
                    str = str[withoutSuffix ? 0 : 1];
                }
                return str.replace(/%d/i, number);
            };
        },
        months = [
            'يناير',
            'فبراير',
            'مارس',
            'أبريل',
            'مايو',
            'يونيو',
            'يوليو',
            'أغسطس',
            'سبتمبر',
            'أكتوبر',
            'نوفمبر',
            'ديسمبر',
        ];

    var ar = moment.defineLocale('ar', {
        months: months,
        monthsShort: months,
        weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
        weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
        weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'D/\u200FM/\u200FYYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        meridiemParse: /ص|م/,
        isPM: function (input) {
            return 'م' === input;
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ص';
            } else {
                return 'م';
            }
        },
        calendar: {
            sameDay: '[اليوم عند الساعة] LT',
            nextDay: '[غدًا عند الساعة] LT',
            nextWeek: 'dddd [عند الساعة] LT',
            lastDay: '[أمس عند الساعة] LT',
            lastWeek: 'dddd [عند الساعة] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'بعد %s',
            past: 'منذ %s',
            s: pluralize('s'),
            ss: pluralize('s'),
            m: pluralize('m'),
            mm: pluralize('m'),
            h: pluralize('h'),
            hh: pluralize('h'),
            d: pluralize('d'),
            dd: pluralize('d'),
            M: pluralize('M'),
            MM: pluralize('M'),
            y: pluralize('y'),
            yy: pluralize('y'),
        },
        preparse: function (string) {
            return string
                .replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                    return numberMap[match];
                })
                .replace(/،/g, ',');
        },
        postformat: function (string) {
            return string
                .replace(/\d/g, function (match) {
                    return symbolMap[match];
                })
                .replace(/,/g, '،');
        },
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12, // The week that contains Jan 12th is the first week of the year.
        },
    });

    return ar;

})));


/***/ }),

/***/ "./node_modules/moment/locale/az.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/az.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Azerbaijani [az]
//! author : topchiyev : https://github.com/topchiyev

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var suffixes = {
        1: '-inci',
        5: '-inci',
        8: '-inci',
        70: '-inci',
        80: '-inci',
        2: '-nci',
        7: '-nci',
        20: '-nci',
        50: '-nci',
        3: '-üncü',
        4: '-üncü',
        100: '-üncü',
        6: '-ncı',
        9: '-uncu',
        10: '-uncu',
        30: '-uncu',
        60: '-ıncı',
        90: '-ıncı',
    };

    var az = moment.defineLocale('az', {
        months: 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split(
            '_'
        ),
        monthsShort: 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
        weekdays: 'Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə'.split(
            '_'
        ),
        weekdaysShort: 'Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən'.split('_'),
        weekdaysMin: 'Bz_BE_ÇA_Çə_CA_Cü_Şə'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[bugün saat] LT',
            nextDay: '[sabah saat] LT',
            nextWeek: '[gələn həftə] dddd [saat] LT',
            lastDay: '[dünən] LT',
            lastWeek: '[keçən həftə] dddd [saat] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s sonra',
            past: '%s əvvəl',
            s: 'bir neçə saniyə',
            ss: '%d saniyə',
            m: 'bir dəqiqə',
            mm: '%d dəqiqə',
            h: 'bir saat',
            hh: '%d saat',
            d: 'bir gün',
            dd: '%d gün',
            M: 'bir ay',
            MM: '%d ay',
            y: 'bir il',
            yy: '%d il',
        },
        meridiemParse: /gecə|səhər|gündüz|axşam/,
        isPM: function (input) {
            return /^(gündüz|axşam)$/.test(input);
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'gecə';
            } else if (hour < 12) {
                return 'səhər';
            } else if (hour < 17) {
                return 'gündüz';
            } else {
                return 'axşam';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
        ordinal: function (number) {
            if (number === 0) {
                // special case for zero
                return number + '-ıncı';
            }
            var a = number % 10,
                b = (number % 100) - a,
                c = number >= 100 ? 100 : null;
            return number + (suffixes[a] || suffixes[b] || suffixes[c]);
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return az;

})));


/***/ }),

/***/ "./node_modules/moment/locale/be.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/be.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Belarusian [be]
//! author : Dmitry Demidov : https://github.com/demidov91
//! author: Praleska: http://praleska.pro/
//! Author : Menelion Elensúle : https://github.com/Oire

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11
            ? forms[0]
            : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
            ? forms[1]
            : forms[2];
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            ss: withoutSuffix ? 'секунда_секунды_секунд' : 'секунду_секунды_секунд',
            mm: withoutSuffix ? 'хвіліна_хвіліны_хвілін' : 'хвіліну_хвіліны_хвілін',
            hh: withoutSuffix ? 'гадзіна_гадзіны_гадзін' : 'гадзіну_гадзіны_гадзін',
            dd: 'дзень_дні_дзён',
            MM: 'месяц_месяцы_месяцаў',
            yy: 'год_гады_гадоў',
        };
        if (key === 'm') {
            return withoutSuffix ? 'хвіліна' : 'хвіліну';
        } else if (key === 'h') {
            return withoutSuffix ? 'гадзіна' : 'гадзіну';
        } else {
            return number + ' ' + plural(format[key], +number);
        }
    }

    var be = moment.defineLocale('be', {
        months: {
            format: 'студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня'.split(
                '_'
            ),
            standalone: 'студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань'.split(
                '_'
            ),
        },
        monthsShort: 'студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж'.split(
            '_'
        ),
        weekdays: {
            format: 'нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу'.split(
                '_'
            ),
            standalone: 'нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота'.split(
                '_'
            ),
            isFormat: /\[ ?[Ууў] ?(?:мінулую|наступную)? ?\] ?dddd/,
        },
        weekdaysShort: 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
        weekdaysMin: 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY г.',
            LLL: 'D MMMM YYYY г., HH:mm',
            LLLL: 'dddd, D MMMM YYYY г., HH:mm',
        },
        calendar: {
            sameDay: '[Сёння ў] LT',
            nextDay: '[Заўтра ў] LT',
            lastDay: '[Учора ў] LT',
            nextWeek: function () {
                return '[У] dddd [ў] LT';
            },
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 5:
                    case 6:
                        return '[У мінулую] dddd [ў] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[У мінулы] dddd [ў] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'праз %s',
            past: '%s таму',
            s: 'некалькі секунд',
            m: relativeTimeWithPlural,
            mm: relativeTimeWithPlural,
            h: relativeTimeWithPlural,
            hh: relativeTimeWithPlural,
            d: 'дзень',
            dd: relativeTimeWithPlural,
            M: 'месяц',
            MM: relativeTimeWithPlural,
            y: 'год',
            yy: relativeTimeWithPlural,
        },
        meridiemParse: /ночы|раніцы|дня|вечара/,
        isPM: function (input) {
            return /^(дня|вечара)$/.test(input);
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ночы';
            } else if (hour < 12) {
                return 'раніцы';
            } else if (hour < 17) {
                return 'дня';
            } else {
                return 'вечара';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(і|ы|га)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                case 'w':
                case 'W':
                    return (number % 10 === 2 || number % 10 === 3) &&
                        number % 100 !== 12 &&
                        number % 100 !== 13
                        ? number + '-і'
                        : number + '-ы';
                case 'D':
                    return number + '-га';
                default:
                    return number;
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return be;

})));


/***/ }),

/***/ "./node_modules/moment/locale/bg.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/bg.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bulgarian [bg]
//! author : Krasen Borisov : https://github.com/kraz

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var bg = moment.defineLocale('bg', {
        months: 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split(
            '_'
        ),
        monthsShort: 'яну_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
        weekdays: 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split(
            '_'
        ),
        weekdaysShort: 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
        weekdaysMin: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'D.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY H:mm',
            LLLL: 'dddd, D MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[Днес в] LT',
            nextDay: '[Утре в] LT',
            nextWeek: 'dddd [в] LT',
            lastDay: '[Вчера в] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 6:
                        return '[Миналата] dddd [в] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[Миналия] dddd [в] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'след %s',
            past: 'преди %s',
            s: 'няколко секунди',
            ss: '%d секунди',
            m: 'минута',
            mm: '%d минути',
            h: 'час',
            hh: '%d часа',
            d: 'ден',
            dd: '%d дена',
            w: 'седмица',
            ww: '%d седмици',
            M: 'месец',
            MM: '%d месеца',
            y: 'година',
            yy: '%d години',
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
        ordinal: function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-ев';
            } else if (last2Digits === 0) {
                return number + '-ен';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-ти';
            } else if (lastDigit === 1) {
                return number + '-ви';
            } else if (lastDigit === 2) {
                return number + '-ри';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-ми';
            } else {
                return number + '-ти';
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return bg;

})));


/***/ }),

/***/ "./node_modules/moment/locale/bm.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/bm.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bambara [bm]
//! author : Estelle Comment : https://github.com/estellecomment

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var bm = moment.defineLocale('bm', {
        months: 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mɛkalo_Zuwɛnkalo_Zuluyekalo_Utikalo_Sɛtanburukalo_ɔkutɔburukalo_Nowanburukalo_Desanburukalo'.split(
            '_'
        ),
        monthsShort: 'Zan_Few_Mar_Awi_Mɛ_Zuw_Zul_Uti_Sɛt_ɔku_Now_Des'.split('_'),
        weekdays: 'Kari_Ntɛnɛn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
        weekdaysShort: 'Kar_Ntɛ_Tar_Ara_Ala_Jum_Sib'.split('_'),
        weekdaysMin: 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'MMMM [tile] D [san] YYYY',
            LLL: 'MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm',
            LLLL: 'dddd MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm',
        },
        calendar: {
            sameDay: '[Bi lɛrɛ] LT',
            nextDay: '[Sini lɛrɛ] LT',
            nextWeek: 'dddd [don lɛrɛ] LT',
            lastDay: '[Kunu lɛrɛ] LT',
            lastWeek: 'dddd [tɛmɛnen lɛrɛ] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s kɔnɔ',
            past: 'a bɛ %s bɔ',
            s: 'sanga dama dama',
            ss: 'sekondi %d',
            m: 'miniti kelen',
            mm: 'miniti %d',
            h: 'lɛrɛ kelen',
            hh: 'lɛrɛ %d',
            d: 'tile kelen',
            dd: 'tile %d',
            M: 'kalo kelen',
            MM: 'kalo %d',
            y: 'san kelen',
            yy: 'san %d',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return bm;

})));


/***/ }),

/***/ "./node_modules/moment/locale/bn-bd.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/bn-bd.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bengali (Bangladesh) [bn-bd]
//! author : Asraf Hossain Patoary : https://github.com/ashwoolford

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            1: '১',
            2: '২',
            3: '৩',
            4: '৪',
            5: '৫',
            6: '৬',
            7: '৭',
            8: '৮',
            9: '৯',
            0: '০',
        },
        numberMap = {
            '১': '1',
            '২': '2',
            '৩': '3',
            '৪': '4',
            '৫': '5',
            '৬': '6',
            '৭': '7',
            '৮': '8',
            '৯': '9',
            '০': '0',
        };

    var bnBd = moment.defineLocale('bn-bd', {
        months: 'জানুয়ারি_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split(
            '_'
        ),
        monthsShort: 'জানু_ফেব্রু_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্ট_অক্টো_নভে_ডিসে'.split(
            '_'
        ),
        weekdays: 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার'.split(
            '_'
        ),
        weekdaysShort: 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি'.split('_'),
        weekdaysMin: 'রবি_সোম_মঙ্গল_বুধ_বৃহ_শুক্র_শনি'.split('_'),
        longDateFormat: {
            LT: 'A h:mm সময়',
            LTS: 'A h:mm:ss সময়',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm সময়',
            LLLL: 'dddd, D MMMM YYYY, A h:mm সময়',
        },
        calendar: {
            sameDay: '[আজ] LT',
            nextDay: '[আগামীকাল] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[গতকাল] LT',
            lastWeek: '[গত] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s পরে',
            past: '%s আগে',
            s: 'কয়েক সেকেন্ড',
            ss: '%d সেকেন্ড',
            m: 'এক মিনিট',
            mm: '%d মিনিট',
            h: 'এক ঘন্টা',
            hh: '%d ঘন্টা',
            d: 'এক দিন',
            dd: '%d দিন',
            M: 'এক মাস',
            MM: '%d মাস',
            y: 'এক বছর',
            yy: '%d বছর',
        },
        preparse: function (string) {
            return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },

        meridiemParse: /রাত|ভোর|সকাল|দুপুর|বিকাল|সন্ধ্যা|রাত/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'রাত') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'ভোর') {
                return hour;
            } else if (meridiem === 'সকাল') {
                return hour;
            } else if (meridiem === 'দুপুর') {
                return hour >= 3 ? hour : hour + 12;
            } else if (meridiem === 'বিকাল') {
                return hour + 12;
            } else if (meridiem === 'সন্ধ্যা') {
                return hour + 12;
            }
        },

        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'রাত';
            } else if (hour < 6) {
                return 'ভোর';
            } else if (hour < 12) {
                return 'সকাল';
            } else if (hour < 15) {
                return 'দুপুর';
            } else if (hour < 18) {
                return 'বিকাল';
            } else if (hour < 20) {
                return 'সন্ধ্যা';
            } else {
                return 'রাত';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return bnBd;

})));


/***/ }),

/***/ "./node_modules/moment/locale/bn.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/bn.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bengali [bn]
//! author : Kaushik Gandhi : https://github.com/kaushikgandhi

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            1: '১',
            2: '২',
            3: '৩',
            4: '৪',
            5: '৫',
            6: '৬',
            7: '৭',
            8: '৮',
            9: '৯',
            0: '০',
        },
        numberMap = {
            '১': '1',
            '২': '2',
            '৩': '3',
            '৪': '4',
            '৫': '5',
            '৬': '6',
            '৭': '7',
            '৮': '8',
            '৯': '9',
            '০': '0',
        };

    var bn = moment.defineLocale('bn', {
        months: 'জানুয়ারি_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split(
            '_'
        ),
        monthsShort: 'জানু_ফেব্রু_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্ট_অক্টো_নভে_ডিসে'.split(
            '_'
        ),
        weekdays: 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার'.split(
            '_'
        ),
        weekdaysShort: 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি'.split('_'),
        weekdaysMin: 'রবি_সোম_মঙ্গল_বুধ_বৃহ_শুক্র_শনি'.split('_'),
        longDateFormat: {
            LT: 'A h:mm সময়',
            LTS: 'A h:mm:ss সময়',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm সময়',
            LLLL: 'dddd, D MMMM YYYY, A h:mm সময়',
        },
        calendar: {
            sameDay: '[আজ] LT',
            nextDay: '[আগামীকাল] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[গতকাল] LT',
            lastWeek: '[গত] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s পরে',
            past: '%s আগে',
            s: 'কয়েক সেকেন্ড',
            ss: '%d সেকেন্ড',
            m: 'এক মিনিট',
            mm: '%d মিনিট',
            h: 'এক ঘন্টা',
            hh: '%d ঘন্টা',
            d: 'এক দিন',
            dd: '%d দিন',
            M: 'এক মাস',
            MM: '%d মাস',
            y: 'এক বছর',
            yy: '%d বছর',
        },
        preparse: function (string) {
            return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (
                (meridiem === 'রাত' && hour >= 4) ||
                (meridiem === 'দুপুর' && hour < 5) ||
                meridiem === 'বিকাল'
            ) {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'রাত';
            } else if (hour < 10) {
                return 'সকাল';
            } else if (hour < 17) {
                return 'দুপুর';
            } else if (hour < 20) {
                return 'বিকাল';
            } else {
                return 'রাত';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return bn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/bo.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/bo.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tibetan [bo]
//! author : Thupten N. Chakrishar : https://github.com/vajradog

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            1: '༡',
            2: '༢',
            3: '༣',
            4: '༤',
            5: '༥',
            6: '༦',
            7: '༧',
            8: '༨',
            9: '༩',
            0: '༠',
        },
        numberMap = {
            '༡': '1',
            '༢': '2',
            '༣': '3',
            '༤': '4',
            '༥': '5',
            '༦': '6',
            '༧': '7',
            '༨': '8',
            '༩': '9',
            '༠': '0',
        };

    var bo = moment.defineLocale('bo', {
        months: 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split(
            '_'
        ),
        monthsShort: 'ཟླ་1_ཟླ་2_ཟླ་3_ཟླ་4_ཟླ་5_ཟླ་6_ཟླ་7_ཟླ་8_ཟླ་9_ཟླ་10_ཟླ་11_ཟླ་12'.split(
            '_'
        ),
        monthsShortRegex: /^(ཟླ་\d{1,2})/,
        monthsParseExact: true,
        weekdays: 'གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་'.split(
            '_'
        ),
        weekdaysShort: 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split(
            '_'
        ),
        weekdaysMin: 'ཉི_ཟླ_མིག_ལྷག_ཕུར_སངས_སྤེན'.split('_'),
        longDateFormat: {
            LT: 'A h:mm',
            LTS: 'A h:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm',
            LLLL: 'dddd, D MMMM YYYY, A h:mm',
        },
        calendar: {
            sameDay: '[དི་རིང] LT',
            nextDay: '[སང་ཉིན] LT',
            nextWeek: '[བདུན་ཕྲག་རྗེས་མ], LT',
            lastDay: '[ཁ་སང] LT',
            lastWeek: '[བདུན་ཕྲག་མཐའ་མ] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s ལ་',
            past: '%s སྔན་ལ',
            s: 'ལམ་སང',
            ss: '%d སྐར་ཆ།',
            m: 'སྐར་མ་གཅིག',
            mm: '%d སྐར་མ',
            h: 'ཆུ་ཚོད་གཅིག',
            hh: '%d ཆུ་ཚོད',
            d: 'ཉིན་གཅིག',
            dd: '%d ཉིན་',
            M: 'ཟླ་བ་གཅིག',
            MM: '%d ཟླ་བ',
            y: 'ལོ་གཅིག',
            yy: '%d ལོ',
        },
        preparse: function (string) {
            return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (
                (meridiem === 'མཚན་མོ' && hour >= 4) ||
                (meridiem === 'ཉིན་གུང' && hour < 5) ||
                meridiem === 'དགོང་དག'
            ) {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'མཚན་མོ';
            } else if (hour < 10) {
                return 'ཞོགས་ཀས';
            } else if (hour < 17) {
                return 'ཉིན་གུང';
            } else if (hour < 20) {
                return 'དགོང་དག';
            } else {
                return 'མཚན་མོ';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return bo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/br.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/br.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Breton [br]
//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function relativeTimeWithMutation(number, withoutSuffix, key) {
        var format = {
            mm: 'munutenn',
            MM: 'miz',
            dd: 'devezh',
        };
        return number + ' ' + mutation(format[key], number);
    }
    function specialMutationForYears(number) {
        switch (lastNumber(number)) {
            case 1:
            case 3:
            case 4:
            case 5:
            case 9:
                return number + ' bloaz';
            default:
                return number + ' vloaz';
        }
    }
    function lastNumber(number) {
        if (number > 9) {
            return lastNumber(number % 10);
        }
        return number;
    }
    function mutation(text, number) {
        if (number === 2) {
            return softMutation(text);
        }
        return text;
    }
    function softMutation(text) {
        var mutationTable = {
            m: 'v',
            b: 'v',
            d: 'z',
        };
        if (mutationTable[text.charAt(0)] === undefined) {
            return text;
        }
        return mutationTable[text.charAt(0)] + text.substring(1);
    }

    var monthsParse = [
            /^gen/i,
            /^c[ʼ\']hwe/i,
            /^meu/i,
            /^ebr/i,
            /^mae/i,
            /^(mez|eve)/i,
            /^gou/i,
            /^eos/i,
            /^gwe/i,
            /^her/i,
            /^du/i,
            /^ker/i,
        ],
        monthsRegex = /^(genver|c[ʼ\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[ʼ\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
        monthsStrictRegex = /^(genver|c[ʼ\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i,
        monthsShortStrictRegex = /^(gen|c[ʼ\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
        fullWeekdaysParse = [
            /^sul/i,
            /^lun/i,
            /^meurzh/i,
            /^merc[ʼ\']her/i,
            /^yaou/i,
            /^gwener/i,
            /^sadorn/i,
        ],
        shortWeekdaysParse = [
            /^Sul/i,
            /^Lun/i,
            /^Meu/i,
            /^Mer/i,
            /^Yao/i,
            /^Gwe/i,
            /^Sad/i,
        ],
        minWeekdaysParse = [
            /^Su/i,
            /^Lu/i,
            /^Me([^r]|$)/i,
            /^Mer/i,
            /^Ya/i,
            /^Gw/i,
            /^Sa/i,
        ];

    var br = moment.defineLocale('br', {
        months: 'Genver_Cʼhwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split(
            '_'
        ),
        monthsShort: 'Gen_Cʼhwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
        weekdays: 'Sul_Lun_Meurzh_Mercʼher_Yaou_Gwener_Sadorn'.split('_'),
        weekdaysShort: 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
        weekdaysParse: minWeekdaysParse,
        fullWeekdaysParse: fullWeekdaysParse,
        shortWeekdaysParse: shortWeekdaysParse,
        minWeekdaysParse: minWeekdaysParse,

        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: monthsStrictRegex,
        monthsShortStrictRegex: monthsShortStrictRegex,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,

        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D [a viz] MMMM YYYY',
            LLL: 'D [a viz] MMMM YYYY HH:mm',
            LLLL: 'dddd, D [a viz] MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Hiziv da] LT',
            nextDay: '[Warcʼhoazh da] LT',
            nextWeek: 'dddd [da] LT',
            lastDay: '[Decʼh da] LT',
            lastWeek: 'dddd [paset da] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'a-benn %s',
            past: '%s ʼzo',
            s: 'un nebeud segondennoù',
            ss: '%d eilenn',
            m: 'ur vunutenn',
            mm: relativeTimeWithMutation,
            h: 'un eur',
            hh: '%d eur',
            d: 'un devezh',
            dd: relativeTimeWithMutation,
            M: 'ur miz',
            MM: relativeTimeWithMutation,
            y: 'ur bloaz',
            yy: specialMutationForYears,
        },
        dayOfMonthOrdinalParse: /\d{1,2}(añ|vet)/,
        ordinal: function (number) {
            var output = number === 1 ? 'añ' : 'vet';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
        meridiemParse: /a.m.|g.m./, // goude merenn | a-raok merenn
        isPM: function (token) {
            return token === 'g.m.';
        },
        meridiem: function (hour, minute, isLower) {
            return hour < 12 ? 'a.m.' : 'g.m.';
        },
    });

    return br;

})));


/***/ }),

/***/ "./node_modules/moment/locale/bs.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/bs.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bosnian [bs]
//! author : Nedim Cholich : https://github.com/frontyard
//! based on (hr) translation by Bojan Marković

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'ss':
                if (number === 1) {
                    result += 'sekunda';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sekunde';
                } else {
                    result += 'sekundi';
                }
                return result;
            case 'm':
                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
            case 'mm':
                if (number === 1) {
                    result += 'minuta';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'minute';
                } else {
                    result += 'minuta';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'jedan sat' : 'jednog sata';
            case 'hh':
                if (number === 1) {
                    result += 'sat';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sata';
                } else {
                    result += 'sati';
                }
                return result;
            case 'dd':
                if (number === 1) {
                    result += 'dan';
                } else {
                    result += 'dana';
                }
                return result;
            case 'MM':
                if (number === 1) {
                    result += 'mjesec';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'mjeseca';
                } else {
                    result += 'mjeseci';
                }
                return result;
            case 'yy':
                if (number === 1) {
                    result += 'godina';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'godine';
                } else {
                    result += 'godina';
                }
                return result;
        }
    }

    var bs = moment.defineLocale('bs', {
        months: 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split(
            '_'
        ),
        monthsShort: 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split(
            '_'
        ),
        weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay: '[jučer u] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                        return '[prošlu] dddd [u] LT';
                    case 6:
                        return '[prošle] [subote] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[prošli] dddd [u] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'za %s',
            past: 'prije %s',
            s: 'par sekundi',
            ss: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: 'dan',
            dd: translate,
            M: 'mjesec',
            MM: translate,
            y: 'godinu',
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return bs;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ca.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ca.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Catalan [ca]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ca = moment.defineLocale('ca', {
        months: {
            standalone: 'gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split(
                '_'
            ),
            format: "de gener_de febrer_de març_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split(
                '_'
            ),
            isFormat: /D[oD]?(\s)+MMMM/,
        },
        monthsShort: 'gen._febr._març_abr._maig_juny_jul._ag._set._oct._nov._des.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split(
            '_'
        ),
        weekdaysShort: 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
        weekdaysMin: 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM [de] YYYY',
            ll: 'D MMM YYYY',
            LLL: 'D MMMM [de] YYYY [a les] H:mm',
            lll: 'D MMM YYYY, H:mm',
            LLLL: 'dddd D MMMM [de] YYYY [a les] H:mm',
            llll: 'ddd D MMM YYYY, H:mm',
        },
        calendar: {
            sameDay: function () {
                return '[avui a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
            },
            nextDay: function () {
                return '[demà a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
            },
            nextWeek: function () {
                return 'dddd [a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
            },
            lastDay: function () {
                return '[ahir a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
            },
            lastWeek: function () {
                return (
                    '[el] dddd [passat a ' +
                    (this.hours() !== 1 ? 'les' : 'la') +
                    '] LT'
                );
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: "d'aquí %s",
            past: 'fa %s',
            s: 'uns segons',
            ss: '%d segons',
            m: 'un minut',
            mm: '%d minuts',
            h: 'una hora',
            hh: '%d hores',
            d: 'un dia',
            dd: '%d dies',
            M: 'un mes',
            MM: '%d mesos',
            y: 'un any',
            yy: '%d anys',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
        ordinal: function (number, period) {
            var output =
                number === 1
                    ? 'r'
                    : number === 2
                    ? 'n'
                    : number === 3
                    ? 'r'
                    : number === 4
                    ? 't'
                    : 'è';
            if (period === 'w' || period === 'W') {
                output = 'a';
            }
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return ca;

})));


/***/ }),

/***/ "./node_modules/moment/locale/cs.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/cs.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Czech [cs]
//! author : petrbela : https://github.com/petrbela

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var months = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split(
            '_'
        ),
        monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_'),
        monthsParse = [
            /^led/i,
            /^úno/i,
            /^bře/i,
            /^dub/i,
            /^kvě/i,
            /^(čvn|červen$|června)/i,
            /^(čvc|červenec|července)/i,
            /^srp/i,
            /^zář/i,
            /^říj/i,
            /^lis/i,
            /^pro/i,
        ],
        // NOTE: 'červen' is substring of 'červenec'; therefore 'červenec' must precede 'červen' in the regex to be fully matched.
        // Otherwise parser matches '1. červenec' as '1. červen' + 'ec'.
        monthsRegex = /^(leden|únor|březen|duben|květen|červenec|července|červen|června|srpen|září|říjen|listopad|prosinec|led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i;

    function plural(n) {
        return n > 1 && n < 5 && ~~(n / 10) !== 1;
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's': // a few seconds / in a few seconds / a few seconds ago
                return withoutSuffix || isFuture ? 'pár sekund' : 'pár sekundami';
            case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'sekundy' : 'sekund');
                } else {
                    return result + 'sekundami';
                }
            case 'm': // a minute / in a minute / a minute ago
                return withoutSuffix ? 'minuta' : isFuture ? 'minutu' : 'minutou';
            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'minuty' : 'minut');
                } else {
                    return result + 'minutami';
                }
            case 'h': // an hour / in an hour / an hour ago
                return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';
            case 'hh': // 9 hours / in 9 hours / 9 hours ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'hodiny' : 'hodin');
                } else {
                    return result + 'hodinami';
                }
            case 'd': // a day / in a day / a day ago
                return withoutSuffix || isFuture ? 'den' : 'dnem';
            case 'dd': // 9 days / in 9 days / 9 days ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'dny' : 'dní');
                } else {
                    return result + 'dny';
                }
            case 'M': // a month / in a month / a month ago
                return withoutSuffix || isFuture ? 'měsíc' : 'měsícem';
            case 'MM': // 9 months / in 9 months / 9 months ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'měsíce' : 'měsíců');
                } else {
                    return result + 'měsíci';
                }
            case 'y': // a year / in a year / a year ago
                return withoutSuffix || isFuture ? 'rok' : 'rokem';
            case 'yy': // 9 years / in 9 years / 9 years ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'roky' : 'let');
                } else {
                    return result + 'lety';
                }
        }
    }

    var cs = moment.defineLocale('cs', {
        months: months,
        monthsShort: monthsShort,
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        // NOTE: 'červen' is substring of 'červenec'; therefore 'červenec' must precede 'červen' in the regex to be fully matched.
        // Otherwise parser matches '1. červenec' as '1. červen' + 'ec'.
        monthsStrictRegex: /^(leden|ledna|února|únor|březen|března|duben|dubna|květen|května|červenec|července|červen|června|srpen|srpna|září|říjen|října|listopadu|listopad|prosinec|prosince)/i,
        monthsShortStrictRegex: /^(led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
        weekdaysShort: 'ne_po_út_st_čt_pá_so'.split('_'),
        weekdaysMin: 'ne_po_út_st_čt_pá_so'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd D. MMMM YYYY H:mm',
            l: 'D. M. YYYY',
        },
        calendar: {
            sameDay: '[dnes v] LT',
            nextDay: '[zítra v] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[v neděli v] LT';
                    case 1:
                    case 2:
                        return '[v] dddd [v] LT';
                    case 3:
                        return '[ve středu v] LT';
                    case 4:
                        return '[ve čtvrtek v] LT';
                    case 5:
                        return '[v pátek v] LT';
                    case 6:
                        return '[v sobotu v] LT';
                }
            },
            lastDay: '[včera v] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[minulou neděli v] LT';
                    case 1:
                    case 2:
                        return '[minulé] dddd [v] LT';
                    case 3:
                        return '[minulou středu v] LT';
                    case 4:
                    case 5:
                        return '[minulý] dddd [v] LT';
                    case 6:
                        return '[minulou sobotu v] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'za %s',
            past: 'před %s',
            s: translate,
            ss: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: translate,
            dd: translate,
            M: translate,
            MM: translate,
            y: translate,
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return cs;

})));


/***/ }),

/***/ "./node_modules/moment/locale/cv.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/cv.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chuvash [cv]
//! author : Anatoly Mironov : https://github.com/mirontoli

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var cv = moment.defineLocale('cv', {
        months: 'кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав'.split(
            '_'
        ),
        monthsShort: 'кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш'.split('_'),
        weekdays: 'вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун'.split(
            '_'
        ),
        weekdaysShort: 'выр_тун_ытл_юн_кӗҫ_эрн_шӑм'.split('_'),
        weekdaysMin: 'вр_тн_ыт_юн_кҫ_эр_шм'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD-MM-YYYY',
            LL: 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]',
            LLL: 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
            LLLL: 'dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
        },
        calendar: {
            sameDay: '[Паян] LT [сехетре]',
            nextDay: '[Ыран] LT [сехетре]',
            lastDay: '[Ӗнер] LT [сехетре]',
            nextWeek: '[Ҫитес] dddd LT [сехетре]',
            lastWeek: '[Иртнӗ] dddd LT [сехетре]',
            sameElse: 'L',
        },
        relativeTime: {
            future: function (output) {
                var affix = /сехет$/i.exec(output)
                    ? 'рен'
                    : /ҫул$/i.exec(output)
                    ? 'тан'
                    : 'ран';
                return output + affix;
            },
            past: '%s каялла',
            s: 'пӗр-ик ҫеккунт',
            ss: '%d ҫеккунт',
            m: 'пӗр минут',
            mm: '%d минут',
            h: 'пӗр сехет',
            hh: '%d сехет',
            d: 'пӗр кун',
            dd: '%d кун',
            M: 'пӗр уйӑх',
            MM: '%d уйӑх',
            y: 'пӗр ҫул',
            yy: '%d ҫул',
        },
        dayOfMonthOrdinalParse: /\d{1,2}-мӗш/,
        ordinal: '%d-мӗш',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return cv;

})));


/***/ }),

/***/ "./node_modules/moment/locale/cy.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/cy.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Welsh [cy]
//! author : Robert Allen : https://github.com/robgallen
//! author : https://github.com/ryangreaves

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var cy = moment.defineLocale('cy', {
        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split(
            '_'
        ),
        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split(
            '_'
        ),
        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split(
            '_'
        ),
        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
        weekdaysParseExact: true,
        // time formats are the same as en-gb
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Heddiw am] LT',
            nextDay: '[Yfory am] LT',
            nextWeek: 'dddd [am] LT',
            lastDay: '[Ddoe am] LT',
            lastWeek: 'dddd [diwethaf am] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'mewn %s',
            past: '%s yn ôl',
            s: 'ychydig eiliadau',
            ss: '%d eiliad',
            m: 'munud',
            mm: '%d munud',
            h: 'awr',
            hh: '%d awr',
            d: 'diwrnod',
            dd: '%d diwrnod',
            M: 'mis',
            MM: '%d mis',
            y: 'blwyddyn',
            yy: '%d flynedd',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
        ordinal: function (number) {
            var b = number,
                output = '',
                lookup = [
                    '',
                    'af',
                    'il',
                    'ydd',
                    'ydd',
                    'ed',
                    'ed',
                    'ed',
                    'fed',
                    'fed',
                    'fed', // 1af to 10fed
                    'eg',
                    'fed',
                    'eg',
                    'eg',
                    'fed',
                    'eg',
                    'eg',
                    'fed',
                    'eg',
                    'fed', // 11eg to 20fed
                ];
            if (b > 20) {
                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                    output = 'fed'; // not 30ain, 70ain or 90ain
                } else {
                    output = 'ain';
                }
            } else if (b > 0) {
                output = lookup[b];
            }
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return cy;

})));


/***/ }),

/***/ "./node_modules/moment/locale/da.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/da.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Danish [da]
//! author : Ulrik Nielsen : https://github.com/mrbase

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var da = moment.defineLocale('da', {
        months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split(
            '_'
        ),
        monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays: 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
        weekdaysShort: 'søn_man_tir_ons_tor_fre_lør'.split('_'),
        weekdaysMin: 'sø_ma_ti_on_to_fr_lø'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY HH:mm',
            LLLL: 'dddd [d.] D. MMMM YYYY [kl.] HH:mm',
        },
        calendar: {
            sameDay: '[i dag kl.] LT',
            nextDay: '[i morgen kl.] LT',
            nextWeek: 'på dddd [kl.] LT',
            lastDay: '[i går kl.] LT',
            lastWeek: '[i] dddd[s kl.] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'om %s',
            past: '%s siden',
            s: 'få sekunder',
            ss: '%d sekunder',
            m: 'et minut',
            mm: '%d minutter',
            h: 'en time',
            hh: '%d timer',
            d: 'en dag',
            dd: '%d dage',
            M: 'en måned',
            MM: '%d måneder',
            y: 'et år',
            yy: '%d år',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return da;

})));


/***/ }),

/***/ "./node_modules/moment/locale/de-at.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/de-at.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German (Austria) [de-at]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensúle: https://github.com/Oire
//! author : Martin Groller : https://github.com/MadMG
//! author : Mikolaj Dadela : https://github.com/mik01aj

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            m: ['eine Minute', 'einer Minute'],
            h: ['eine Stunde', 'einer Stunde'],
            d: ['ein Tag', 'einem Tag'],
            dd: [number + ' Tage', number + ' Tagen'],
            w: ['eine Woche', 'einer Woche'],
            M: ['ein Monat', 'einem Monat'],
            MM: [number + ' Monate', number + ' Monaten'],
            y: ['ein Jahr', 'einem Jahr'],
            yy: [number + ' Jahre', number + ' Jahren'],
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var deAt = moment.defineLocale('de-at', {
        months: 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split(
            '_'
        ),
        monthsShort: 'Jän._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split(
            '_'
        ),
        weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY HH:mm',
            LLLL: 'dddd, D. MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]',
        },
        relativeTime: {
            future: 'in %s',
            past: 'vor %s',
            s: 'ein paar Sekunden',
            ss: '%d Sekunden',
            m: processRelativeTime,
            mm: '%d Minuten',
            h: processRelativeTime,
            hh: '%d Stunden',
            d: processRelativeTime,
            dd: processRelativeTime,
            w: processRelativeTime,
            ww: '%d Wochen',
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return deAt;

})));


/***/ }),

/***/ "./node_modules/moment/locale/de-ch.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/de-ch.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German (Switzerland) [de-ch]
//! author : sschueller : https://github.com/sschueller

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            m: ['eine Minute', 'einer Minute'],
            h: ['eine Stunde', 'einer Stunde'],
            d: ['ein Tag', 'einem Tag'],
            dd: [number + ' Tage', number + ' Tagen'],
            w: ['eine Woche', 'einer Woche'],
            M: ['ein Monat', 'einem Monat'],
            MM: [number + ' Monate', number + ' Monaten'],
            y: ['ein Jahr', 'einem Jahr'],
            yy: [number + ' Jahre', number + ' Jahren'],
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var deCh = moment.defineLocale('de-ch', {
        months: 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split(
            '_'
        ),
        monthsShort: 'Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split(
            '_'
        ),
        weekdaysShort: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY HH:mm',
            LLLL: 'dddd, D. MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]',
        },
        relativeTime: {
            future: 'in %s',
            past: 'vor %s',
            s: 'ein paar Sekunden',
            ss: '%d Sekunden',
            m: processRelativeTime,
            mm: '%d Minuten',
            h: processRelativeTime,
            hh: '%d Stunden',
            d: processRelativeTime,
            dd: processRelativeTime,
            w: processRelativeTime,
            ww: '%d Wochen',
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return deCh;

})));


/***/ }),

/***/ "./node_modules/moment/locale/de.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/de.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German [de]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensúle: https://github.com/Oire
//! author : Mikolaj Dadela : https://github.com/mik01aj

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            m: ['eine Minute', 'einer Minute'],
            h: ['eine Stunde', 'einer Stunde'],
            d: ['ein Tag', 'einem Tag'],
            dd: [number + ' Tage', number + ' Tagen'],
            w: ['eine Woche', 'einer Woche'],
            M: ['ein Monat', 'einem Monat'],
            MM: [number + ' Monate', number + ' Monaten'],
            y: ['ein Jahr', 'einem Jahr'],
            yy: [number + ' Jahre', number + ' Jahren'],
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de = moment.defineLocale('de', {
        months: 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split(
            '_'
        ),
        monthsShort: 'Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split(
            '_'
        ),
        weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY HH:mm',
            LLLL: 'dddd, D. MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]',
        },
        relativeTime: {
            future: 'in %s',
            past: 'vor %s',
            s: 'ein paar Sekunden',
            ss: '%d Sekunden',
            m: processRelativeTime,
            mm: '%d Minuten',
            h: processRelativeTime,
            hh: '%d Stunden',
            d: processRelativeTime,
            dd: processRelativeTime,
            w: processRelativeTime,
            ww: '%d Wochen',
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return de;

})));


/***/ }),

/***/ "./node_modules/moment/locale/dv.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/dv.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maldivian [dv]
//! author : Jawish Hameed : https://github.com/jawish

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var months = [
            'ޖެނުއަރީ',
            'ފެބްރުއަރީ',
            'މާރިޗު',
            'އޭޕްރީލު',
            'މޭ',
            'ޖޫން',
            'ޖުލައި',
            'އޯގަސްޓު',
            'ސެޕްޓެމްބަރު',
            'އޮކްޓޯބަރު',
            'ނޮވެމްބަރު',
            'ޑިސެމްބަރު',
        ],
        weekdays = [
            'އާދިއްތަ',
            'ހޯމަ',
            'އަންގާރަ',
            'ބުދަ',
            'ބުރާސްފަތި',
            'ހުކުރު',
            'ހޮނިހިރު',
        ];

    var dv = moment.defineLocale('dv', {
        months: months,
        monthsShort: months,
        weekdays: weekdays,
        weekdaysShort: weekdays,
        weekdaysMin: 'އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'D/M/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        meridiemParse: /މކ|މފ/,
        isPM: function (input) {
            return 'މފ' === input;
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'މކ';
            } else {
                return 'މފ';
            }
        },
        calendar: {
            sameDay: '[މިއަދު] LT',
            nextDay: '[މާދަމާ] LT',
            nextWeek: 'dddd LT',
            lastDay: '[އިއްޔެ] LT',
            lastWeek: '[ފާއިތުވި] dddd LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'ތެރޭގައި %s',
            past: 'ކުރިން %s',
            s: 'ސިކުންތުކޮޅެއް',
            ss: 'd% ސިކުންތު',
            m: 'މިނިޓެއް',
            mm: 'މިނިޓު %d',
            h: 'ގަޑިއިރެއް',
            hh: 'ގަޑިއިރު %d',
            d: 'ދުވަހެއް',
            dd: 'ދުވަސް %d',
            M: 'މަހެއް',
            MM: 'މަސް %d',
            y: 'އަހަރެއް',
            yy: 'އަހަރު %d',
        },
        preparse: function (string) {
            return string.replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '،');
        },
        week: {
            dow: 7, // Sunday is the first day of the week.
            doy: 12, // The week that contains Jan 12th is the first week of the year.
        },
    });

    return dv;

})));


/***/ }),

/***/ "./node_modules/moment/locale/el.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/el.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Greek [el]
//! author : Aggelos Karalias : https://github.com/mehiel

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function isFunction(input) {
        return (
            (typeof Function !== 'undefined' && input instanceof Function) ||
            Object.prototype.toString.call(input) === '[object Function]'
        );
    }

    var el = moment.defineLocale('el', {
        monthsNominativeEl: 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split(
            '_'
        ),
        monthsGenitiveEl: 'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split(
            '_'
        ),
        months: function (momentToFormat, format) {
            if (!momentToFormat) {
                return this._monthsNominativeEl;
            } else if (
                typeof format === 'string' &&
                /D/.test(format.substring(0, format.indexOf('MMMM')))
            ) {
                // if there is a day number before 'MMMM'
                return this._monthsGenitiveEl[momentToFormat.month()];
            } else {
                return this._monthsNominativeEl[momentToFormat.month()];
            }
        },
        monthsShort: 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
        weekdays: 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split(
            '_'
        ),
        weekdaysShort: 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
        weekdaysMin: 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
        meridiem: function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'μμ' : 'ΜΜ';
            } else {
                return isLower ? 'πμ' : 'ΠΜ';
            }
        },
        isPM: function (input) {
            return (input + '').toLowerCase()[0] === 'μ';
        },
        meridiemParse: /[ΠΜ]\.?Μ?\.?/i,
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendarEl: {
            sameDay: '[Σήμερα {}] LT',
            nextDay: '[Αύριο {}] LT',
            nextWeek: 'dddd [{}] LT',
            lastDay: '[Χθες {}] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 6:
                        return '[το προηγούμενο] dddd [{}] LT';
                    default:
                        return '[την προηγούμενη] dddd [{}] LT';
                }
            },
            sameElse: 'L',
        },
        calendar: function (key, mom) {
            var output = this._calendarEl[key],
                hours = mom && mom.hours();
            if (isFunction(output)) {
                output = output.apply(mom);
            }
            return output.replace('{}', hours % 12 === 1 ? 'στη' : 'στις');
        },
        relativeTime: {
            future: 'σε %s',
            past: '%s πριν',
            s: 'λίγα δευτερόλεπτα',
            ss: '%d δευτερόλεπτα',
            m: 'ένα λεπτό',
            mm: '%d λεπτά',
            h: 'μία ώρα',
            hh: '%d ώρες',
            d: 'μία μέρα',
            dd: '%d μέρες',
            M: 'ένας μήνας',
            MM: '%d μήνες',
            y: 'ένας χρόνος',
            yy: '%d χρόνια',
        },
        dayOfMonthOrdinalParse: /\d{1,2}η/,
        ordinal: '%dη',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4st is the first week of the year.
        },
    });

    return el;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-au.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-au.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Australia) [en-au]
//! author : Jared Morse : https://github.com/jarcoal

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var enAu = moment.defineLocale('en-au', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return enAu;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-ca.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-ca.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Canada) [en-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var enCa = moment.defineLocale('en-ca', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'YYYY-MM-DD',
            LL: 'MMMM D, YYYY',
            LLL: 'MMMM D, YYYY h:mm A',
            LLLL: 'dddd, MMMM D, YYYY h:mm A',
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
    });

    return enCa;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-gb.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-gb.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (United Kingdom) [en-gb]
//! author : Chris Gedrim : https://github.com/chrisgedrim

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var enGb = moment.defineLocale('en-gb', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return enGb;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-ie.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-ie.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Ireland) [en-ie]
//! author : Chris Cartlidge : https://github.com/chriscartlidge

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var enIe = moment.defineLocale('en-ie', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return enIe;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-il.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-il.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Israel) [en-il]
//! author : Chris Gedrim : https://github.com/chrisgedrim

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var enIl = moment.defineLocale('en-il', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
    });

    return enIl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-in.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-in.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (India) [en-in]
//! author : Jatin Agrawal : https://github.com/jatinag22

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var enIn = moment.defineLocale('en-in', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 1st is the first week of the year.
        },
    });

    return enIn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-nz.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-nz.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (New Zealand) [en-nz]
//! author : Luke McGregor : https://github.com/lukemcgregor

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var enNz = moment.defineLocale('en-nz', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return enNz;

})));


/***/ }),

/***/ "./node_modules/moment/locale/en-sg.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/en-sg.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Singapore) [en-sg]
//! author : Matthew Castrillon-Madrigal : https://github.com/techdimension

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var enSg = moment.defineLocale('en-sg', {
        months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return enSg;

})));


/***/ }),

/***/ "./node_modules/moment/locale/eo.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/eo.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Esperanto [eo]
//! author : Colin Dean : https://github.com/colindean
//! author : Mia Nordentoft Imperatori : https://github.com/miestasmia
//! comment : miestasmia corrected the translation by colindean
//! comment : Vivakvo corrected the translation by colindean and miestasmia

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var eo = moment.defineLocale('eo', {
        months: 'januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro'.split(
            '_'
        ),
        monthsShort: 'jan_feb_mart_apr_maj_jun_jul_aŭg_sept_okt_nov_dec'.split('_'),
        weekdays: 'dimanĉo_lundo_mardo_merkredo_ĵaŭdo_vendredo_sabato'.split('_'),
        weekdaysShort: 'dim_lun_mard_merk_ĵaŭ_ven_sab'.split('_'),
        weekdaysMin: 'di_lu_ma_me_ĵa_ve_sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: '[la] D[-an de] MMMM, YYYY',
            LLL: '[la] D[-an de] MMMM, YYYY HH:mm',
            LLLL: 'dddd[n], [la] D[-an de] MMMM, YYYY HH:mm',
            llll: 'ddd, [la] D[-an de] MMM, YYYY HH:mm',
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function (input) {
            return input.charAt(0).toLowerCase() === 'p';
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'p.t.m.' : 'P.T.M.';
            } else {
                return isLower ? 'a.t.m.' : 'A.T.M.';
            }
        },
        calendar: {
            sameDay: '[Hodiaŭ je] LT',
            nextDay: '[Morgaŭ je] LT',
            nextWeek: 'dddd[n je] LT',
            lastDay: '[Hieraŭ je] LT',
            lastWeek: '[pasintan] dddd[n je] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'post %s',
            past: 'antaŭ %s',
            s: 'kelkaj sekundoj',
            ss: '%d sekundoj',
            m: 'unu minuto',
            mm: '%d minutoj',
            h: 'unu horo',
            hh: '%d horoj',
            d: 'unu tago', //ne 'diurno', ĉar estas uzita por proksimumo
            dd: '%d tagoj',
            M: 'unu monato',
            MM: '%d monatoj',
            y: 'unu jaro',
            yy: '%d jaroj',
        },
        dayOfMonthOrdinalParse: /\d{1,2}a/,
        ordinal: '%da',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return eo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/es-do.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/es-do.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish (Dominican Republic) [es-do]

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
            '_'
        ),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
        monthsParse = [
            /^ene/i,
            /^feb/i,
            /^mar/i,
            /^abr/i,
            /^may/i,
            /^jun/i,
            /^jul/i,
            /^ago/i,
            /^sep/i,
            /^oct/i,
            /^nov/i,
            /^dic/i,
        ],
        monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

    var esDo = moment.defineLocale('es-do', {
        months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
            '_'
        ),
        monthsShort: function (m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
        weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
        weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY h:mm A',
            LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A',
        },
        calendar: {
            sameDay: function () {
                return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextDay: function () {
                return '[mañana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextWeek: function () {
                return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastDay: function () {
                return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastWeek: function () {
                return (
                    '[el] dddd [pasado a la' +
                    (this.hours() !== 1 ? 's' : '') +
                    '] LT'
                );
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'en %s',
            past: 'hace %s',
            s: 'unos segundos',
            ss: '%d segundos',
            m: 'un minuto',
            mm: '%d minutos',
            h: 'una hora',
            hh: '%d horas',
            d: 'un día',
            dd: '%d días',
            w: 'una semana',
            ww: '%d semanas',
            M: 'un mes',
            MM: '%d meses',
            y: 'un año',
            yy: '%d años',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return esDo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/es-mx.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/es-mx.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish (Mexico) [es-mx]
//! author : JC Franco : https://github.com/jcfranco

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
            '_'
        ),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
        monthsParse = [
            /^ene/i,
            /^feb/i,
            /^mar/i,
            /^abr/i,
            /^may/i,
            /^jun/i,
            /^jul/i,
            /^ago/i,
            /^sep/i,
            /^oct/i,
            /^nov/i,
            /^dic/i,
        ],
        monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

    var esMx = moment.defineLocale('es-mx', {
        months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
            '_'
        ),
        monthsShort: function (m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
        weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
        weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY H:mm',
            LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
        },
        calendar: {
            sameDay: function () {
                return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextDay: function () {
                return '[mañana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextWeek: function () {
                return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastDay: function () {
                return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastWeek: function () {
                return (
                    '[el] dddd [pasado a la' +
                    (this.hours() !== 1 ? 's' : '') +
                    '] LT'
                );
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'en %s',
            past: 'hace %s',
            s: 'unos segundos',
            ss: '%d segundos',
            m: 'un minuto',
            mm: '%d minutos',
            h: 'una hora',
            hh: '%d horas',
            d: 'un día',
            dd: '%d días',
            w: 'una semana',
            ww: '%d semanas',
            M: 'un mes',
            MM: '%d meses',
            y: 'un año',
            yy: '%d años',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
        invalidDate: 'Fecha inválida',
    });

    return esMx;

})));


/***/ }),

/***/ "./node_modules/moment/locale/es-us.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/es-us.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish (United States) [es-us]
//! author : bustta : https://github.com/bustta
//! author : chrisrodz : https://github.com/chrisrodz

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
            '_'
        ),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
        monthsParse = [
            /^ene/i,
            /^feb/i,
            /^mar/i,
            /^abr/i,
            /^may/i,
            /^jun/i,
            /^jul/i,
            /^ago/i,
            /^sep/i,
            /^oct/i,
            /^nov/i,
            /^dic/i,
        ],
        monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

    var esUs = moment.defineLocale('es-us', {
        months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
            '_'
        ),
        monthsShort: function (m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
        weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
        weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'MM/DD/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY h:mm A',
            LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A',
        },
        calendar: {
            sameDay: function () {
                return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextDay: function () {
                return '[mañana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextWeek: function () {
                return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastDay: function () {
                return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastWeek: function () {
                return (
                    '[el] dddd [pasado a la' +
                    (this.hours() !== 1 ? 's' : '') +
                    '] LT'
                );
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'en %s',
            past: 'hace %s',
            s: 'unos segundos',
            ss: '%d segundos',
            m: 'un minuto',
            mm: '%d minutos',
            h: 'una hora',
            hh: '%d horas',
            d: 'un día',
            dd: '%d días',
            w: 'una semana',
            ww: '%d semanas',
            M: 'un mes',
            MM: '%d meses',
            y: 'un año',
            yy: '%d años',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return esUs;

})));


/***/ }),

/***/ "./node_modules/moment/locale/es.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/es.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish [es]
//! author : Julio Napurí : https://github.com/julionc

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split(
            '_'
        ),
        monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
        monthsParse = [
            /^ene/i,
            /^feb/i,
            /^mar/i,
            /^abr/i,
            /^may/i,
            /^jun/i,
            /^jul/i,
            /^ago/i,
            /^sep/i,
            /^oct/i,
            /^nov/i,
            /^dic/i,
        ],
        monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

    var es = moment.defineLocale('es', {
        months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split(
            '_'
        ),
        monthsShort: function (m, format) {
            if (!m) {
                return monthsShortDot;
            } else if (/-MMM-/.test(format)) {
                return monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
        monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
        weekdaysShort: 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
        weekdaysMin: 'do_lu_ma_mi_ju_vi_sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY H:mm',
            LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
        },
        calendar: {
            sameDay: function () {
                return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextDay: function () {
                return '[mañana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            nextWeek: function () {
                return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastDay: function () {
                return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
            },
            lastWeek: function () {
                return (
                    '[el] dddd [pasado a la' +
                    (this.hours() !== 1 ? 's' : '') +
                    '] LT'
                );
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'en %s',
            past: 'hace %s',
            s: 'unos segundos',
            ss: '%d segundos',
            m: 'un minuto',
            mm: '%d minutos',
            h: 'una hora',
            hh: '%d horas',
            d: 'un día',
            dd: '%d días',
            w: 'una semana',
            ww: '%d semanas',
            M: 'un mes',
            MM: '%d meses',
            y: 'un año',
            yy: '%d años',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
        invalidDate: 'Fecha inválida',
    });

    return es;

})));


/***/ }),

/***/ "./node_modules/moment/locale/et.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/et.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Estonian [et]
//! author : Henry Kehlmann : https://github.com/madhenry
//! improvements : Illimar Tambek : https://github.com/ragulka

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            s: ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
            ss: [number + 'sekundi', number + 'sekundit'],
            m: ['ühe minuti', 'üks minut'],
            mm: [number + ' minuti', number + ' minutit'],
            h: ['ühe tunni', 'tund aega', 'üks tund'],
            hh: [number + ' tunni', number + ' tundi'],
            d: ['ühe päeva', 'üks päev'],
            M: ['kuu aja', 'kuu aega', 'üks kuu'],
            MM: [number + ' kuu', number + ' kuud'],
            y: ['ühe aasta', 'aasta', 'üks aasta'],
            yy: [number + ' aasta', number + ' aastat'],
        };
        if (withoutSuffix) {
            return format[key][2] ? format[key][2] : format[key][1];
        }
        return isFuture ? format[key][0] : format[key][1];
    }

    var et = moment.defineLocale('et', {
        months: 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split(
            '_'
        ),
        monthsShort: 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split(
            '_'
        ),
        weekdays: 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split(
            '_'
        ),
        weekdaysShort: 'P_E_T_K_N_R_L'.split('_'),
        weekdaysMin: 'P_E_T_K_N_R_L'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[Täna,] LT',
            nextDay: '[Homme,] LT',
            nextWeek: '[Järgmine] dddd LT',
            lastDay: '[Eile,] LT',
            lastWeek: '[Eelmine] dddd LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s pärast',
            past: '%s tagasi',
            s: processRelativeTime,
            ss: processRelativeTime,
            m: processRelativeTime,
            mm: processRelativeTime,
            h: processRelativeTime,
            hh: processRelativeTime,
            d: processRelativeTime,
            dd: '%d päeva',
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return et;

})));


/***/ }),

/***/ "./node_modules/moment/locale/eu.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/eu.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Basque [eu]
//! author : Eneko Illarramendi : https://github.com/eillarra

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var eu = moment.defineLocale('eu', {
        months: 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split(
            '_'
        ),
        monthsShort: 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split(
            '_'
        ),
        weekdaysShort: 'ig._al._ar._az._og._ol._lr.'.split('_'),
        weekdaysMin: 'ig_al_ar_az_og_ol_lr'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'YYYY[ko] MMMM[ren] D[a]',
            LLL: 'YYYY[ko] MMMM[ren] D[a] HH:mm',
            LLLL: 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
            l: 'YYYY-M-D',
            ll: 'YYYY[ko] MMM D[a]',
            lll: 'YYYY[ko] MMM D[a] HH:mm',
            llll: 'ddd, YYYY[ko] MMM D[a] HH:mm',
        },
        calendar: {
            sameDay: '[gaur] LT[etan]',
            nextDay: '[bihar] LT[etan]',
            nextWeek: 'dddd LT[etan]',
            lastDay: '[atzo] LT[etan]',
            lastWeek: '[aurreko] dddd LT[etan]',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s barru',
            past: 'duela %s',
            s: 'segundo batzuk',
            ss: '%d segundo',
            m: 'minutu bat',
            mm: '%d minutu',
            h: 'ordu bat',
            hh: '%d ordu',
            d: 'egun bat',
            dd: '%d egun',
            M: 'hilabete bat',
            MM: '%d hilabete',
            y: 'urte bat',
            yy: '%d urte',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return eu;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fa.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/fa.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Persian [fa]
//! author : Ebrahim Byagowi : https://github.com/ebraminio

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            1: '۱',
            2: '۲',
            3: '۳',
            4: '۴',
            5: '۵',
            6: '۶',
            7: '۷',
            8: '۸',
            9: '۹',
            0: '۰',
        },
        numberMap = {
            '۱': '1',
            '۲': '2',
            '۳': '3',
            '۴': '4',
            '۵': '5',
            '۶': '6',
            '۷': '7',
            '۸': '8',
            '۹': '9',
            '۰': '0',
        };

    var fa = moment.defineLocale('fa', {
        months: 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split(
            '_'
        ),
        monthsShort: 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split(
            '_'
        ),
        weekdays: 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split(
            '_'
        ),
        weekdaysShort: 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split(
            '_'
        ),
        weekdaysMin: 'ی_د_س_چ_پ_ج_ش'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        meridiemParse: /قبل از ظهر|بعد از ظهر/,
        isPM: function (input) {
            return /بعد از ظهر/.test(input);
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'قبل از ظهر';
            } else {
                return 'بعد از ظهر';
            }
        },
        calendar: {
            sameDay: '[امروز ساعت] LT',
            nextDay: '[فردا ساعت] LT',
            nextWeek: 'dddd [ساعت] LT',
            lastDay: '[دیروز ساعت] LT',
            lastWeek: 'dddd [پیش] [ساعت] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'در %s',
            past: '%s پیش',
            s: 'چند ثانیه',
            ss: '%d ثانیه',
            m: 'یک دقیقه',
            mm: '%d دقیقه',
            h: 'یک ساعت',
            hh: '%d ساعت',
            d: 'یک روز',
            dd: '%d روز',
            M: 'یک ماه',
            MM: '%d ماه',
            y: 'یک سال',
            yy: '%d سال',
        },
        preparse: function (string) {
            return string
                .replace(/[۰-۹]/g, function (match) {
                    return numberMap[match];
                })
                .replace(/،/g, ',');
        },
        postformat: function (string) {
            return string
                .replace(/\d/g, function (match) {
                    return symbolMap[match];
                })
                .replace(/,/g, '،');
        },
        dayOfMonthOrdinalParse: /\d{1,2}م/,
        ordinal: '%dم',
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12, // The week that contains Jan 12th is the first week of the year.
        },
    });

    return fa;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fi.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/fi.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Finnish [fi]
//! author : Tarmo Aidantausta : https://github.com/bleadof

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(
            ' '
        ),
        numbersFuture = [
            'nolla',
            'yhden',
            'kahden',
            'kolmen',
            'neljän',
            'viiden',
            'kuuden',
            numbersPast[7],
            numbersPast[8],
            numbersPast[9],
        ];
    function translate(number, withoutSuffix, key, isFuture) {
        var result = '';
        switch (key) {
            case 's':
                return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
            case 'ss':
                result = isFuture ? 'sekunnin' : 'sekuntia';
                break;
            case 'm':
                return isFuture ? 'minuutin' : 'minuutti';
            case 'mm':
                result = isFuture ? 'minuutin' : 'minuuttia';
                break;
            case 'h':
                return isFuture ? 'tunnin' : 'tunti';
            case 'hh':
                result = isFuture ? 'tunnin' : 'tuntia';
                break;
            case 'd':
                return isFuture ? 'päivän' : 'päivä';
            case 'dd':
                result = isFuture ? 'päivän' : 'päivää';
                break;
            case 'M':
                return isFuture ? 'kuukauden' : 'kuukausi';
            case 'MM':
                result = isFuture ? 'kuukauden' : 'kuukautta';
                break;
            case 'y':
                return isFuture ? 'vuoden' : 'vuosi';
            case 'yy':
                result = isFuture ? 'vuoden' : 'vuotta';
                break;
        }
        result = verbalNumber(number, isFuture) + ' ' + result;
        return result;
    }
    function verbalNumber(number, isFuture) {
        return number < 10
            ? isFuture
                ? numbersFuture[number]
                : numbersPast[number]
            : number;
    }

    var fi = moment.defineLocale('fi', {
        months: 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split(
            '_'
        ),
        monthsShort: 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split(
            '_'
        ),
        weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split(
            '_'
        ),
        weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'),
        weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD.MM.YYYY',
            LL: 'Do MMMM[ta] YYYY',
            LLL: 'Do MMMM[ta] YYYY, [klo] HH.mm',
            LLLL: 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
            l: 'D.M.YYYY',
            ll: 'Do MMM YYYY',
            lll: 'Do MMM YYYY, [klo] HH.mm',
            llll: 'ddd, Do MMM YYYY, [klo] HH.mm',
        },
        calendar: {
            sameDay: '[tänään] [klo] LT',
            nextDay: '[huomenna] [klo] LT',
            nextWeek: 'dddd [klo] LT',
            lastDay: '[eilen] [klo] LT',
            lastWeek: '[viime] dddd[na] [klo] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s päästä',
            past: '%s sitten',
            s: translate,
            ss: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: translate,
            dd: translate,
            M: translate,
            MM: translate,
            y: translate,
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return fi;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fil.js":
/*!*******************************************!*\
  !*** ./node_modules/moment/locale/fil.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Filipino [fil]
//! author : Dan Hagman : https://github.com/hagmandan
//! author : Matthew Co : https://github.com/matthewdeeco

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var fil = moment.defineLocale('fil', {
        months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split(
            '_'
        ),
        monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
        weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split(
            '_'
        ),
        weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
        weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'MM/D/YYYY',
            LL: 'MMMM D, YYYY',
            LLL: 'MMMM D, YYYY HH:mm',
            LLLL: 'dddd, MMMM DD, YYYY HH:mm',
        },
        calendar: {
            sameDay: 'LT [ngayong araw]',
            nextDay: '[Bukas ng] LT',
            nextWeek: 'LT [sa susunod na] dddd',
            lastDay: 'LT [kahapon]',
            lastWeek: 'LT [noong nakaraang] dddd',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'sa loob ng %s',
            past: '%s ang nakalipas',
            s: 'ilang segundo',
            ss: '%d segundo',
            m: 'isang minuto',
            mm: '%d minuto',
            h: 'isang oras',
            hh: '%d oras',
            d: 'isang araw',
            dd: '%d araw',
            M: 'isang buwan',
            MM: '%d buwan',
            y: 'isang taon',
            yy: '%d taon',
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function (number) {
            return number;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return fil;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fo.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/fo.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Faroese [fo]
//! author : Ragnar Johannesen : https://github.com/ragnar123
//! author : Kristian Sakarisson : https://github.com/sakarisson

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var fo = moment.defineLocale('fo', {
        months: 'januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember'.split(
            '_'
        ),
        monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays: 'sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur'.split(
            '_'
        ),
        weekdaysShort: 'sun_mán_týs_mik_hós_frí_ley'.split('_'),
        weekdaysMin: 'su_má_tý_mi_hó_fr_le'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D. MMMM, YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Í dag kl.] LT',
            nextDay: '[Í morgin kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[Í gjár kl.] LT',
            lastWeek: '[síðstu] dddd [kl] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'um %s',
            past: '%s síðani',
            s: 'fá sekund',
            ss: '%d sekundir',
            m: 'ein minuttur',
            mm: '%d minuttir',
            h: 'ein tími',
            hh: '%d tímar',
            d: 'ein dagur',
            dd: '%d dagar',
            M: 'ein mánaður',
            MM: '%d mánaðir',
            y: 'eitt ár',
            yy: '%d ár',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return fo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fr-ca.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/fr-ca.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French (Canada) [fr-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var frCa = moment.defineLocale('fr-ca', {
        months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split(
            '_'
        ),
        monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Aujourd’hui à] LT',
            nextDay: '[Demain à] LT',
            nextWeek: 'dddd [à] LT',
            lastDay: '[Hier à] LT',
            lastWeek: 'dddd [dernier à] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'dans %s',
            past: 'il y a %s',
            s: 'quelques secondes',
            ss: '%d secondes',
            m: 'une minute',
            mm: '%d minutes',
            h: 'une heure',
            hh: '%d heures',
            d: 'un jour',
            dd: '%d jours',
            M: 'un mois',
            MM: '%d mois',
            y: 'un an',
            yy: '%d ans',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal: function (number, period) {
            switch (period) {
                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'D':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        },
    });

    return frCa;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fr-ch.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/fr-ch.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French (Switzerland) [fr-ch]
//! author : Gaspard Bucher : https://github.com/gaspard

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var frCh = moment.defineLocale('fr-ch', {
        months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split(
            '_'
        ),
        monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Aujourd’hui à] LT',
            nextDay: '[Demain à] LT',
            nextWeek: 'dddd [à] LT',
            lastDay: '[Hier à] LT',
            lastWeek: 'dddd [dernier à] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'dans %s',
            past: 'il y a %s',
            s: 'quelques secondes',
            ss: '%d secondes',
            m: 'une minute',
            mm: '%d minutes',
            h: 'une heure',
            hh: '%d heures',
            d: 'un jour',
            dd: '%d jours',
            M: 'un mois',
            MM: '%d mois',
            y: 'un an',
            yy: '%d ans',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
        ordinal: function (number, period) {
            switch (period) {
                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'D':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return frCh;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fr.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/fr.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French [fr]
//! author : John Fischer : https://github.com/jfroffice

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var monthsStrictRegex = /^(janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i,
        monthsShortStrictRegex = /(janv\.?|févr\.?|mars|avr\.?|mai|juin|juil\.?|août|sept\.?|oct\.?|nov\.?|déc\.?)/i,
        monthsRegex = /(janv\.?|févr\.?|mars|avr\.?|mai|juin|juil\.?|août|sept\.?|oct\.?|nov\.?|déc\.?|janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i,
        monthsParse = [
            /^janv/i,
            /^févr/i,
            /^mars/i,
            /^avr/i,
            /^mai/i,
            /^juin/i,
            /^juil/i,
            /^août/i,
            /^sept/i,
            /^oct/i,
            /^nov/i,
            /^déc/i,
        ];

    var fr = moment.defineLocale('fr', {
        months: 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split(
            '_'
        ),
        monthsShort: 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split(
            '_'
        ),
        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: monthsStrictRegex,
        monthsShortStrictRegex: monthsShortStrictRegex,
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Aujourd’hui à] LT',
            nextDay: '[Demain à] LT',
            nextWeek: 'dddd [à] LT',
            lastDay: '[Hier à] LT',
            lastWeek: 'dddd [dernier à] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'dans %s',
            past: 'il y a %s',
            s: 'quelques secondes',
            ss: '%d secondes',
            m: 'une minute',
            mm: '%d minutes',
            h: 'une heure',
            hh: '%d heures',
            d: 'un jour',
            dd: '%d jours',
            w: 'une semaine',
            ww: '%d semaines',
            M: 'un mois',
            MM: '%d mois',
            y: 'un an',
            yy: '%d ans',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
        ordinal: function (number, period) {
            switch (period) {
                // TODO: Return 'e' when day of month > 1. Move this case inside
                // block for masculine words below.
                // See https://github.com/moment/moment/issues/3375
                case 'D':
                    return number + (number === 1 ? 'er' : '');

                // Words with masculine grammatical gender: mois, trimestre, jour
                default:
                case 'M':
                case 'Q':
                case 'DDD':
                case 'd':
                    return number + (number === 1 ? 'er' : 'e');

                // Words with feminine grammatical gender: semaine
                case 'w':
                case 'W':
                    return number + (number === 1 ? 're' : 'e');
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return fr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/fy.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/fy.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Frisian [fy]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split(
            '_'
        ),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split(
            '_'
        );

    var fy = moment.defineLocale('fy', {
        months: 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split(
            '_'
        ),
        monthsShort: function (m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },
        monthsParseExact: true,
        weekdays: 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split(
            '_'
        ),
        weekdaysShort: 'si._mo._ti._wo._to._fr._so.'.split('_'),
        weekdaysMin: 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD-MM-YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[hjoed om] LT',
            nextDay: '[moarn om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[juster om] LT',
            lastWeek: '[ôfrûne] dddd [om] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'oer %s',
            past: '%s lyn',
            s: 'in pear sekonden',
            ss: '%d sekonden',
            m: 'ien minút',
            mm: '%d minuten',
            h: 'ien oere',
            hh: '%d oeren',
            d: 'ien dei',
            dd: '%d dagen',
            M: 'ien moanne',
            MM: '%d moannen',
            y: 'ien jier',
            yy: '%d jierren',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function (number) {
            return (
                number +
                (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
            );
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return fy;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ga.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ga.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Irish or Irish Gaelic [ga]
//! author : André Silva : https://github.com/askpt

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var months = [
            'Eanáir',
            'Feabhra',
            'Márta',
            'Aibreán',
            'Bealtaine',
            'Meitheamh',
            'Iúil',
            'Lúnasa',
            'Meán Fómhair',
            'Deireadh Fómhair',
            'Samhain',
            'Nollaig',
        ],
        monthsShort = [
            'Ean',
            'Feabh',
            'Márt',
            'Aib',
            'Beal',
            'Meith',
            'Iúil',
            'Lún',
            'M.F.',
            'D.F.',
            'Samh',
            'Noll',
        ],
        weekdays = [
            'Dé Domhnaigh',
            'Dé Luain',
            'Dé Máirt',
            'Dé Céadaoin',
            'Déardaoin',
            'Dé hAoine',
            'Dé Sathairn',
        ],
        weekdaysShort = ['Domh', 'Luan', 'Máirt', 'Céad', 'Déar', 'Aoine', 'Sath'],
        weekdaysMin = ['Do', 'Lu', 'Má', 'Cé', 'Dé', 'A', 'Sa'];

    var ga = moment.defineLocale('ga', {
        months: months,
        monthsShort: monthsShort,
        monthsParseExact: true,
        weekdays: weekdays,
        weekdaysShort: weekdaysShort,
        weekdaysMin: weekdaysMin,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Inniu ag] LT',
            nextDay: '[Amárach ag] LT',
            nextWeek: 'dddd [ag] LT',
            lastDay: '[Inné ag] LT',
            lastWeek: 'dddd [seo caite] [ag] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'i %s',
            past: '%s ó shin',
            s: 'cúpla soicind',
            ss: '%d soicind',
            m: 'nóiméad',
            mm: '%d nóiméad',
            h: 'uair an chloig',
            hh: '%d uair an chloig',
            d: 'lá',
            dd: '%d lá',
            M: 'mí',
            MM: '%d míonna',
            y: 'bliain',
            yy: '%d bliain',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
        ordinal: function (number) {
            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return ga;

})));


/***/ }),

/***/ "./node_modules/moment/locale/gd.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/gd.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Scottish Gaelic [gd]
//! author : Jon Ashdown : https://github.com/jonashdown

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var months = [
            'Am Faoilleach',
            'An Gearran',
            'Am Màrt',
            'An Giblean',
            'An Cèitean',
            'An t-Ògmhios',
            'An t-Iuchar',
            'An Lùnastal',
            'An t-Sultain',
            'An Dàmhair',
            'An t-Samhain',
            'An Dùbhlachd',
        ],
        monthsShort = [
            'Faoi',
            'Gear',
            'Màrt',
            'Gibl',
            'Cèit',
            'Ògmh',
            'Iuch',
            'Lùn',
            'Sult',
            'Dàmh',
            'Samh',
            'Dùbh',
        ],
        weekdays = [
            'Didòmhnaich',
            'Diluain',
            'Dimàirt',
            'Diciadain',
            'Diardaoin',
            'Dihaoine',
            'Disathairne',
        ],
        weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'],
        weekdaysMin = ['Dò', 'Lu', 'Mà', 'Ci', 'Ar', 'Ha', 'Sa'];

    var gd = moment.defineLocale('gd', {
        months: months,
        monthsShort: monthsShort,
        monthsParseExact: true,
        weekdays: weekdays,
        weekdaysShort: weekdaysShort,
        weekdaysMin: weekdaysMin,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[An-diugh aig] LT',
            nextDay: '[A-màireach aig] LT',
            nextWeek: 'dddd [aig] LT',
            lastDay: '[An-dè aig] LT',
            lastWeek: 'dddd [seo chaidh] [aig] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'ann an %s',
            past: 'bho chionn %s',
            s: 'beagan diogan',
            ss: '%d diogan',
            m: 'mionaid',
            mm: '%d mionaidean',
            h: 'uair',
            hh: '%d uairean',
            d: 'latha',
            dd: '%d latha',
            M: 'mìos',
            MM: '%d mìosan',
            y: 'bliadhna',
            yy: '%d bliadhna',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
        ordinal: function (number) {
            var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return gd;

})));


/***/ }),

/***/ "./node_modules/moment/locale/gl.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/gl.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Galician [gl]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var gl = moment.defineLocale('gl', {
        months: 'xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro'.split(
            '_'
        ),
        monthsShort: 'xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'domingo_luns_martes_mércores_xoves_venres_sábado'.split('_'),
        weekdaysShort: 'dom._lun._mar._mér._xov._ven._sáb.'.split('_'),
        weekdaysMin: 'do_lu_ma_mé_xo_ve_sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY H:mm',
            LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm',
        },
        calendar: {
            sameDay: function () {
                return '[hoxe ' + (this.hours() !== 1 ? 'ás' : 'á') + '] LT';
            },
            nextDay: function () {
                return '[mañá ' + (this.hours() !== 1 ? 'ás' : 'á') + '] LT';
            },
            nextWeek: function () {
                return 'dddd [' + (this.hours() !== 1 ? 'ás' : 'a') + '] LT';
            },
            lastDay: function () {
                return '[onte ' + (this.hours() !== 1 ? 'á' : 'a') + '] LT';
            },
            lastWeek: function () {
                return (
                    '[o] dddd [pasado ' + (this.hours() !== 1 ? 'ás' : 'a') + '] LT'
                );
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: function (str) {
                if (str.indexOf('un') === 0) {
                    return 'n' + str;
                }
                return 'en ' + str;
            },
            past: 'hai %s',
            s: 'uns segundos',
            ss: '%d segundos',
            m: 'un minuto',
            mm: '%d minutos',
            h: 'unha hora',
            hh: '%d horas',
            d: 'un día',
            dd: '%d días',
            M: 'un mes',
            MM: '%d meses',
            y: 'un ano',
            yy: '%d anos',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return gl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/gom-deva.js":
/*!************************************************!*\
  !*** ./node_modules/moment/locale/gom-deva.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Konkani Devanagari script [gom-deva]
//! author : The Discoverer : https://github.com/WikiDiscoverer

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            s: ['थोडया सॅकंडांनी', 'थोडे सॅकंड'],
            ss: [number + ' सॅकंडांनी', number + ' सॅकंड'],
            m: ['एका मिणटान', 'एक मिनूट'],
            mm: [number + ' मिणटांनी', number + ' मिणटां'],
            h: ['एका वरान', 'एक वर'],
            hh: [number + ' वरांनी', number + ' वरां'],
            d: ['एका दिसान', 'एक दीस'],
            dd: [number + ' दिसांनी', number + ' दीस'],
            M: ['एका म्हयन्यान', 'एक म्हयनो'],
            MM: [number + ' म्हयन्यानी', number + ' म्हयने'],
            y: ['एका वर्सान', 'एक वर्स'],
            yy: [number + ' वर्सांनी', number + ' वर्सां'],
        };
        return isFuture ? format[key][0] : format[key][1];
    }

    var gomDeva = moment.defineLocale('gom-deva', {
        months: {
            standalone: 'जानेवारी_फेब्रुवारी_मार्च_एप्रील_मे_जून_जुलय_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split(
                '_'
            ),
            format: 'जानेवारीच्या_फेब्रुवारीच्या_मार्चाच्या_एप्रीलाच्या_मेयाच्या_जूनाच्या_जुलयाच्या_ऑगस्टाच्या_सप्टेंबराच्या_ऑक्टोबराच्या_नोव्हेंबराच्या_डिसेंबराच्या'.split(
                '_'
            ),
            isFormat: /MMMM(\s)+D[oD]?/,
        },
        monthsShort: 'जाने._फेब्रु._मार्च_एप्री._मे_जून_जुल._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'आयतार_सोमार_मंगळार_बुधवार_बिरेस्तार_सुक्रार_शेनवार'.split('_'),
        weekdaysShort: 'आयत._सोम._मंगळ._बुध._ब्रेस्त._सुक्र._शेन.'.split('_'),
        weekdaysMin: 'आ_सो_मं_बु_ब्रे_सु_शे'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'A h:mm [वाजतां]',
            LTS: 'A h:mm:ss [वाजतां]',
            L: 'DD-MM-YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY A h:mm [वाजतां]',
            LLLL: 'dddd, MMMM Do, YYYY, A h:mm [वाजतां]',
            llll: 'ddd, D MMM YYYY, A h:mm [वाजतां]',
        },
        calendar: {
            sameDay: '[आयज] LT',
            nextDay: '[फाल्यां] LT',
            nextWeek: '[फुडलो] dddd[,] LT',
            lastDay: '[काल] LT',
            lastWeek: '[फाटलो] dddd[,] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s',
            past: '%s आदीं',
            s: processRelativeTime,
            ss: processRelativeTime,
            m: processRelativeTime,
            mm: processRelativeTime,
            h: processRelativeTime,
            hh: processRelativeTime,
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime,
        },
        dayOfMonthOrdinalParse: /\d{1,2}(वेर)/,
        ordinal: function (number, period) {
            switch (period) {
                // the ordinal 'वेर' only applies to day of the month
                case 'D':
                    return number + 'वेर';
                default:
                case 'M':
                case 'Q':
                case 'DDD':
                case 'd':
                case 'w':
                case 'W':
                    return number;
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week
            doy: 3, // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)
        },
        meridiemParse: /राती|सकाळीं|दनपारां|सांजे/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'राती') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'सकाळीं') {
                return hour;
            } else if (meridiem === 'दनपारां') {
                return hour > 12 ? hour : hour + 12;
            } else if (meridiem === 'सांजे') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'राती';
            } else if (hour < 12) {
                return 'सकाळीं';
            } else if (hour < 16) {
                return 'दनपारां';
            } else if (hour < 20) {
                return 'सांजे';
            } else {
                return 'राती';
            }
        },
    });

    return gomDeva;

})));


/***/ }),

/***/ "./node_modules/moment/locale/gom-latn.js":
/*!************************************************!*\
  !*** ./node_modules/moment/locale/gom-latn.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Konkani Latin script [gom-latn]
//! author : The Discoverer : https://github.com/WikiDiscoverer

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            s: ['thoddea sekondamni', 'thodde sekond'],
            ss: [number + ' sekondamni', number + ' sekond'],
            m: ['eka mintan', 'ek minut'],
            mm: [number + ' mintamni', number + ' mintam'],
            h: ['eka voran', 'ek vor'],
            hh: [number + ' voramni', number + ' voram'],
            d: ['eka disan', 'ek dis'],
            dd: [number + ' disamni', number + ' dis'],
            M: ['eka mhoinean', 'ek mhoino'],
            MM: [number + ' mhoineamni', number + ' mhoine'],
            y: ['eka vorsan', 'ek voros'],
            yy: [number + ' vorsamni', number + ' vorsam'],
        };
        return isFuture ? format[key][0] : format[key][1];
    }

    var gomLatn = moment.defineLocale('gom-latn', {
        months: {
            standalone: 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split(
                '_'
            ),
            format: 'Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea'.split(
                '_'
            ),
            isFormat: /MMMM(\s)+D[oD]?/,
        },
        monthsShort: 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split('_'),
        weekdaysShort: 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
        weekdaysMin: 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'A h:mm [vazta]',
            LTS: 'A h:mm:ss [vazta]',
            L: 'DD-MM-YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY A h:mm [vazta]',
            LLLL: 'dddd, MMMM Do, YYYY, A h:mm [vazta]',
            llll: 'ddd, D MMM YYYY, A h:mm [vazta]',
        },
        calendar: {
            sameDay: '[Aiz] LT',
            nextDay: '[Faleam] LT',
            nextWeek: '[Fuddlo] dddd[,] LT',
            lastDay: '[Kal] LT',
            lastWeek: '[Fattlo] dddd[,] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s',
            past: '%s adim',
            s: processRelativeTime,
            ss: processRelativeTime,
            m: processRelativeTime,
            mm: processRelativeTime,
            h: processRelativeTime,
            hh: processRelativeTime,
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime,
        },
        dayOfMonthOrdinalParse: /\d{1,2}(er)/,
        ordinal: function (number, period) {
            switch (period) {
                // the ordinal 'er' only applies to day of the month
                case 'D':
                    return number + 'er';
                default:
                case 'M':
                case 'Q':
                case 'DDD':
                case 'd':
                case 'w':
                case 'W':
                    return number;
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week
            doy: 3, // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)
        },
        meridiemParse: /rati|sokallim|donparam|sanje/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'rati') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'sokallim') {
                return hour;
            } else if (meridiem === 'donparam') {
                return hour > 12 ? hour : hour + 12;
            } else if (meridiem === 'sanje') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'rati';
            } else if (hour < 12) {
                return 'sokallim';
            } else if (hour < 16) {
                return 'donparam';
            } else if (hour < 20) {
                return 'sanje';
            } else {
                return 'rati';
            }
        },
    });

    return gomLatn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/gu.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/gu.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Gujarati [gu]
//! author : Kaushik Thanki : https://github.com/Kaushik1987

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            1: '૧',
            2: '૨',
            3: '૩',
            4: '૪',
            5: '૫',
            6: '૬',
            7: '૭',
            8: '૮',
            9: '૯',
            0: '૦',
        },
        numberMap = {
            '૧': '1',
            '૨': '2',
            '૩': '3',
            '૪': '4',
            '૫': '5',
            '૬': '6',
            '૭': '7',
            '૮': '8',
            '૯': '9',
            '૦': '0',
        };

    var gu = moment.defineLocale('gu', {
        months: 'જાન્યુઆરી_ફેબ્રુઆરી_માર્ચ_એપ્રિલ_મે_જૂન_જુલાઈ_ઑગસ્ટ_સપ્ટેમ્બર_ઑક્ટ્બર_નવેમ્બર_ડિસેમ્બર'.split(
            '_'
        ),
        monthsShort: 'જાન્યુ._ફેબ્રુ._માર્ચ_એપ્રિ._મે_જૂન_જુલા._ઑગ._સપ્ટે._ઑક્ટ્._નવે._ડિસે.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'રવિવાર_સોમવાર_મંગળવાર_બુધ્વાર_ગુરુવાર_શુક્રવાર_શનિવાર'.split(
            '_'
        ),
        weekdaysShort: 'રવિ_સોમ_મંગળ_બુધ્_ગુરુ_શુક્ર_શનિ'.split('_'),
        weekdaysMin: 'ર_સો_મં_બુ_ગુ_શુ_શ'.split('_'),
        longDateFormat: {
            LT: 'A h:mm વાગ્યે',
            LTS: 'A h:mm:ss વાગ્યે',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm વાગ્યે',
            LLLL: 'dddd, D MMMM YYYY, A h:mm વાગ્યે',
        },
        calendar: {
            sameDay: '[આજ] LT',
            nextDay: '[કાલે] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[ગઇકાલે] LT',
            lastWeek: '[પાછલા] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s મા',
            past: '%s પહેલા',
            s: 'અમુક પળો',
            ss: '%d સેકંડ',
            m: 'એક મિનિટ',
            mm: '%d મિનિટ',
            h: 'એક કલાક',
            hh: '%d કલાક',
            d: 'એક દિવસ',
            dd: '%d દિવસ',
            M: 'એક મહિનો',
            MM: '%d મહિનો',
            y: 'એક વર્ષ',
            yy: '%d વર્ષ',
        },
        preparse: function (string) {
            return string.replace(/[૧૨૩૪૫૬૭૮૯૦]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
        meridiemParse: /રાત|બપોર|સવાર|સાંજ/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'રાત') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'સવાર') {
                return hour;
            } else if (meridiem === 'બપોર') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'સાંજ') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'રાત';
            } else if (hour < 10) {
                return 'સવાર';
            } else if (hour < 17) {
                return 'બપોર';
            } else if (hour < 20) {
                return 'સાંજ';
            } else {
                return 'રાત';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return gu;

})));


/***/ }),

/***/ "./node_modules/moment/locale/he.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/he.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hebrew [he]
//! author : Tomer Cohen : https://github.com/tomer
//! author : Moshe Simantov : https://github.com/DevelopmentIL
//! author : Tal Ater : https://github.com/TalAter

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var he = moment.defineLocale('he', {
        months: 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split(
            '_'
        ),
        monthsShort: 'ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳'.split(
            '_'
        ),
        weekdays: 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
        weekdaysShort: 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
        weekdaysMin: 'א_ב_ג_ד_ה_ו_ש'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D [ב]MMMM YYYY',
            LLL: 'D [ב]MMMM YYYY HH:mm',
            LLLL: 'dddd, D [ב]MMMM YYYY HH:mm',
            l: 'D/M/YYYY',
            ll: 'D MMM YYYY',
            lll: 'D MMM YYYY HH:mm',
            llll: 'ddd, D MMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[היום ב־]LT',
            nextDay: '[מחר ב־]LT',
            nextWeek: 'dddd [בשעה] LT',
            lastDay: '[אתמול ב־]LT',
            lastWeek: '[ביום] dddd [האחרון בשעה] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'בעוד %s',
            past: 'לפני %s',
            s: 'מספר שניות',
            ss: '%d שניות',
            m: 'דקה',
            mm: '%d דקות',
            h: 'שעה',
            hh: function (number) {
                if (number === 2) {
                    return 'שעתיים';
                }
                return number + ' שעות';
            },
            d: 'יום',
            dd: function (number) {
                if (number === 2) {
                    return 'יומיים';
                }
                return number + ' ימים';
            },
            M: 'חודש',
            MM: function (number) {
                if (number === 2) {
                    return 'חודשיים';
                }
                return number + ' חודשים';
            },
            y: 'שנה',
            yy: function (number) {
                if (number === 2) {
                    return 'שנתיים';
                } else if (number % 10 === 0 && number !== 10) {
                    return number + ' שנה';
                }
                return number + ' שנים';
            },
        },
        meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
        isPM: function (input) {
            return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(input);
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 5) {
                return 'לפנות בוקר';
            } else if (hour < 10) {
                return 'בבוקר';
            } else if (hour < 12) {
                return isLower ? 'לפנה"צ' : 'לפני הצהריים';
            } else if (hour < 18) {
                return isLower ? 'אחה"צ' : 'אחרי הצהריים';
            } else {
                return 'בערב';
            }
        },
    });

    return he;

})));


/***/ }),

/***/ "./node_modules/moment/locale/hi.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/hi.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hindi [hi]
//! author : Mayank Singhal : https://github.com/mayanksinghal

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            1: '१',
            2: '२',
            3: '३',
            4: '४',
            5: '५',
            6: '६',
            7: '७',
            8: '८',
            9: '९',
            0: '०',
        },
        numberMap = {
            '१': '1',
            '२': '2',
            '३': '3',
            '४': '4',
            '५': '5',
            '६': '6',
            '७': '7',
            '८': '8',
            '९': '9',
            '०': '0',
        },
        monthsParse = [
            /^जन/i,
            /^फ़र|फर/i,
            /^मार्च/i,
            /^अप्रै/i,
            /^मई/i,
            /^जून/i,
            /^जुल/i,
            /^अग/i,
            /^सितं|सित/i,
            /^अक्टू/i,
            /^नव|नवं/i,
            /^दिसं|दिस/i,
        ],
        shortMonthsParse = [
            /^जन/i,
            /^फ़र/i,
            /^मार्च/i,
            /^अप्रै/i,
            /^मई/i,
            /^जून/i,
            /^जुल/i,
            /^अग/i,
            /^सित/i,
            /^अक्टू/i,
            /^नव/i,
            /^दिस/i,
        ];

    var hi = moment.defineLocale('hi', {
        months: {
            format: 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split(
                '_'
            ),
            standalone: 'जनवरी_फरवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितंबर_अक्टूबर_नवंबर_दिसंबर'.split(
                '_'
            ),
        },
        monthsShort: 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split(
            '_'
        ),
        weekdays: 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
        weekdaysShort: 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
        weekdaysMin: 'र_सो_मं_बु_गु_शु_श'.split('_'),
        longDateFormat: {
            LT: 'A h:mm बजे',
            LTS: 'A h:mm:ss बजे',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm बजे',
            LLLL: 'dddd, D MMMM YYYY, A h:mm बजे',
        },

        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: shortMonthsParse,

        monthsRegex: /^(जनवरी|जन\.?|फ़रवरी|फरवरी|फ़र\.?|मार्च?|अप्रैल|अप्रै\.?|मई?|जून?|जुलाई|जुल\.?|अगस्त|अग\.?|सितम्बर|सितंबर|सित\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर|नव\.?|दिसम्बर|दिसंबर|दिस\.?)/i,

        monthsShortRegex: /^(जनवरी|जन\.?|फ़रवरी|फरवरी|फ़र\.?|मार्च?|अप्रैल|अप्रै\.?|मई?|जून?|जुलाई|जुल\.?|अगस्त|अग\.?|सितम्बर|सितंबर|सित\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर|नव\.?|दिसम्बर|दिसंबर|दिस\.?)/i,

        monthsStrictRegex: /^(जनवरी?|फ़रवरी|फरवरी?|मार्च?|अप्रैल?|मई?|जून?|जुलाई?|अगस्त?|सितम्बर|सितंबर|सित?\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर?|दिसम्बर|दिसंबर?)/i,

        monthsShortStrictRegex: /^(जन\.?|फ़र\.?|मार्च?|अप्रै\.?|मई?|जून?|जुल\.?|अग\.?|सित\.?|अक्टू\.?|नव\.?|दिस\.?)/i,

        calendar: {
            sameDay: '[आज] LT',
            nextDay: '[कल] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[कल] LT',
            lastWeek: '[पिछले] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s में',
            past: '%s पहले',
            s: 'कुछ ही क्षण',
            ss: '%d सेकंड',
            m: 'एक मिनट',
            mm: '%d मिनट',
            h: 'एक घंटा',
            hh: '%d घंटे',
            d: 'एक दिन',
            dd: '%d दिन',
            M: 'एक महीने',
            MM: '%d महीने',
            y: 'एक वर्ष',
            yy: '%d वर्ष',
        },
        preparse: function (string) {
            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
        meridiemParse: /रात|सुबह|दोपहर|शाम/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'रात') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'सुबह') {
                return hour;
            } else if (meridiem === 'दोपहर') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'शाम') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'रात';
            } else if (hour < 10) {
                return 'सुबह';
            } else if (hour < 17) {
                return 'दोपहर';
            } else if (hour < 20) {
                return 'शाम';
            } else {
                return 'रात';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return hi;

})));


/***/ }),

/***/ "./node_modules/moment/locale/hr.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/hr.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Croatian [hr]
//! author : Bojan Marković : https://github.com/bmarkovic

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'ss':
                if (number === 1) {
                    result += 'sekunda';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sekunde';
                } else {
                    result += 'sekundi';
                }
                return result;
            case 'm':
                return withoutSuffix ? 'jedna minuta' : 'jedne minute';
            case 'mm':
                if (number === 1) {
                    result += 'minuta';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'minute';
                } else {
                    result += 'minuta';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'jedan sat' : 'jednog sata';
            case 'hh':
                if (number === 1) {
                    result += 'sat';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'sata';
                } else {
                    result += 'sati';
                }
                return result;
            case 'dd':
                if (number === 1) {
                    result += 'dan';
                } else {
                    result += 'dana';
                }
                return result;
            case 'MM':
                if (number === 1) {
                    result += 'mjesec';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'mjeseca';
                } else {
                    result += 'mjeseci';
                }
                return result;
            case 'yy':
                if (number === 1) {
                    result += 'godina';
                } else if (number === 2 || number === 3 || number === 4) {
                    result += 'godine';
                } else {
                    result += 'godina';
                }
                return result;
        }
    }

    var hr = moment.defineLocale('hr', {
        months: {
            format: 'siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split(
                '_'
            ),
            standalone: 'siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split(
                '_'
            ),
        },
        monthsShort: 'sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split(
            '_'
        ),
        weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'Do MMMM YYYY',
            LLL: 'Do MMMM YYYY H:mm',
            LLLL: 'dddd, Do MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay: '[jučer u] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[prošlu] [nedjelju] [u] LT';
                    case 3:
                        return '[prošlu] [srijedu] [u] LT';
                    case 6:
                        return '[prošle] [subote] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[prošli] dddd [u] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'za %s',
            past: 'prije %s',
            s: 'par sekundi',
            ss: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: 'dan',
            dd: translate,
            M: 'mjesec',
            MM: translate,
            y: 'godinu',
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return hr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/hu.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/hu.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hungarian [hu]
//! author : Adam Brunner : https://github.com/adambrunner
//! author : Peter Viszt  : https://github.com/passatgt

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(
        ' '
    );
    function translate(number, withoutSuffix, key, isFuture) {
        var num = number;
        switch (key) {
            case 's':
                return isFuture || withoutSuffix
                    ? 'néhány másodperc'
                    : 'néhány másodperce';
            case 'ss':
                return num + (isFuture || withoutSuffix)
                    ? ' másodperc'
                    : ' másodperce';
            case 'm':
                return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
            case 'mm':
                return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
            case 'h':
                return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája');
            case 'hh':
                return num + (isFuture || withoutSuffix ? ' óra' : ' órája');
            case 'd':
                return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
            case 'dd':
                return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
            case 'M':
                return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
            case 'MM':
                return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
            case 'y':
                return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve');
            case 'yy':
                return num + (isFuture || withoutSuffix ? ' év' : ' éve');
        }
        return '';
    }
    function week(isFuture) {
        return (
            (isFuture ? '' : '[múlt] ') +
            '[' +
            weekEndings[this.day()] +
            '] LT[-kor]'
        );
    }

    var hu = moment.defineLocale('hu', {
        months: 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split(
            '_'
        ),
        monthsShort: 'jan._feb._márc._ápr._máj._jún._júl._aug._szept._okt._nov._dec.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
        weekdaysShort: 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
        weekdaysMin: 'v_h_k_sze_cs_p_szo'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'YYYY.MM.DD.',
            LL: 'YYYY. MMMM D.',
            LLL: 'YYYY. MMMM D. H:mm',
            LLLL: 'YYYY. MMMM D., dddd H:mm',
        },
        meridiemParse: /de|du/i,
        isPM: function (input) {
            return input.charAt(1).toLowerCase() === 'u';
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower === true ? 'de' : 'DE';
            } else {
                return isLower === true ? 'du' : 'DU';
            }
        },
        calendar: {
            sameDay: '[ma] LT[-kor]',
            nextDay: '[holnap] LT[-kor]',
            nextWeek: function () {
                return week.call(this, true);
            },
            lastDay: '[tegnap] LT[-kor]',
            lastWeek: function () {
                return week.call(this, false);
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s múlva',
            past: '%s',
            s: translate,
            ss: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: translate,
            dd: translate,
            M: translate,
            MM: translate,
            y: translate,
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return hu;

})));


/***/ }),

/***/ "./node_modules/moment/locale/hy-am.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/hy-am.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Armenian [hy-am]
//! author : Armendarabyan : https://github.com/armendarabyan

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var hyAm = moment.defineLocale('hy-am', {
        months: {
            format: 'հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի'.split(
                '_'
            ),
            standalone: 'հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր'.split(
                '_'
            ),
        },
        monthsShort: 'հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ'.split('_'),
        weekdays: 'կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ'.split(
            '_'
        ),
        weekdaysShort: 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
        weekdaysMin: 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY թ.',
            LLL: 'D MMMM YYYY թ., HH:mm',
            LLLL: 'dddd, D MMMM YYYY թ., HH:mm',
        },
        calendar: {
            sameDay: '[այսօր] LT',
            nextDay: '[վաղը] LT',
            lastDay: '[երեկ] LT',
            nextWeek: function () {
                return 'dddd [օրը ժամը] LT';
            },
            lastWeek: function () {
                return '[անցած] dddd [օրը ժամը] LT';
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s հետո',
            past: '%s առաջ',
            s: 'մի քանի վայրկյան',
            ss: '%d վայրկյան',
            m: 'րոպե',
            mm: '%d րոպե',
            h: 'ժամ',
            hh: '%d ժամ',
            d: 'օր',
            dd: '%d օր',
            M: 'ամիս',
            MM: '%d ամիս',
            y: 'տարի',
            yy: '%d տարի',
        },
        meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
        isPM: function (input) {
            return /^(ցերեկվա|երեկոյան)$/.test(input);
        },
        meridiem: function (hour) {
            if (hour < 4) {
                return 'գիշերվա';
            } else if (hour < 12) {
                return 'առավոտվա';
            } else if (hour < 17) {
                return 'ցերեկվա';
            } else {
                return 'երեկոյան';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'DDD':
                case 'w':
                case 'W':
                case 'DDDo':
                    if (number === 1) {
                        return number + '-ին';
                    }
                    return number + '-րդ';
                default:
                    return number;
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return hyAm;

})));


/***/ }),

/***/ "./node_modules/moment/locale/id.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/id.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Indonesian [id]
//! author : Mohammad Satrio Utomo : https://github.com/tyok
//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var id = moment.defineLocale('id', {
        months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
        weekdays: 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
        weekdaysShort: 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
        weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [pukul] HH.mm',
            LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'siang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sore' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'siang';
            } else if (hours < 19) {
                return 'sore';
            } else {
                return 'malam';
            }
        },
        calendar: {
            sameDay: '[Hari ini pukul] LT',
            nextDay: '[Besok pukul] LT',
            nextWeek: 'dddd [pukul] LT',
            lastDay: '[Kemarin pukul] LT',
            lastWeek: 'dddd [lalu pukul] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'dalam %s',
            past: '%s yang lalu',
            s: 'beberapa detik',
            ss: '%d detik',
            m: 'semenit',
            mm: '%d menit',
            h: 'sejam',
            hh: '%d jam',
            d: 'sehari',
            dd: '%d hari',
            M: 'sebulan',
            MM: '%d bulan',
            y: 'setahun',
            yy: '%d tahun',
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return id;

})));


/***/ }),

/***/ "./node_modules/moment/locale/is.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/is.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Icelandic [is]
//! author : Hinrik Örn Sigurðsson : https://github.com/hinrik

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function plural(n) {
        if (n % 100 === 11) {
            return true;
        } else if (n % 10 === 1) {
            return false;
        }
        return true;
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':
                return withoutSuffix || isFuture
                    ? 'nokkrar sekúndur'
                    : 'nokkrum sekúndum';
            case 'ss':
                if (plural(number)) {
                    return (
                        result +
                        (withoutSuffix || isFuture ? 'sekúndur' : 'sekúndum')
                    );
                }
                return result + 'sekúnda';
            case 'm':
                return withoutSuffix ? 'mínúta' : 'mínútu';
            case 'mm':
                if (plural(number)) {
                    return (
                        result + (withoutSuffix || isFuture ? 'mínútur' : 'mínútum')
                    );
                } else if (withoutSuffix) {
                    return result + 'mínúta';
                }
                return result + 'mínútu';
            case 'hh':
                if (plural(number)) {
                    return (
                        result +
                        (withoutSuffix || isFuture
                            ? 'klukkustundir'
                            : 'klukkustundum')
                    );
                }
                return result + 'klukkustund';
            case 'd':
                if (withoutSuffix) {
                    return 'dagur';
                }
                return isFuture ? 'dag' : 'degi';
            case 'dd':
                if (plural(number)) {
                    if (withoutSuffix) {
                        return result + 'dagar';
                    }
                    return result + (isFuture ? 'daga' : 'dögum');
                } else if (withoutSuffix) {
                    return result + 'dagur';
                }
                return result + (isFuture ? 'dag' : 'degi');
            case 'M':
                if (withoutSuffix) {
                    return 'mánuður';
                }
                return isFuture ? 'mánuð' : 'mánuði';
            case 'MM':
                if (plural(number)) {
                    if (withoutSuffix) {
                        return result + 'mánuðir';
                    }
                    return result + (isFuture ? 'mánuði' : 'mánuðum');
                } else if (withoutSuffix) {
                    return result + 'mánuður';
                }
                return result + (isFuture ? 'mánuð' : 'mánuði');
            case 'y':
                return withoutSuffix || isFuture ? 'ár' : 'ári';
            case 'yy':
                if (plural(number)) {
                    return result + (withoutSuffix || isFuture ? 'ár' : 'árum');
                }
                return result + (withoutSuffix || isFuture ? 'ár' : 'ári');
        }
    }

    var is = moment.defineLocale('is', {
        months: 'janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember'.split(
            '_'
        ),
        monthsShort: 'jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des'.split('_'),
        weekdays: 'sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur'.split(
            '_'
        ),
        weekdaysShort: 'sun_mán_þri_mið_fim_fös_lau'.split('_'),
        weekdaysMin: 'Su_Má_Þr_Mi_Fi_Fö_La'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY [kl.] H:mm',
            LLLL: 'dddd, D. MMMM YYYY [kl.] H:mm',
        },
        calendar: {
            sameDay: '[í dag kl.] LT',
            nextDay: '[á morgun kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[í gær kl.] LT',
            lastWeek: '[síðasta] dddd [kl.] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'eftir %s',
            past: 'fyrir %s síðan',
            s: translate,
            ss: translate,
            m: translate,
            mm: translate,
            h: 'klukkustund',
            hh: translate,
            d: translate,
            dd: translate,
            M: translate,
            MM: translate,
            y: translate,
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return is;

})));


/***/ }),

/***/ "./node_modules/moment/locale/it-ch.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/it-ch.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Italian (Switzerland) [it-ch]
//! author : xfh : https://github.com/xfh

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var itCh = moment.defineLocale('it-ch', {
        months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split(
            '_'
        ),
        monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays: 'domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato'.split(
            '_'
        ),
        weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
        weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Oggi alle] LT',
            nextDay: '[Domani alle] LT',
            nextWeek: 'dddd [alle] LT',
            lastDay: '[Ieri alle] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[la scorsa] dddd [alle] LT';
                    default:
                        return '[lo scorso] dddd [alle] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: function (s) {
                return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s;
            },
            past: '%s fa',
            s: 'alcuni secondi',
            ss: '%d secondi',
            m: 'un minuto',
            mm: '%d minuti',
            h: "un'ora",
            hh: '%d ore',
            d: 'un giorno',
            dd: '%d giorni',
            M: 'un mese',
            MM: '%d mesi',
            y: 'un anno',
            yy: '%d anni',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return itCh;

})));


/***/ }),

/***/ "./node_modules/moment/locale/it.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/it.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Italian [it]
//! author : Lorenzo : https://github.com/aliem
//! author: Mattia Larentis: https://github.com/nostalgiaz
//! author: Marco : https://github.com/Manfre98

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var it = moment.defineLocale('it', {
        months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split(
            '_'
        ),
        monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays: 'domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato'.split(
            '_'
        ),
        weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
        weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: function () {
                return (
                    '[Oggi a' +
                    (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                    ']LT'
                );
            },
            nextDay: function () {
                return (
                    '[Domani a' +
                    (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                    ']LT'
                );
            },
            nextWeek: function () {
                return (
                    'dddd [a' +
                    (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                    ']LT'
                );
            },
            lastDay: function () {
                return (
                    '[Ieri a' +
                    (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") +
                    ']LT'
                );
            },
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return (
                            '[La scorsa] dddd [a' +
                            (this.hours() > 1
                                ? 'lle '
                                : this.hours() === 0
                                ? ' '
                                : "ll'") +
                            ']LT'
                        );
                    default:
                        return (
                            '[Lo scorso] dddd [a' +
                            (this.hours() > 1
                                ? 'lle '
                                : this.hours() === 0
                                ? ' '
                                : "ll'") +
                            ']LT'
                        );
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'tra %s',
            past: '%s fa',
            s: 'alcuni secondi',
            ss: '%d secondi',
            m: 'un minuto',
            mm: '%d minuti',
            h: "un'ora",
            hh: '%d ore',
            d: 'un giorno',
            dd: '%d giorni',
            w: 'una settimana',
            ww: '%d settimane',
            M: 'un mese',
            MM: '%d mesi',
            y: 'un anno',
            yy: '%d anni',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return it;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ja.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ja.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Japanese [ja]
//! author : LI Long : https://github.com/baryon

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ja = moment.defineLocale('ja', {
        eras: [
            {
                since: '2019-05-01',
                offset: 1,
                name: '令和',
                narrow: '㋿',
                abbr: 'R',
            },
            {
                since: '1989-01-08',
                until: '2019-04-30',
                offset: 1,
                name: '平成',
                narrow: '㍻',
                abbr: 'H',
            },
            {
                since: '1926-12-25',
                until: '1989-01-07',
                offset: 1,
                name: '昭和',
                narrow: '㍼',
                abbr: 'S',
            },
            {
                since: '1912-07-30',
                until: '1926-12-24',
                offset: 1,
                name: '大正',
                narrow: '㍽',
                abbr: 'T',
            },
            {
                since: '1873-01-01',
                until: '1912-07-29',
                offset: 6,
                name: '明治',
                narrow: '㍾',
                abbr: 'M',
            },
            {
                since: '0001-01-01',
                until: '1873-12-31',
                offset: 1,
                name: '西暦',
                narrow: 'AD',
                abbr: 'AD',
            },
            {
                since: '0000-12-31',
                until: -Infinity,
                offset: 1,
                name: '紀元前',
                narrow: 'BC',
                abbr: 'BC',
            },
        ],
        eraYearOrdinalRegex: /(元|\d+)年/,
        eraYearOrdinalParse: function (input, match) {
            return match[1] === '元' ? 1 : parseInt(match[1] || input, 10);
        },
        months: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split(
            '_'
        ),
        weekdays: '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
        weekdaysShort: '日_月_火_水_木_金_土'.split('_'),
        weekdaysMin: '日_月_火_水_木_金_土'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY/MM/DD',
            LL: 'YYYY年M月D日',
            LLL: 'YYYY年M月D日 HH:mm',
            LLLL: 'YYYY年M月D日 dddd HH:mm',
            l: 'YYYY/MM/DD',
            ll: 'YYYY年M月D日',
            lll: 'YYYY年M月D日 HH:mm',
            llll: 'YYYY年M月D日(ddd) HH:mm',
        },
        meridiemParse: /午前|午後/i,
        isPM: function (input) {
            return input === '午後';
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return '午前';
            } else {
                return '午後';
            }
        },
        calendar: {
            sameDay: '[今日] LT',
            nextDay: '[明日] LT',
            nextWeek: function (now) {
                if (now.week() !== this.week()) {
                    return '[来週]dddd LT';
                } else {
                    return 'dddd LT';
                }
            },
            lastDay: '[昨日] LT',
            lastWeek: function (now) {
                if (this.week() !== now.week()) {
                    return '[先週]dddd LT';
                } else {
                    return 'dddd LT';
                }
            },
            sameElse: 'L',
        },
        dayOfMonthOrdinalParse: /\d{1,2}日/,
        ordinal: function (number, period) {
            switch (period) {
                case 'y':
                    return number === 1 ? '元年' : number + '年';
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '日';
                default:
                    return number;
            }
        },
        relativeTime: {
            future: '%s後',
            past: '%s前',
            s: '数秒',
            ss: '%d秒',
            m: '1分',
            mm: '%d分',
            h: '1時間',
            hh: '%d時間',
            d: '1日',
            dd: '%d日',
            M: '1ヶ月',
            MM: '%dヶ月',
            y: '1年',
            yy: '%d年',
        },
    });

    return ja;

})));


/***/ }),

/***/ "./node_modules/moment/locale/jv.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/jv.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Javanese [jv]
//! author : Rony Lantip : https://github.com/lantip
//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var jv = moment.defineLocale('jv', {
        months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
        weekdays: 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
        weekdaysShort: 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
        weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [pukul] HH.mm',
            LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
        },
        meridiemParse: /enjing|siyang|sonten|ndalu/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'enjing') {
                return hour;
            } else if (meridiem === 'siyang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
                return hour + 12;
            }
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'enjing';
            } else if (hours < 15) {
                return 'siyang';
            } else if (hours < 19) {
                return 'sonten';
            } else {
                return 'ndalu';
            }
        },
        calendar: {
            sameDay: '[Dinten puniko pukul] LT',
            nextDay: '[Mbenjang pukul] LT',
            nextWeek: 'dddd [pukul] LT',
            lastDay: '[Kala wingi pukul] LT',
            lastWeek: 'dddd [kepengker pukul] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'wonten ing %s',
            past: '%s ingkang kepengker',
            s: 'sawetawis detik',
            ss: '%d detik',
            m: 'setunggal menit',
            mm: '%d menit',
            h: 'setunggal jam',
            hh: '%d jam',
            d: 'sedinten',
            dd: '%d dinten',
            M: 'sewulan',
            MM: '%d wulan',
            y: 'setaun',
            yy: '%d taun',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return jv;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ka.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ka.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Georgian [ka]
//! author : Irakli Janiashvili : https://github.com/IrakliJani

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ka = moment.defineLocale('ka', {
        months: 'იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი'.split(
            '_'
        ),
        monthsShort: 'იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ'.split('_'),
        weekdays: {
            standalone: 'კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი'.split(
                '_'
            ),
            format: 'კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს'.split(
                '_'
            ),
            isFormat: /(წინა|შემდეგ)/,
        },
        weekdaysShort: 'კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ'.split('_'),
        weekdaysMin: 'კვ_ორ_სა_ოთ_ხუ_პა_შა'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[დღეს] LT[-ზე]',
            nextDay: '[ხვალ] LT[-ზე]',
            lastDay: '[გუშინ] LT[-ზე]',
            nextWeek: '[შემდეგ] dddd LT[-ზე]',
            lastWeek: '[წინა] dddd LT-ზე',
            sameElse: 'L',
        },
        relativeTime: {
            future: function (s) {
                return s.replace(/(წამ|წუთ|საათ|წელ|დღ|თვ)(ი|ე)/, function (
                    $0,
                    $1,
                    $2
                ) {
                    return $2 === 'ი' ? $1 + 'ში' : $1 + $2 + 'ში';
                });
            },
            past: function (s) {
                if (/(წამი|წუთი|საათი|დღე|თვე)/.test(s)) {
                    return s.replace(/(ი|ე)$/, 'ის წინ');
                }
                if (/წელი/.test(s)) {
                    return s.replace(/წელი$/, 'წლის წინ');
                }
                return s;
            },
            s: 'რამდენიმე წამი',
            ss: '%d წამი',
            m: 'წუთი',
            mm: '%d წუთი',
            h: 'საათი',
            hh: '%d საათი',
            d: 'დღე',
            dd: '%d დღე',
            M: 'თვე',
            MM: '%d თვე',
            y: 'წელი',
            yy: '%d წელი',
        },
        dayOfMonthOrdinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
        ordinal: function (number) {
            if (number === 0) {
                return number;
            }
            if (number === 1) {
                return number + '-ლი';
            }
            if (
                number < 20 ||
                (number <= 100 && number % 20 === 0) ||
                number % 100 === 0
            ) {
                return 'მე-' + number;
            }
            return number + '-ე';
        },
        week: {
            dow: 1,
            doy: 7,
        },
    });

    return ka;

})));


/***/ }),

/***/ "./node_modules/moment/locale/kk.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/kk.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kazakh [kk]
//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var suffixes = {
        0: '-ші',
        1: '-ші',
        2: '-ші',
        3: '-ші',
        4: '-ші',
        5: '-ші',
        6: '-шы',
        7: '-ші',
        8: '-ші',
        9: '-шы',
        10: '-шы',
        20: '-шы',
        30: '-шы',
        40: '-шы',
        50: '-ші',
        60: '-шы',
        70: '-ші',
        80: '-ші',
        90: '-шы',
        100: '-ші',
    };

    var kk = moment.defineLocale('kk', {
        months: 'қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан'.split(
            '_'
        ),
        monthsShort: 'қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел'.split('_'),
        weekdays: 'жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі'.split(
            '_'
        ),
        weekdaysShort: 'жек_дүй_сей_сәр_бей_жұм_сен'.split('_'),
        weekdaysMin: 'жк_дй_сй_ср_бй_жм_сн'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Бүгін сағат] LT',
            nextDay: '[Ертең сағат] LT',
            nextWeek: 'dddd [сағат] LT',
            lastDay: '[Кеше сағат] LT',
            lastWeek: '[Өткен аптаның] dddd [сағат] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s ішінде',
            past: '%s бұрын',
            s: 'бірнеше секунд',
            ss: '%d секунд',
            m: 'бір минут',
            mm: '%d минут',
            h: 'бір сағат',
            hh: '%d сағат',
            d: 'бір күн',
            dd: '%d күн',
            M: 'бір ай',
            MM: '%d ай',
            y: 'бір жыл',
            yy: '%d жыл',
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ші|шы)/,
        ordinal: function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return kk;

})));


/***/ }),

/***/ "./node_modules/moment/locale/km.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/km.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Cambodian [km]
//! author : Kruy Vanna : https://github.com/kruyvanna

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            1: '១',
            2: '២',
            3: '៣',
            4: '៤',
            5: '៥',
            6: '៦',
            7: '៧',
            8: '៨',
            9: '៩',
            0: '០',
        },
        numberMap = {
            '១': '1',
            '២': '2',
            '៣': '3',
            '៤': '4',
            '៥': '5',
            '៦': '6',
            '៧': '7',
            '៨': '8',
            '៩': '9',
            '០': '0',
        };

    var km = moment.defineLocale('km', {
        months: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split(
            '_'
        ),
        monthsShort: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split(
            '_'
        ),
        weekdays: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
        weekdaysShort: 'អា_ច_អ_ព_ព្រ_សុ_ស'.split('_'),
        weekdaysMin: 'អា_ច_អ_ព_ព្រ_សុ_ស'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        meridiemParse: /ព្រឹក|ល្ងាច/,
        isPM: function (input) {
            return input === 'ល្ងាច';
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ព្រឹក';
            } else {
                return 'ល្ងាច';
            }
        },
        calendar: {
            sameDay: '[ថ្ងៃនេះ ម៉ោង] LT',
            nextDay: '[ស្អែក ម៉ោង] LT',
            nextWeek: 'dddd [ម៉ោង] LT',
            lastDay: '[ម្សិលមិញ ម៉ោង] LT',
            lastWeek: 'dddd [សប្តាហ៍មុន] [ម៉ោង] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%sទៀត',
            past: '%sមុន',
            s: 'ប៉ុន្មានវិនាទី',
            ss: '%d វិនាទី',
            m: 'មួយនាទី',
            mm: '%d នាទី',
            h: 'មួយម៉ោង',
            hh: '%d ម៉ោង',
            d: 'មួយថ្ងៃ',
            dd: '%d ថ្ងៃ',
            M: 'មួយខែ',
            MM: '%d ខែ',
            y: 'មួយឆ្នាំ',
            yy: '%d ឆ្នាំ',
        },
        dayOfMonthOrdinalParse: /ទី\d{1,2}/,
        ordinal: 'ទី%d',
        preparse: function (string) {
            return string.replace(/[១២៣៤៥៦៧៨៩០]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return km;

})));


/***/ }),

/***/ "./node_modules/moment/locale/kn.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/kn.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kannada [kn]
//! author : Rajeev Naik : https://github.com/rajeevnaikte

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            1: '೧',
            2: '೨',
            3: '೩',
            4: '೪',
            5: '೫',
            6: '೬',
            7: '೭',
            8: '೮',
            9: '೯',
            0: '೦',
        },
        numberMap = {
            '೧': '1',
            '೨': '2',
            '೩': '3',
            '೪': '4',
            '೫': '5',
            '೬': '6',
            '೭': '7',
            '೮': '8',
            '೯': '9',
            '೦': '0',
        };

    var kn = moment.defineLocale('kn', {
        months: 'ಜನವರಿ_ಫೆಬ್ರವರಿ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬರ್_ಅಕ್ಟೋಬರ್_ನವೆಂಬರ್_ಡಿಸೆಂಬರ್'.split(
            '_'
        ),
        monthsShort: 'ಜನ_ಫೆಬ್ರ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂ_ಅಕ್ಟೋ_ನವೆಂ_ಡಿಸೆಂ'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'ಭಾನುವಾರ_ಸೋಮವಾರ_ಮಂಗಳವಾರ_ಬುಧವಾರ_ಗುರುವಾರ_ಶುಕ್ರವಾರ_ಶನಿವಾರ'.split(
            '_'
        ),
        weekdaysShort: 'ಭಾನು_ಸೋಮ_ಮಂಗಳ_ಬುಧ_ಗುರು_ಶುಕ್ರ_ಶನಿ'.split('_'),
        weekdaysMin: 'ಭಾ_ಸೋ_ಮಂ_ಬು_ಗು_ಶು_ಶ'.split('_'),
        longDateFormat: {
            LT: 'A h:mm',
            LTS: 'A h:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm',
            LLLL: 'dddd, D MMMM YYYY, A h:mm',
        },
        calendar: {
            sameDay: '[ಇಂದು] LT',
            nextDay: '[ನಾಳೆ] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[ನಿನ್ನೆ] LT',
            lastWeek: '[ಕೊನೆಯ] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s ನಂತರ',
            past: '%s ಹಿಂದೆ',
            s: 'ಕೆಲವು ಕ್ಷಣಗಳು',
            ss: '%d ಸೆಕೆಂಡುಗಳು',
            m: 'ಒಂದು ನಿಮಿಷ',
            mm: '%d ನಿಮಿಷ',
            h: 'ಒಂದು ಗಂಟೆ',
            hh: '%d ಗಂಟೆ',
            d: 'ಒಂದು ದಿನ',
            dd: '%d ದಿನ',
            M: 'ಒಂದು ತಿಂಗಳು',
            MM: '%d ತಿಂಗಳು',
            y: 'ಒಂದು ವರ್ಷ',
            yy: '%d ವರ್ಷ',
        },
        preparse: function (string) {
            return string.replace(/[೧೨೩೪೫೬೭೮೯೦]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /ರಾತ್ರಿ|ಬೆಳಿಗ್ಗೆ|ಮಧ್ಯಾಹ್ನ|ಸಂಜೆ/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'ರಾತ್ರಿ') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'ಬೆಳಿಗ್ಗೆ') {
                return hour;
            } else if (meridiem === 'ಮಧ್ಯಾಹ್ನ') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'ಸಂಜೆ') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ರಾತ್ರಿ';
            } else if (hour < 10) {
                return 'ಬೆಳಿಗ್ಗೆ';
            } else if (hour < 17) {
                return 'ಮಧ್ಯಾಹ್ನ';
            } else if (hour < 20) {
                return 'ಸಂಜೆ';
            } else {
                return 'ರಾತ್ರಿ';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ನೇ)/,
        ordinal: function (number) {
            return number + 'ನೇ';
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return kn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ko.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ko.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Korean [ko]
//! author : Kyungwook, Park : https://github.com/kyungw00k
//! author : Jeeeyul Lee <jeeeyul@gmail.com>

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ko = moment.defineLocale('ko', {
        months: '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
        monthsShort: '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split(
            '_'
        ),
        weekdays: '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
        weekdaysShort: '일_월_화_수_목_금_토'.split('_'),
        weekdaysMin: '일_월_화_수_목_금_토'.split('_'),
        longDateFormat: {
            LT: 'A h:mm',
            LTS: 'A h:mm:ss',
            L: 'YYYY.MM.DD.',
            LL: 'YYYY년 MMMM D일',
            LLL: 'YYYY년 MMMM D일 A h:mm',
            LLLL: 'YYYY년 MMMM D일 dddd A h:mm',
            l: 'YYYY.MM.DD.',
            ll: 'YYYY년 MMMM D일',
            lll: 'YYYY년 MMMM D일 A h:mm',
            llll: 'YYYY년 MMMM D일 dddd A h:mm',
        },
        calendar: {
            sameDay: '오늘 LT',
            nextDay: '내일 LT',
            nextWeek: 'dddd LT',
            lastDay: '어제 LT',
            lastWeek: '지난주 dddd LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s 후',
            past: '%s 전',
            s: '몇 초',
            ss: '%d초',
            m: '1분',
            mm: '%d분',
            h: '한 시간',
            hh: '%d시간',
            d: '하루',
            dd: '%d일',
            M: '한 달',
            MM: '%d달',
            y: '일 년',
            yy: '%d년',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(일|월|주)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '일';
                case 'M':
                    return number + '월';
                case 'w':
                case 'W':
                    return number + '주';
                default:
                    return number;
            }
        },
        meridiemParse: /오전|오후/,
        isPM: function (token) {
            return token === '오후';
        },
        meridiem: function (hour, minute, isUpper) {
            return hour < 12 ? '오전' : '오후';
        },
    });

    return ko;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ku.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ku.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kurdish [ku]
//! author : Shahram Mebashar : https://github.com/ShahramMebashar

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            1: '١',
            2: '٢',
            3: '٣',
            4: '٤',
            5: '٥',
            6: '٦',
            7: '٧',
            8: '٨',
            9: '٩',
            0: '٠',
        },
        numberMap = {
            '١': '1',
            '٢': '2',
            '٣': '3',
            '٤': '4',
            '٥': '5',
            '٦': '6',
            '٧': '7',
            '٨': '8',
            '٩': '9',
            '٠': '0',
        },
        months = [
            'کانونی دووەم',
            'شوبات',
            'ئازار',
            'نیسان',
            'ئایار',
            'حوزەیران',
            'تەمموز',
            'ئاب',
            'ئەیلوول',
            'تشرینی یەكەم',
            'تشرینی دووەم',
            'كانونی یەکەم',
        ];

    var ku = moment.defineLocale('ku', {
        months: months,
        monthsShort: months,
        weekdays: 'یه‌كشه‌ممه‌_دووشه‌ممه‌_سێشه‌ممه‌_چوارشه‌ممه‌_پێنجشه‌ممه‌_هه‌ینی_شه‌ممه‌'.split(
            '_'
        ),
        weekdaysShort: 'یه‌كشه‌م_دووشه‌م_سێشه‌م_چوارشه‌م_پێنجشه‌م_هه‌ینی_شه‌ممه‌'.split(
            '_'
        ),
        weekdaysMin: 'ی_د_س_چ_پ_ه_ش'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        meridiemParse: /ئێواره‌|به‌یانی/,
        isPM: function (input) {
            return /ئێواره‌/.test(input);
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'به‌یانی';
            } else {
                return 'ئێواره‌';
            }
        },
        calendar: {
            sameDay: '[ئه‌مرۆ كاتژمێر] LT',
            nextDay: '[به‌یانی كاتژمێر] LT',
            nextWeek: 'dddd [كاتژمێر] LT',
            lastDay: '[دوێنێ كاتژمێر] LT',
            lastWeek: 'dddd [كاتژمێر] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'له‌ %s',
            past: '%s',
            s: 'چه‌ند چركه‌یه‌ك',
            ss: 'چركه‌ %d',
            m: 'یه‌ك خوله‌ك',
            mm: '%d خوله‌ك',
            h: 'یه‌ك كاتژمێر',
            hh: '%d كاتژمێر',
            d: 'یه‌ك ڕۆژ',
            dd: '%d ڕۆژ',
            M: 'یه‌ك مانگ',
            MM: '%d مانگ',
            y: 'یه‌ك ساڵ',
            yy: '%d ساڵ',
        },
        preparse: function (string) {
            return string
                .replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
                    return numberMap[match];
                })
                .replace(/،/g, ',');
        },
        postformat: function (string) {
            return string
                .replace(/\d/g, function (match) {
                    return symbolMap[match];
                })
                .replace(/,/g, '،');
        },
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12, // The week that contains Jan 12th is the first week of the year.
        },
    });

    return ku;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ky.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ky.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kyrgyz [ky]
//! author : Chyngyz Arystan uulu : https://github.com/chyngyz

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var suffixes = {
        0: '-чү',
        1: '-чи',
        2: '-чи',
        3: '-чү',
        4: '-чү',
        5: '-чи',
        6: '-чы',
        7: '-чи',
        8: '-чи',
        9: '-чу',
        10: '-чу',
        20: '-чы',
        30: '-чу',
        40: '-чы',
        50: '-чү',
        60: '-чы',
        70: '-чи',
        80: '-чи',
        90: '-чу',
        100: '-чү',
    };

    var ky = moment.defineLocale('ky', {
        months: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split(
            '_'
        ),
        monthsShort: 'янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split(
            '_'
        ),
        weekdays: 'Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби'.split(
            '_'
        ),
        weekdaysShort: 'Жек_Дүй_Шей_Шар_Бей_Жум_Ише'.split('_'),
        weekdaysMin: 'Жк_Дй_Шй_Шр_Бй_Жм_Иш'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Бүгүн саат] LT',
            nextDay: '[Эртең саат] LT',
            nextWeek: 'dddd [саат] LT',
            lastDay: '[Кечээ саат] LT',
            lastWeek: '[Өткөн аптанын] dddd [күнү] [саат] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s ичинде',
            past: '%s мурун',
            s: 'бирнече секунд',
            ss: '%d секунд',
            m: 'бир мүнөт',
            mm: '%d мүнөт',
            h: 'бир саат',
            hh: '%d саат',
            d: 'бир күн',
            dd: '%d күн',
            M: 'бир ай',
            MM: '%d ай',
            y: 'бир жыл',
            yy: '%d жыл',
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
        ordinal: function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return ky;

})));


/***/ }),

/***/ "./node_modules/moment/locale/lb.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/lb.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Luxembourgish [lb]
//! author : mweimerskirch : https://github.com/mweimerskirch
//! author : David Raison : https://github.com/kwisatz

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            m: ['eng Minutt', 'enger Minutt'],
            h: ['eng Stonn', 'enger Stonn'],
            d: ['een Dag', 'engem Dag'],
            M: ['ee Mount', 'engem Mount'],
            y: ['ee Joer', 'engem Joer'],
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processFutureTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'a ' + string;
        }
        return 'an ' + string;
    }
    function processPastTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'viru ' + string;
        }
        return 'virun ' + string;
    }
    /**
     * Returns true if the word before the given number loses the '-n' ending.
     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
     *
     * @param number {integer}
     * @returns {boolean}
     */
    function eifelerRegelAppliesToNumber(number) {
        number = parseInt(number, 10);
        if (isNaN(number)) {
            return false;
        }
        if (number < 0) {
            // Negative Number --> always true
            return true;
        } else if (number < 10) {
            // Only 1 digit
            if (4 <= number && number <= 7) {
                return true;
            }
            return false;
        } else if (number < 100) {
            // 2 digits
            var lastDigit = number % 10,
                firstDigit = number / 10;
            if (lastDigit === 0) {
                return eifelerRegelAppliesToNumber(firstDigit);
            }
            return eifelerRegelAppliesToNumber(lastDigit);
        } else if (number < 10000) {
            // 3 or 4 digits --> recursively check first digit
            while (number >= 10) {
                number = number / 10;
            }
            return eifelerRegelAppliesToNumber(number);
        } else {
            // Anything larger than 4 digits: recursively check first n-3 digits
            number = number / 1000;
            return eifelerRegelAppliesToNumber(number);
        }
    }

    var lb = moment.defineLocale('lb', {
        months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split(
            '_'
        ),
        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split(
            '_'
        ),
        weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm [Auer]',
            LTS: 'H:mm:ss [Auer]',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm [Auer]',
            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]',
        },
        calendar: {
            sameDay: '[Haut um] LT',
            sameElse: 'L',
            nextDay: '[Muer um] LT',
            nextWeek: 'dddd [um] LT',
            lastDay: '[Gëschter um] LT',
            lastWeek: function () {
                // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
                switch (this.day()) {
                    case 2:
                    case 4:
                        return '[Leschten] dddd [um] LT';
                    default:
                        return '[Leschte] dddd [um] LT';
                }
            },
        },
        relativeTime: {
            future: processFutureTime,
            past: processPastTime,
            s: 'e puer Sekonnen',
            ss: '%d Sekonnen',
            m: processRelativeTime,
            mm: '%d Minutten',
            h: processRelativeTime,
            hh: '%d Stonnen',
            d: processRelativeTime,
            dd: '%d Deeg',
            M: processRelativeTime,
            MM: '%d Méint',
            y: processRelativeTime,
            yy: '%d Joer',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return lb;

})));


/***/ }),

/***/ "./node_modules/moment/locale/lo.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/lo.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lao [lo]
//! author : Ryan Hart : https://github.com/ryanhart2

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var lo = moment.defineLocale('lo', {
        months: 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split(
            '_'
        ),
        monthsShort: 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split(
            '_'
        ),
        weekdays: 'ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
        weekdaysShort: 'ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
        weekdaysMin: 'ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'ວັນdddd D MMMM YYYY HH:mm',
        },
        meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
        isPM: function (input) {
            return input === 'ຕອນແລງ';
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ຕອນເຊົ້າ';
            } else {
                return 'ຕອນແລງ';
            }
        },
        calendar: {
            sameDay: '[ມື້ນີ້ເວລາ] LT',
            nextDay: '[ມື້ອື່ນເວລາ] LT',
            nextWeek: '[ວັນ]dddd[ໜ້າເວລາ] LT',
            lastDay: '[ມື້ວານນີ້ເວລາ] LT',
            lastWeek: '[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'ອີກ %s',
            past: '%sຜ່ານມາ',
            s: 'ບໍ່ເທົ່າໃດວິນາທີ',
            ss: '%d ວິນາທີ',
            m: '1 ນາທີ',
            mm: '%d ນາທີ',
            h: '1 ຊົ່ວໂມງ',
            hh: '%d ຊົ່ວໂມງ',
            d: '1 ມື້',
            dd: '%d ມື້',
            M: '1 ເດືອນ',
            MM: '%d ເດືອນ',
            y: '1 ປີ',
            yy: '%d ປີ',
        },
        dayOfMonthOrdinalParse: /(ທີ່)\d{1,2}/,
        ordinal: function (number) {
            return 'ທີ່' + number;
        },
    });

    return lo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/lt.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/lt.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lithuanian [lt]
//! author : Mindaugas Mozūras : https://github.com/mmozuras

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var units = {
        ss: 'sekundė_sekundžių_sekundes',
        m: 'minutė_minutės_minutę',
        mm: 'minutės_minučių_minutes',
        h: 'valanda_valandos_valandą',
        hh: 'valandos_valandų_valandas',
        d: 'diena_dienos_dieną',
        dd: 'dienos_dienų_dienas',
        M: 'mėnuo_mėnesio_mėnesį',
        MM: 'mėnesiai_mėnesių_mėnesius',
        y: 'metai_metų_metus',
        yy: 'metai_metų_metus',
    };
    function translateSeconds(number, withoutSuffix, key, isFuture) {
        if (withoutSuffix) {
            return 'kelios sekundės';
        } else {
            return isFuture ? 'kelių sekundžių' : 'kelias sekundes';
        }
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
        return withoutSuffix
            ? forms(key)[0]
            : isFuture
            ? forms(key)[1]
            : forms(key)[2];
    }
    function special(number) {
        return number % 10 === 0 || (number > 10 && number < 20);
    }
    function forms(key) {
        return units[key].split('_');
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        if (number === 1) {
            return (
                result + translateSingular(number, withoutSuffix, key[0], isFuture)
            );
        } else if (withoutSuffix) {
            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
        } else {
            if (isFuture) {
                return result + forms(key)[1];
            } else {
                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
            }
        }
    }
    var lt = moment.defineLocale('lt', {
        months: {
            format: 'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split(
                '_'
            ),
            standalone: 'sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis'.split(
                '_'
            ),
            isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/,
        },
        monthsShort: 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
        weekdays: {
            format: 'sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį'.split(
                '_'
            ),
            standalone: 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split(
                '_'
            ),
            isFormat: /dddd HH:mm/,
        },
        weekdaysShort: 'Sek_Pir_Ant_Tre_Ket_Pen_Šeš'.split('_'),
        weekdaysMin: 'S_P_A_T_K_Pn_Š'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'YYYY [m.] MMMM D [d.]',
            LLL: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            LLLL: 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
            l: 'YYYY-MM-DD',
            ll: 'YYYY [m.] MMMM D [d.]',
            lll: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            llll: 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]',
        },
        calendar: {
            sameDay: '[Šiandien] LT',
            nextDay: '[Rytoj] LT',
            nextWeek: 'dddd LT',
            lastDay: '[Vakar] LT',
            lastWeek: '[Praėjusį] dddd LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'po %s',
            past: 'prieš %s',
            s: translateSeconds,
            ss: translate,
            m: translateSingular,
            mm: translate,
            h: translateSingular,
            hh: translate,
            d: translateSingular,
            dd: translate,
            M: translateSingular,
            MM: translate,
            y: translateSingular,
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}-oji/,
        ordinal: function (number) {
            return number + '-oji';
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return lt;

})));


/***/ }),

/***/ "./node_modules/moment/locale/lv.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/lv.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Latvian [lv]
//! author : Kristaps Karlsons : https://github.com/skakri
//! author : Jānis Elmeris : https://github.com/JanisE

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var units = {
        ss: 'sekundes_sekundēm_sekunde_sekundes'.split('_'),
        m: 'minūtes_minūtēm_minūte_minūtes'.split('_'),
        mm: 'minūtes_minūtēm_minūte_minūtes'.split('_'),
        h: 'stundas_stundām_stunda_stundas'.split('_'),
        hh: 'stundas_stundām_stunda_stundas'.split('_'),
        d: 'dienas_dienām_diena_dienas'.split('_'),
        dd: 'dienas_dienām_diena_dienas'.split('_'),
        M: 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
        MM: 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
        y: 'gada_gadiem_gads_gadi'.split('_'),
        yy: 'gada_gadiem_gads_gadi'.split('_'),
    };
    /**
     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
     */
    function format(forms, number, withoutSuffix) {
        if (withoutSuffix) {
            // E.g. "21 minūte", "3 minūtes".
            return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
        } else {
            // E.g. "21 minūtes" as in "pēc 21 minūtes".
            // E.g. "3 minūtēm" as in "pēc 3 minūtēm".
            return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
        }
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        return number + ' ' + format(units[key], number, withoutSuffix);
    }
    function relativeTimeWithSingular(number, withoutSuffix, key) {
        return format(units[key], number, withoutSuffix);
    }
    function relativeSeconds(number, withoutSuffix) {
        return withoutSuffix ? 'dažas sekundes' : 'dažām sekundēm';
    }

    var lv = moment.defineLocale('lv', {
        months: 'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split(
            '_'
        ),
        monthsShort: 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
        weekdays: 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split(
            '_'
        ),
        weekdaysShort: 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysMin: 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY.',
            LL: 'YYYY. [gada] D. MMMM',
            LLL: 'YYYY. [gada] D. MMMM, HH:mm',
            LLLL: 'YYYY. [gada] D. MMMM, dddd, HH:mm',
        },
        calendar: {
            sameDay: '[Šodien pulksten] LT',
            nextDay: '[Rīt pulksten] LT',
            nextWeek: 'dddd [pulksten] LT',
            lastDay: '[Vakar pulksten] LT',
            lastWeek: '[Pagājušā] dddd [pulksten] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'pēc %s',
            past: 'pirms %s',
            s: relativeSeconds,
            ss: relativeTimeWithPlural,
            m: relativeTimeWithSingular,
            mm: relativeTimeWithPlural,
            h: relativeTimeWithSingular,
            hh: relativeTimeWithPlural,
            d: relativeTimeWithSingular,
            dd: relativeTimeWithPlural,
            M: relativeTimeWithSingular,
            MM: relativeTimeWithPlural,
            y: relativeTimeWithSingular,
            yy: relativeTimeWithPlural,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return lv;

})));


/***/ }),

/***/ "./node_modules/moment/locale/me.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/me.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Montenegrin [me]
//! author : Miodrag Nikač <miodrag@restartit.me> : https://github.com/miodragnikac

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var translator = {
        words: {
            //Different grammatical cases
            ss: ['sekund', 'sekunda', 'sekundi'],
            m: ['jedan minut', 'jednog minuta'],
            mm: ['minut', 'minuta', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mjesec', 'mjeseca', 'mjeseci'],
            yy: ['godina', 'godine', 'godina'],
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1
                ? wordKey[0]
                : number >= 2 && number <= 4
                ? wordKey[1]
                : wordKey[2];
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return (
                    number +
                    ' ' +
                    translator.correctGrammaticalCase(number, wordKey)
                );
            }
        },
    };

    var me = moment.defineLocale('me', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split(
            '_'
        ),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split(
            '_'
        ),
        weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sjutra u] LT',

            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedjelju] [u] LT';
                    case 3:
                        return '[u] [srijedu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay: '[juče u] LT',
            lastWeek: function () {
                var lastWeekDays = [
                    '[prošle] [nedjelje] [u] LT',
                    '[prošlog] [ponedjeljka] [u] LT',
                    '[prošlog] [utorka] [u] LT',
                    '[prošle] [srijede] [u] LT',
                    '[prošlog] [četvrtka] [u] LT',
                    '[prošlog] [petka] [u] LT',
                    '[prošle] [subote] [u] LT',
                ];
                return lastWeekDays[this.day()];
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'za %s',
            past: 'prije %s',
            s: 'nekoliko sekundi',
            ss: translator.translate,
            m: translator.translate,
            mm: translator.translate,
            h: translator.translate,
            hh: translator.translate,
            d: 'dan',
            dd: translator.translate,
            M: 'mjesec',
            MM: translator.translate,
            y: 'godinu',
            yy: translator.translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return me;

})));


/***/ }),

/***/ "./node_modules/moment/locale/mi.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/mi.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maori [mi]
//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var mi = moment.defineLocale('mi', {
        months: 'Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea'.split(
            '_'
        ),
        monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split(
            '_'
        ),
        monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
        monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
        weekdays: 'Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei'.split('_'),
        weekdaysShort: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
        weekdaysMin: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [i] HH:mm',
            LLLL: 'dddd, D MMMM YYYY [i] HH:mm',
        },
        calendar: {
            sameDay: '[i teie mahana, i] LT',
            nextDay: '[apopo i] LT',
            nextWeek: 'dddd [i] LT',
            lastDay: '[inanahi i] LT',
            lastWeek: 'dddd [whakamutunga i] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'i roto i %s',
            past: '%s i mua',
            s: 'te hēkona ruarua',
            ss: '%d hēkona',
            m: 'he meneti',
            mm: '%d meneti',
            h: 'te haora',
            hh: '%d haora',
            d: 'he ra',
            dd: '%d ra',
            M: 'he marama',
            MM: '%d marama',
            y: 'he tau',
            yy: '%d tau',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return mi;

})));


/***/ }),

/***/ "./node_modules/moment/locale/mk.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/mk.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Macedonian [mk]
//! author : Borislav Mickov : https://github.com/B0k0
//! author : Sashko Todorov : https://github.com/bkyceh

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var mk = moment.defineLocale('mk', {
        months: 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split(
            '_'
        ),
        monthsShort: 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
        weekdays: 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split(
            '_'
        ),
        weekdaysShort: 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
        weekdaysMin: 'нe_пo_вт_ср_че_пе_сa'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'D.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY H:mm',
            LLLL: 'dddd, D MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[Денес во] LT',
            nextDay: '[Утре во] LT',
            nextWeek: '[Во] dddd [во] LT',
            lastDay: '[Вчера во] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 6:
                        return '[Изминатата] dddd [во] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[Изминатиот] dddd [во] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'за %s',
            past: 'пред %s',
            s: 'неколку секунди',
            ss: '%d секунди',
            m: 'една минута',
            mm: '%d минути',
            h: 'еден час',
            hh: '%d часа',
            d: 'еден ден',
            dd: '%d дена',
            M: 'еден месец',
            MM: '%d месеци',
            y: 'една година',
            yy: '%d години',
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
        ordinal: function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-ев';
            } else if (last2Digits === 0) {
                return number + '-ен';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-ти';
            } else if (lastDigit === 1) {
                return number + '-ви';
            } else if (lastDigit === 2) {
                return number + '-ри';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-ми';
            } else {
                return number + '-ти';
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return mk;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ml.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ml.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malayalam [ml]
//! author : Floyd Pink : https://github.com/floydpink

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ml = moment.defineLocale('ml', {
        months: 'ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ'.split(
            '_'
        ),
        monthsShort: 'ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച'.split(
            '_'
        ),
        weekdaysShort: 'ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി'.split('_'),
        weekdaysMin: 'ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ'.split('_'),
        longDateFormat: {
            LT: 'A h:mm -നു',
            LTS: 'A h:mm:ss -നു',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm -നു',
            LLLL: 'dddd, D MMMM YYYY, A h:mm -നു',
        },
        calendar: {
            sameDay: '[ഇന്ന്] LT',
            nextDay: '[നാളെ] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[ഇന്നലെ] LT',
            lastWeek: '[കഴിഞ്ഞ] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s കഴിഞ്ഞ്',
            past: '%s മുൻപ്',
            s: 'അൽപ നിമിഷങ്ങൾ',
            ss: '%d സെക്കൻഡ്',
            m: 'ഒരു മിനിറ്റ്',
            mm: '%d മിനിറ്റ്',
            h: 'ഒരു മണിക്കൂർ',
            hh: '%d മണിക്കൂർ',
            d: 'ഒരു ദിവസം',
            dd: '%d ദിവസം',
            M: 'ഒരു മാസം',
            MM: '%d മാസം',
            y: 'ഒരു വർഷം',
            yy: '%d വർഷം',
        },
        meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (
                (meridiem === 'രാത്രി' && hour >= 4) ||
                meridiem === 'ഉച്ച കഴിഞ്ഞ്' ||
                meridiem === 'വൈകുന്നേരം'
            ) {
                return hour + 12;
            } else {
                return hour;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'രാത്രി';
            } else if (hour < 12) {
                return 'രാവിലെ';
            } else if (hour < 17) {
                return 'ഉച്ച കഴിഞ്ഞ്';
            } else if (hour < 20) {
                return 'വൈകുന്നേരം';
            } else {
                return 'രാത്രി';
            }
        },
    });

    return ml;

})));


/***/ }),

/***/ "./node_modules/moment/locale/mn.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/mn.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Mongolian [mn]
//! author : Javkhlantugs Nyamdorj : https://github.com/javkhaanj7

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function translate(number, withoutSuffix, key, isFuture) {
        switch (key) {
            case 's':
                return withoutSuffix ? 'хэдхэн секунд' : 'хэдхэн секундын';
            case 'ss':
                return number + (withoutSuffix ? ' секунд' : ' секундын');
            case 'm':
            case 'mm':
                return number + (withoutSuffix ? ' минут' : ' минутын');
            case 'h':
            case 'hh':
                return number + (withoutSuffix ? ' цаг' : ' цагийн');
            case 'd':
            case 'dd':
                return number + (withoutSuffix ? ' өдөр' : ' өдрийн');
            case 'M':
            case 'MM':
                return number + (withoutSuffix ? ' сар' : ' сарын');
            case 'y':
            case 'yy':
                return number + (withoutSuffix ? ' жил' : ' жилийн');
            default:
                return number;
        }
    }

    var mn = moment.defineLocale('mn', {
        months: 'Нэгдүгээр сар_Хоёрдугаар сар_Гуравдугаар сар_Дөрөвдүгээр сар_Тавдугаар сар_Зургадугаар сар_Долдугаар сар_Наймдугаар сар_Есдүгээр сар_Аравдугаар сар_Арван нэгдүгээр сар_Арван хоёрдугаар сар'.split(
            '_'
        ),
        monthsShort: '1 сар_2 сар_3 сар_4 сар_5 сар_6 сар_7 сар_8 сар_9 сар_10 сар_11 сар_12 сар'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'Ням_Даваа_Мягмар_Лхагва_Пүрэв_Баасан_Бямба'.split('_'),
        weekdaysShort: 'Ням_Дав_Мяг_Лха_Пүр_Баа_Бям'.split('_'),
        weekdaysMin: 'Ня_Да_Мя_Лх_Пү_Ба_Бя'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'YYYY оны MMMMын D',
            LLL: 'YYYY оны MMMMын D HH:mm',
            LLLL: 'dddd, YYYY оны MMMMын D HH:mm',
        },
        meridiemParse: /ҮӨ|ҮХ/i,
        isPM: function (input) {
            return input === 'ҮХ';
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ҮӨ';
            } else {
                return 'ҮХ';
            }
        },
        calendar: {
            sameDay: '[Өнөөдөр] LT',
            nextDay: '[Маргааш] LT',
            nextWeek: '[Ирэх] dddd LT',
            lastDay: '[Өчигдөр] LT',
            lastWeek: '[Өнгөрсөн] dddd LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s дараа',
            past: '%s өмнө',
            s: translate,
            ss: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: translate,
            dd: translate,
            M: translate,
            MM: translate,
            y: translate,
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2} өдөр/,
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + ' өдөр';
                default:
                    return number;
            }
        },
    });

    return mn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/mr.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/mr.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Marathi [mr]
//! author : Harshad Kale : https://github.com/kalehv
//! author : Vivek Athalye : https://github.com/vnathalye

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            1: '१',
            2: '२',
            3: '३',
            4: '४',
            5: '५',
            6: '६',
            7: '७',
            8: '८',
            9: '९',
            0: '०',
        },
        numberMap = {
            '१': '1',
            '२': '2',
            '३': '3',
            '४': '4',
            '५': '5',
            '६': '6',
            '७': '7',
            '८': '8',
            '९': '9',
            '०': '0',
        };

    function relativeTimeMr(number, withoutSuffix, string, isFuture) {
        var output = '';
        if (withoutSuffix) {
            switch (string) {
                case 's':
                    output = 'काही सेकंद';
                    break;
                case 'ss':
                    output = '%d सेकंद';
                    break;
                case 'm':
                    output = 'एक मिनिट';
                    break;
                case 'mm':
                    output = '%d मिनिटे';
                    break;
                case 'h':
                    output = 'एक तास';
                    break;
                case 'hh':
                    output = '%d तास';
                    break;
                case 'd':
                    output = 'एक दिवस';
                    break;
                case 'dd':
                    output = '%d दिवस';
                    break;
                case 'M':
                    output = 'एक महिना';
                    break;
                case 'MM':
                    output = '%d महिने';
                    break;
                case 'y':
                    output = 'एक वर्ष';
                    break;
                case 'yy':
                    output = '%d वर्षे';
                    break;
            }
        } else {
            switch (string) {
                case 's':
                    output = 'काही सेकंदां';
                    break;
                case 'ss':
                    output = '%d सेकंदां';
                    break;
                case 'm':
                    output = 'एका मिनिटा';
                    break;
                case 'mm':
                    output = '%d मिनिटां';
                    break;
                case 'h':
                    output = 'एका तासा';
                    break;
                case 'hh':
                    output = '%d तासां';
                    break;
                case 'd':
                    output = 'एका दिवसा';
                    break;
                case 'dd':
                    output = '%d दिवसां';
                    break;
                case 'M':
                    output = 'एका महिन्या';
                    break;
                case 'MM':
                    output = '%d महिन्यां';
                    break;
                case 'y':
                    output = 'एका वर्षा';
                    break;
                case 'yy':
                    output = '%d वर्षां';
                    break;
            }
        }
        return output.replace(/%d/i, number);
    }

    var mr = moment.defineLocale('mr', {
        months: 'जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split(
            '_'
        ),
        monthsShort: 'जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
        weekdaysShort: 'रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि'.split('_'),
        weekdaysMin: 'र_सो_मं_बु_गु_शु_श'.split('_'),
        longDateFormat: {
            LT: 'A h:mm वाजता',
            LTS: 'A h:mm:ss वाजता',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm वाजता',
            LLLL: 'dddd, D MMMM YYYY, A h:mm वाजता',
        },
        calendar: {
            sameDay: '[आज] LT',
            nextDay: '[उद्या] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[काल] LT',
            lastWeek: '[मागील] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%sमध्ये',
            past: '%sपूर्वी',
            s: relativeTimeMr,
            ss: relativeTimeMr,
            m: relativeTimeMr,
            mm: relativeTimeMr,
            h: relativeTimeMr,
            hh: relativeTimeMr,
            d: relativeTimeMr,
            dd: relativeTimeMr,
            M: relativeTimeMr,
            MM: relativeTimeMr,
            y: relativeTimeMr,
            yy: relativeTimeMr,
        },
        preparse: function (string) {
            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /पहाटे|सकाळी|दुपारी|सायंकाळी|रात्री/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'पहाटे' || meridiem === 'सकाळी') {
                return hour;
            } else if (
                meridiem === 'दुपारी' ||
                meridiem === 'सायंकाळी' ||
                meridiem === 'रात्री'
            ) {
                return hour >= 12 ? hour : hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour >= 0 && hour < 6) {
                return 'पहाटे';
            } else if (hour < 12) {
                return 'सकाळी';
            } else if (hour < 17) {
                return 'दुपारी';
            } else if (hour < 20) {
                return 'सायंकाळी';
            } else {
                return 'रात्री';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return mr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ms-my.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ms-my.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malay [ms-my]
//! note : DEPRECATED, the correct one is [ms]
//! author : Weldan Jamili : https://github.com/weldan

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var msMy = moment.defineLocale('ms-my', {
        months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [pukul] HH.mm',
            LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar: {
            sameDay: '[Hari ini pukul] LT',
            nextDay: '[Esok pukul] LT',
            nextWeek: 'dddd [pukul] LT',
            lastDay: '[Kelmarin pukul] LT',
            lastWeek: 'dddd [lepas pukul] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'dalam %s',
            past: '%s yang lepas',
            s: 'beberapa saat',
            ss: '%d saat',
            m: 'seminit',
            mm: '%d minit',
            h: 'sejam',
            hh: '%d jam',
            d: 'sehari',
            dd: '%d hari',
            M: 'sebulan',
            MM: '%d bulan',
            y: 'setahun',
            yy: '%d tahun',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return msMy;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ms.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ms.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malay [ms]
//! author : Weldan Jamili : https://github.com/weldan

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ms = moment.defineLocale('ms', {
        months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [pukul] HH.mm',
            LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm',
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar: {
            sameDay: '[Hari ini pukul] LT',
            nextDay: '[Esok pukul] LT',
            nextWeek: 'dddd [pukul] LT',
            lastDay: '[Kelmarin pukul] LT',
            lastWeek: 'dddd [lepas pukul] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'dalam %s',
            past: '%s yang lepas',
            s: 'beberapa saat',
            ss: '%d saat',
            m: 'seminit',
            mm: '%d minit',
            h: 'sejam',
            hh: '%d jam',
            d: 'sehari',
            dd: '%d hari',
            M: 'sebulan',
            MM: '%d bulan',
            y: 'setahun',
            yy: '%d tahun',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return ms;

})));


/***/ }),

/***/ "./node_modules/moment/locale/mt.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/mt.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maltese (Malta) [mt]
//! author : Alessandro Maruccia : https://github.com/alesma

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var mt = moment.defineLocale('mt', {
        months: 'Jannar_Frar_Marzu_April_Mejju_Ġunju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diċembru'.split(
            '_'
        ),
        monthsShort: 'Jan_Fra_Mar_Apr_Mej_Ġun_Lul_Aww_Set_Ott_Nov_Diċ'.split('_'),
        weekdays: 'Il-Ħadd_It-Tnejn_It-Tlieta_L-Erbgħa_Il-Ħamis_Il-Ġimgħa_Is-Sibt'.split(
            '_'
        ),
        weekdaysShort: 'Ħad_Tne_Tli_Erb_Ħam_Ġim_Sib'.split('_'),
        weekdaysMin: 'Ħa_Tn_Tl_Er_Ħa_Ġi_Si'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Illum fil-]LT',
            nextDay: '[Għada fil-]LT',
            nextWeek: 'dddd [fil-]LT',
            lastDay: '[Il-bieraħ fil-]LT',
            lastWeek: 'dddd [li għadda] [fil-]LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'f’ %s',
            past: '%s ilu',
            s: 'ftit sekondi',
            ss: '%d sekondi',
            m: 'minuta',
            mm: '%d minuti',
            h: 'siegħa',
            hh: '%d siegħat',
            d: 'ġurnata',
            dd: '%d ġranet',
            M: 'xahar',
            MM: '%d xhur',
            y: 'sena',
            yy: '%d sni',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return mt;

})));


/***/ }),

/***/ "./node_modules/moment/locale/my.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/my.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Burmese [my]
//! author : Squar team, mysquar.com
//! author : David Rossellat : https://github.com/gholadr
//! author : Tin Aung Lin : https://github.com/thanyawzinmin

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            1: '၁',
            2: '၂',
            3: '၃',
            4: '၄',
            5: '၅',
            6: '၆',
            7: '၇',
            8: '၈',
            9: '၉',
            0: '၀',
        },
        numberMap = {
            '၁': '1',
            '၂': '2',
            '၃': '3',
            '၄': '4',
            '၅': '5',
            '၆': '6',
            '၇': '7',
            '၈': '8',
            '၉': '9',
            '၀': '0',
        };

    var my = moment.defineLocale('my', {
        months: 'ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ'.split(
            '_'
        ),
        monthsShort: 'ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ'.split('_'),
        weekdays: 'တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ'.split(
            '_'
        ),
        weekdaysShort: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
        weekdaysMin: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),

        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[ယနေ.] LT [မှာ]',
            nextDay: '[မနက်ဖြန်] LT [မှာ]',
            nextWeek: 'dddd LT [မှာ]',
            lastDay: '[မနေ.က] LT [မှာ]',
            lastWeek: '[ပြီးခဲ့သော] dddd LT [မှာ]',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'လာမည့် %s မှာ',
            past: 'လွန်ခဲ့သော %s က',
            s: 'စက္ကန်.အနည်းငယ်',
            ss: '%d စက္ကန့်',
            m: 'တစ်မိနစ်',
            mm: '%d မိနစ်',
            h: 'တစ်နာရီ',
            hh: '%d နာရီ',
            d: 'တစ်ရက်',
            dd: '%d ရက်',
            M: 'တစ်လ',
            MM: '%d လ',
            y: 'တစ်နှစ်',
            yy: '%d နှစ်',
        },
        preparse: function (string) {
            return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return my;

})));


/***/ }),

/***/ "./node_modules/moment/locale/nb.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/nb.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Norwegian Bokmål [nb]
//! authors : Espen Hovlandsdal : https://github.com/rexxars
//!           Sigurd Gartmann : https://github.com/sigurdga
//!           Stephen Ramthun : https://github.com/stephenramthun

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var nb = moment.defineLocale('nb', {
        months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split(
            '_'
        ),
        monthsShort: 'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
        weekdaysShort: 'sø._ma._ti._on._to._fr._lø.'.split('_'),
        weekdaysMin: 'sø_ma_ti_on_to_fr_lø'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY [kl.] HH:mm',
            LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm',
        },
        calendar: {
            sameDay: '[i dag kl.] LT',
            nextDay: '[i morgen kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[i går kl.] LT',
            lastWeek: '[forrige] dddd [kl.] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'om %s',
            past: '%s siden',
            s: 'noen sekunder',
            ss: '%d sekunder',
            m: 'ett minutt',
            mm: '%d minutter',
            h: 'en time',
            hh: '%d timer',
            d: 'en dag',
            dd: '%d dager',
            w: 'en uke',
            ww: '%d uker',
            M: 'en måned',
            MM: '%d måneder',
            y: 'ett år',
            yy: '%d år',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return nb;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ne.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ne.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Nepalese [ne]
//! author : suvash : https://github.com/suvash

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            1: '१',
            2: '२',
            3: '३',
            4: '४',
            5: '५',
            6: '६',
            7: '७',
            8: '८',
            9: '९',
            0: '०',
        },
        numberMap = {
            '१': '1',
            '२': '2',
            '३': '3',
            '४': '4',
            '५': '5',
            '६': '6',
            '७': '7',
            '८': '8',
            '९': '9',
            '०': '0',
        };

    var ne = moment.defineLocale('ne', {
        months: 'जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर'.split(
            '_'
        ),
        monthsShort: 'जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार'.split(
            '_'
        ),
        weekdaysShort: 'आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.'.split('_'),
        weekdaysMin: 'आ._सो._मं._बु._बि._शु._श.'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'Aको h:mm बजे',
            LTS: 'Aको h:mm:ss बजे',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, Aको h:mm बजे',
            LLLL: 'dddd, D MMMM YYYY, Aको h:mm बजे',
        },
        preparse: function (string) {
            return string.replace(/[१२३४५६७८९०]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'राति') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'बिहान') {
                return hour;
            } else if (meridiem === 'दिउँसो') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'साँझ') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 3) {
                return 'राति';
            } else if (hour < 12) {
                return 'बिहान';
            } else if (hour < 16) {
                return 'दिउँसो';
            } else if (hour < 20) {
                return 'साँझ';
            } else {
                return 'राति';
            }
        },
        calendar: {
            sameDay: '[आज] LT',
            nextDay: '[भोलि] LT',
            nextWeek: '[आउँदो] dddd[,] LT',
            lastDay: '[हिजो] LT',
            lastWeek: '[गएको] dddd[,] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%sमा',
            past: '%s अगाडि',
            s: 'केही क्षण',
            ss: '%d सेकेण्ड',
            m: 'एक मिनेट',
            mm: '%d मिनेट',
            h: 'एक घण्टा',
            hh: '%d घण्टा',
            d: 'एक दिन',
            dd: '%d दिन',
            M: 'एक महिना',
            MM: '%d महिना',
            y: 'एक बर्ष',
            yy: '%d बर्ष',
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return ne;

})));


/***/ }),

/***/ "./node_modules/moment/locale/nl-be.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/nl-be.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Dutch (Belgium) [nl-be]
//! author : Joris Röling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split(
            '_'
        ),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split(
            '_'
        ),
        monthsParse = [
            /^jan/i,
            /^feb/i,
            /^maart|mrt.?$/i,
            /^apr/i,
            /^mei$/i,
            /^jun[i.]?$/i,
            /^jul[i.]?$/i,
            /^aug/i,
            /^sep/i,
            /^okt/i,
            /^nov/i,
            /^dec/i,
        ],
        monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

    var nlBe = moment.defineLocale('nl-be', {
        months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split(
            '_'
        ),
        monthsShort: function (m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },

        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,

        weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split(
            '_'
        ),
        weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'over %s',
            past: '%s geleden',
            s: 'een paar seconden',
            ss: '%d seconden',
            m: 'één minuut',
            mm: '%d minuten',
            h: 'één uur',
            hh: '%d uur',
            d: 'één dag',
            dd: '%d dagen',
            M: 'één maand',
            MM: '%d maanden',
            y: 'één jaar',
            yy: '%d jaar',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function (number) {
            return (
                number +
                (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
            );
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return nlBe;

})));


/***/ }),

/***/ "./node_modules/moment/locale/nl.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/nl.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Dutch [nl]
//! author : Joris Röling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split(
            '_'
        ),
        monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split(
            '_'
        ),
        monthsParse = [
            /^jan/i,
            /^feb/i,
            /^maart|mrt.?$/i,
            /^apr/i,
            /^mei$/i,
            /^jun[i.]?$/i,
            /^jul[i.]?$/i,
            /^aug/i,
            /^sep/i,
            /^okt/i,
            /^nov/i,
            /^dec/i,
        ],
        monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

    var nl = moment.defineLocale('nl', {
        months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split(
            '_'
        ),
        monthsShort: function (m, format) {
            if (!m) {
                return monthsShortWithDots;
            } else if (/-MMM-/.test(format)) {
                return monthsShortWithoutDots[m.month()];
            } else {
                return monthsShortWithDots[m.month()];
            }
        },

        monthsRegex: monthsRegex,
        monthsShortRegex: monthsRegex,
        monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
        monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,

        weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split(
            '_'
        ),
        weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD-MM-YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'over %s',
            past: '%s geleden',
            s: 'een paar seconden',
            ss: '%d seconden',
            m: 'één minuut',
            mm: '%d minuten',
            h: 'één uur',
            hh: '%d uur',
            d: 'één dag',
            dd: '%d dagen',
            w: 'één week',
            ww: '%d weken',
            M: 'één maand',
            MM: '%d maanden',
            y: 'één jaar',
            yy: '%d jaar',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
        ordinal: function (number) {
            return (
                number +
                (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de')
            );
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return nl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/nn.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/nn.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Nynorsk [nn]
//! authors : https://github.com/mechuwind
//!           Stephen Ramthun : https://github.com/stephenramthun

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var nn = moment.defineLocale('nn', {
        months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split(
            '_'
        ),
        monthsShort: 'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
        weekdaysShort: 'su._må._ty._on._to._fr._lau.'.split('_'),
        weekdaysMin: 'su_må_ty_on_to_fr_la'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY [kl.] H:mm',
            LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm',
        },
        calendar: {
            sameDay: '[I dag klokka] LT',
            nextDay: '[I morgon klokka] LT',
            nextWeek: 'dddd [klokka] LT',
            lastDay: '[I går klokka] LT',
            lastWeek: '[Føregåande] dddd [klokka] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'om %s',
            past: '%s sidan',
            s: 'nokre sekund',
            ss: '%d sekund',
            m: 'eit minutt',
            mm: '%d minutt',
            h: 'ein time',
            hh: '%d timar',
            d: 'ein dag',
            dd: '%d dagar',
            w: 'ei veke',
            ww: '%d veker',
            M: 'ein månad',
            MM: '%d månader',
            y: 'eit år',
            yy: '%d år',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return nn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/oc-lnc.js":
/*!**********************************************!*\
  !*** ./node_modules/moment/locale/oc-lnc.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Occitan, lengadocian dialecte [oc-lnc]
//! author : Quentin PAGÈS : https://github.com/Quenty31

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ocLnc = moment.defineLocale('oc-lnc', {
        months: {
            standalone: 'genièr_febrièr_març_abril_mai_junh_julhet_agost_setembre_octòbre_novembre_decembre'.split(
                '_'
            ),
            format: "de genièr_de febrièr_de març_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octòbre_de novembre_de decembre".split(
                '_'
            ),
            isFormat: /D[oD]?(\s)+MMMM/,
        },
        monthsShort: 'gen._febr._març_abr._mai_junh_julh._ago._set._oct._nov._dec.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'dimenge_diluns_dimars_dimècres_dijòus_divendres_dissabte'.split(
            '_'
        ),
        weekdaysShort: 'dg._dl._dm._dc._dj._dv._ds.'.split('_'),
        weekdaysMin: 'dg_dl_dm_dc_dj_dv_ds'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM [de] YYYY',
            ll: 'D MMM YYYY',
            LLL: 'D MMMM [de] YYYY [a] H:mm',
            lll: 'D MMM YYYY, H:mm',
            LLLL: 'dddd D MMMM [de] YYYY [a] H:mm',
            llll: 'ddd D MMM YYYY, H:mm',
        },
        calendar: {
            sameDay: '[uèi a] LT',
            nextDay: '[deman a] LT',
            nextWeek: 'dddd [a] LT',
            lastDay: '[ièr a] LT',
            lastWeek: 'dddd [passat a] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: "d'aquí %s",
            past: 'fa %s',
            s: 'unas segondas',
            ss: '%d segondas',
            m: 'una minuta',
            mm: '%d minutas',
            h: 'una ora',
            hh: '%d oras',
            d: 'un jorn',
            dd: '%d jorns',
            M: 'un mes',
            MM: '%d meses',
            y: 'un an',
            yy: '%d ans',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
        ordinal: function (number, period) {
            var output =
                number === 1
                    ? 'r'
                    : number === 2
                    ? 'n'
                    : number === 3
                    ? 'r'
                    : number === 4
                    ? 't'
                    : 'è';
            if (period === 'w' || period === 'W') {
                output = 'a';
            }
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4,
        },
    });

    return ocLnc;

})));


/***/ }),

/***/ "./node_modules/moment/locale/pa-in.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/pa-in.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Punjabi (India) [pa-in]
//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            1: '੧',
            2: '੨',
            3: '੩',
            4: '੪',
            5: '੫',
            6: '੬',
            7: '੭',
            8: '੮',
            9: '੯',
            0: '੦',
        },
        numberMap = {
            '੧': '1',
            '੨': '2',
            '੩': '3',
            '੪': '4',
            '੫': '5',
            '੬': '6',
            '੭': '7',
            '੮': '8',
            '੯': '9',
            '੦': '0',
        };

    var paIn = moment.defineLocale('pa-in', {
        // There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.
        months: 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split(
            '_'
        ),
        monthsShort: 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split(
            '_'
        ),
        weekdays: 'ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ'.split(
            '_'
        ),
        weekdaysShort: 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
        weekdaysMin: 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
        longDateFormat: {
            LT: 'A h:mm ਵਜੇ',
            LTS: 'A h:mm:ss ਵਜੇ',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm ਵਜੇ',
            LLLL: 'dddd, D MMMM YYYY, A h:mm ਵਜੇ',
        },
        calendar: {
            sameDay: '[ਅਜ] LT',
            nextDay: '[ਕਲ] LT',
            nextWeek: '[ਅਗਲਾ] dddd, LT',
            lastDay: '[ਕਲ] LT',
            lastWeek: '[ਪਿਛਲੇ] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s ਵਿੱਚ',
            past: '%s ਪਿਛਲੇ',
            s: 'ਕੁਝ ਸਕਿੰਟ',
            ss: '%d ਸਕਿੰਟ',
            m: 'ਇਕ ਮਿੰਟ',
            mm: '%d ਮਿੰਟ',
            h: 'ਇੱਕ ਘੰਟਾ',
            hh: '%d ਘੰਟੇ',
            d: 'ਇੱਕ ਦਿਨ',
            dd: '%d ਦਿਨ',
            M: 'ਇੱਕ ਮਹੀਨਾ',
            MM: '%d ਮਹੀਨੇ',
            y: 'ਇੱਕ ਸਾਲ',
            yy: '%d ਸਾਲ',
        },
        preparse: function (string) {
            return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
        meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'ਰਾਤ') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'ਸਵੇਰ') {
                return hour;
            } else if (meridiem === 'ਦੁਪਹਿਰ') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'ਸ਼ਾਮ') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ਰਾਤ';
            } else if (hour < 10) {
                return 'ਸਵੇਰ';
            } else if (hour < 17) {
                return 'ਦੁਪਹਿਰ';
            } else if (hour < 20) {
                return 'ਸ਼ਾਮ';
            } else {
                return 'ਰਾਤ';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return paIn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/pl.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/pl.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Polish [pl]
//! author : Rafal Hirsz : https://github.com/evoL

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var monthsNominative = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split(
            '_'
        ),
        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split(
            '_'
        ),
        monthsParse = [
            /^sty/i,
            /^lut/i,
            /^mar/i,
            /^kwi/i,
            /^maj/i,
            /^cze/i,
            /^lip/i,
            /^sie/i,
            /^wrz/i,
            /^paź/i,
            /^lis/i,
            /^gru/i,
        ];
    function plural(n) {
        return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
    }
    function translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
            case 'ss':
                return result + (plural(number) ? 'sekundy' : 'sekund');
            case 'm':
                return withoutSuffix ? 'minuta' : 'minutę';
            case 'mm':
                return result + (plural(number) ? 'minuty' : 'minut');
            case 'h':
                return withoutSuffix ? 'godzina' : 'godzinę';
            case 'hh':
                return result + (plural(number) ? 'godziny' : 'godzin');
            case 'ww':
                return result + (plural(number) ? 'tygodnie' : 'tygodni');
            case 'MM':
                return result + (plural(number) ? 'miesiące' : 'miesięcy');
            case 'yy':
                return result + (plural(number) ? 'lata' : 'lat');
        }
    }

    var pl = moment.defineLocale('pl', {
        months: function (momentToFormat, format) {
            if (!momentToFormat) {
                return monthsNominative;
            } else if (/D MMMM/.test(format)) {
                return monthsSubjective[momentToFormat.month()];
            } else {
                return monthsNominative[momentToFormat.month()];
            }
        },
        monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,
        weekdays: 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split(
            '_'
        ),
        weekdaysShort: 'ndz_pon_wt_śr_czw_pt_sob'.split('_'),
        weekdaysMin: 'Nd_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Dziś o] LT',
            nextDay: '[Jutro o] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[W niedzielę o] LT';

                    case 2:
                        return '[We wtorek o] LT';

                    case 3:
                        return '[W środę o] LT';

                    case 6:
                        return '[W sobotę o] LT';

                    default:
                        return '[W] dddd [o] LT';
                }
            },
            lastDay: '[Wczoraj o] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[W zeszłą niedzielę o] LT';
                    case 3:
                        return '[W zeszłą środę o] LT';
                    case 6:
                        return '[W zeszłą sobotę o] LT';
                    default:
                        return '[W zeszły] dddd [o] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'za %s',
            past: '%s temu',
            s: 'kilka sekund',
            ss: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: '1 dzień',
            dd: '%d dni',
            w: 'tydzień',
            ww: translate,
            M: 'miesiąc',
            MM: translate,
            y: 'rok',
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return pl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/pt-br.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/pt-br.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Portuguese (Brazil) [pt-br]
//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ptBr = moment.defineLocale('pt-br', {
        months: 'janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split(
            '_'
        ),
        monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
        weekdays: 'domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado'.split(
            '_'
        ),
        weekdaysShort: 'dom_seg_ter_qua_qui_sex_sáb'.split('_'),
        weekdaysMin: 'do_2ª_3ª_4ª_5ª_6ª_sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY [às] HH:mm',
            LLLL: 'dddd, D [de] MMMM [de] YYYY [às] HH:mm',
        },
        calendar: {
            sameDay: '[Hoje às] LT',
            nextDay: '[Amanhã às] LT',
            nextWeek: 'dddd [às] LT',
            lastDay: '[Ontem às] LT',
            lastWeek: function () {
                return this.day() === 0 || this.day() === 6
                    ? '[Último] dddd [às] LT' // Saturday + Sunday
                    : '[Última] dddd [às] LT'; // Monday - Friday
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'em %s',
            past: 'há %s',
            s: 'poucos segundos',
            ss: '%d segundos',
            m: 'um minuto',
            mm: '%d minutos',
            h: 'uma hora',
            hh: '%d horas',
            d: 'um dia',
            dd: '%d dias',
            M: 'um mês',
            MM: '%d meses',
            y: 'um ano',
            yy: '%d anos',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        invalidDate: 'Data inválida',
    });

    return ptBr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/pt.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/pt.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Portuguese [pt]
//! author : Jefferson : https://github.com/jalex79

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var pt = moment.defineLocale('pt', {
        months: 'janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split(
            '_'
        ),
        monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
        weekdays: 'Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado'.split(
            '_'
        ),
        weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
        weekdaysMin: 'Do_2ª_3ª_4ª_5ª_6ª_Sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D [de] MMMM [de] YYYY',
            LLL: 'D [de] MMMM [de] YYYY HH:mm',
            LLLL: 'dddd, D [de] MMMM [de] YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Hoje às] LT',
            nextDay: '[Amanhã às] LT',
            nextWeek: 'dddd [às] LT',
            lastDay: '[Ontem às] LT',
            lastWeek: function () {
                return this.day() === 0 || this.day() === 6
                    ? '[Último] dddd [às] LT' // Saturday + Sunday
                    : '[Última] dddd [às] LT'; // Monday - Friday
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'em %s',
            past: 'há %s',
            s: 'segundos',
            ss: '%d segundos',
            m: 'um minuto',
            mm: '%d minutos',
            h: 'uma hora',
            hh: '%d horas',
            d: 'um dia',
            dd: '%d dias',
            w: 'uma semana',
            ww: '%d semanas',
            M: 'um mês',
            MM: '%d meses',
            y: 'um ano',
            yy: '%d anos',
        },
        dayOfMonthOrdinalParse: /\d{1,2}º/,
        ordinal: '%dº',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return pt;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ro.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ro.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Romanian [ro]
//! author : Vlad Gurdiga : https://github.com/gurdiga
//! author : Valentin Agachi : https://github.com/avaly
//! author : Emanuel Cepoi : https://github.com/cepem

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
                ss: 'secunde',
                mm: 'minute',
                hh: 'ore',
                dd: 'zile',
                ww: 'săptămâni',
                MM: 'luni',
                yy: 'ani',
            },
            separator = ' ';
        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
            separator = ' de ';
        }
        return number + separator + format[key];
    }

    var ro = moment.defineLocale('ro', {
        months: 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split(
            '_'
        ),
        monthsShort: 'ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'duminică_luni_marți_miercuri_joi_vineri_sâmbătă'.split('_'),
        weekdaysShort: 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
        weekdaysMin: 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY H:mm',
            LLLL: 'dddd, D MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[azi la] LT',
            nextDay: '[mâine la] LT',
            nextWeek: 'dddd [la] LT',
            lastDay: '[ieri la] LT',
            lastWeek: '[fosta] dddd [la] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'peste %s',
            past: '%s în urmă',
            s: 'câteva secunde',
            ss: relativeTimeWithPlural,
            m: 'un minut',
            mm: relativeTimeWithPlural,
            h: 'o oră',
            hh: relativeTimeWithPlural,
            d: 'o zi',
            dd: relativeTimeWithPlural,
            w: 'o săptămână',
            ww: relativeTimeWithPlural,
            M: 'o lună',
            MM: relativeTimeWithPlural,
            y: 'un an',
            yy: relativeTimeWithPlural,
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return ro;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ru.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ru.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Russian [ru]
//! author : Viktorminator : https://github.com/Viktorminator
//! author : Menelion Elensúle : https://github.com/Oire
//! author : Коренберг Марк : https://github.com/socketpair

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11
            ? forms[0]
            : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
            ? forms[1]
            : forms[2];
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            ss: withoutSuffix ? 'секунда_секунды_секунд' : 'секунду_секунды_секунд',
            mm: withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
            hh: 'час_часа_часов',
            dd: 'день_дня_дней',
            ww: 'неделя_недели_недель',
            MM: 'месяц_месяца_месяцев',
            yy: 'год_года_лет',
        };
        if (key === 'm') {
            return withoutSuffix ? 'минута' : 'минуту';
        } else {
            return number + ' ' + plural(format[key], +number);
        }
    }
    var monthsParse = [
        /^янв/i,
        /^фев/i,
        /^мар/i,
        /^апр/i,
        /^ма[йя]/i,
        /^июн/i,
        /^июл/i,
        /^авг/i,
        /^сен/i,
        /^окт/i,
        /^ноя/i,
        /^дек/i,
    ];

    // http://new.gramota.ru/spravka/rules/139-prop : § 103
    // Сокращения месяцев: http://new.gramota.ru/spravka/buro/search-answer?s=242637
    // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
    var ru = moment.defineLocale('ru', {
        months: {
            format: 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split(
                '_'
            ),
            standalone: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split(
                '_'
            ),
        },
        monthsShort: {
            // по CLDR именно "июл." и "июн.", но какой смысл менять букву на точку?
            format: 'янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.'.split(
                '_'
            ),
            standalone: 'янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.'.split(
                '_'
            ),
        },
        weekdays: {
            standalone: 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split(
                '_'
            ),
            format: 'воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу'.split(
                '_'
            ),
            isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?] ?dddd/,
        },
        weekdaysShort: 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
        weekdaysMin: 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
        monthsParse: monthsParse,
        longMonthsParse: monthsParse,
        shortMonthsParse: monthsParse,

        // полные названия с падежами, по три буквы, для некоторых, по 4 буквы, сокращения с точкой и без точки
        monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

        // копия предыдущего
        monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

        // полные названия с падежами
        monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,

        // Выражение, которое соответствует только сокращённым формам
        monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY г.',
            LLL: 'D MMMM YYYY г., H:mm',
            LLLL: 'dddd, D MMMM YYYY г., H:mm',
        },
        calendar: {
            sameDay: '[Сегодня, в] LT',
            nextDay: '[Завтра, в] LT',
            lastDay: '[Вчера, в] LT',
            nextWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                        case 0:
                            return '[В следующее] dddd, [в] LT';
                        case 1:
                        case 2:
                        case 4:
                            return '[В следующий] dddd, [в] LT';
                        case 3:
                        case 5:
                        case 6:
                            return '[В следующую] dddd, [в] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[Во] dddd, [в] LT';
                    } else {
                        return '[В] dddd, [в] LT';
                    }
                }
            },
            lastWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                        case 0:
                            return '[В прошлое] dddd, [в] LT';
                        case 1:
                        case 2:
                        case 4:
                            return '[В прошлый] dddd, [в] LT';
                        case 3:
                        case 5:
                        case 6:
                            return '[В прошлую] dddd, [в] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[Во] dddd, [в] LT';
                    } else {
                        return '[В] dddd, [в] LT';
                    }
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'через %s',
            past: '%s назад',
            s: 'несколько секунд',
            ss: relativeTimeWithPlural,
            m: relativeTimeWithPlural,
            mm: relativeTimeWithPlural,
            h: 'час',
            hh: relativeTimeWithPlural,
            d: 'день',
            dd: relativeTimeWithPlural,
            w: 'неделя',
            ww: relativeTimeWithPlural,
            M: 'месяц',
            MM: relativeTimeWithPlural,
            y: 'год',
            yy: relativeTimeWithPlural,
        },
        meridiemParse: /ночи|утра|дня|вечера/i,
        isPM: function (input) {
            return /^(дня|вечера)$/.test(input);
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ночи';
            } else if (hour < 12) {
                return 'утра';
            } else if (hour < 17) {
                return 'дня';
            } else {
                return 'вечера';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(й|го|я)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                    return number + '-й';
                case 'D':
                    return number + '-го';
                case 'w':
                case 'W':
                    return number + '-я';
                default:
                    return number;
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return ru;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sd.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/sd.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Sindhi [sd]
//! author : Narain Sagar : https://github.com/narainsagar

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var months = [
            'جنوري',
            'فيبروري',
            'مارچ',
            'اپريل',
            'مئي',
            'جون',
            'جولاءِ',
            'آگسٽ',
            'سيپٽمبر',
            'آڪٽوبر',
            'نومبر',
            'ڊسمبر',
        ],
        days = ['آچر', 'سومر', 'اڱارو', 'اربع', 'خميس', 'جمع', 'ڇنڇر'];

    var sd = moment.defineLocale('sd', {
        months: months,
        monthsShort: months,
        weekdays: days,
        weekdaysShort: days,
        weekdaysMin: days,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd، D MMMM YYYY HH:mm',
        },
        meridiemParse: /صبح|شام/,
        isPM: function (input) {
            return 'شام' === input;
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'صبح';
            }
            return 'شام';
        },
        calendar: {
            sameDay: '[اڄ] LT',
            nextDay: '[سڀاڻي] LT',
            nextWeek: 'dddd [اڳين هفتي تي] LT',
            lastDay: '[ڪالهه] LT',
            lastWeek: '[گزريل هفتي] dddd [تي] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s پوء',
            past: '%s اڳ',
            s: 'چند سيڪنڊ',
            ss: '%d سيڪنڊ',
            m: 'هڪ منٽ',
            mm: '%d منٽ',
            h: 'هڪ ڪلاڪ',
            hh: '%d ڪلاڪ',
            d: 'هڪ ڏينهن',
            dd: '%d ڏينهن',
            M: 'هڪ مهينو',
            MM: '%d مهينا',
            y: 'هڪ سال',
            yy: '%d سال',
        },
        preparse: function (string) {
            return string.replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '،');
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return sd;

})));


/***/ }),

/***/ "./node_modules/moment/locale/se.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/se.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Northern Sami [se]
//! authors : Bård Rolstad Henriksen : https://github.com/karamell

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var se = moment.defineLocale('se', {
        months: 'ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu'.split(
            '_'
        ),
        monthsShort: 'ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov'.split(
            '_'
        ),
        weekdays: 'sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat'.split(
            '_'
        ),
        weekdaysShort: 'sotn_vuos_maŋ_gask_duor_bear_láv'.split('_'),
        weekdaysMin: 's_v_m_g_d_b_L'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'MMMM D. [b.] YYYY',
            LLL: 'MMMM D. [b.] YYYY [ti.] HH:mm',
            LLLL: 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm',
        },
        calendar: {
            sameDay: '[otne ti] LT',
            nextDay: '[ihttin ti] LT',
            nextWeek: 'dddd [ti] LT',
            lastDay: '[ikte ti] LT',
            lastWeek: '[ovddit] dddd [ti] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s geažes',
            past: 'maŋit %s',
            s: 'moadde sekunddat',
            ss: '%d sekunddat',
            m: 'okta minuhta',
            mm: '%d minuhtat',
            h: 'okta diimmu',
            hh: '%d diimmut',
            d: 'okta beaivi',
            dd: '%d beaivvit',
            M: 'okta mánnu',
            MM: '%d mánut',
            y: 'okta jahki',
            yy: '%d jagit',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return se;

})));


/***/ }),

/***/ "./node_modules/moment/locale/si.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/si.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Sinhalese [si]
//! author : Sampath Sitinamaluwa : https://github.com/sampathsris

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    /*jshint -W100*/
    var si = moment.defineLocale('si', {
        months: 'ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්'.split(
            '_'
        ),
        monthsShort: 'ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ'.split(
            '_'
        ),
        weekdays: 'ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා'.split(
            '_'
        ),
        weekdaysShort: 'ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන'.split('_'),
        weekdaysMin: 'ඉ_ස_අ_බ_බ්‍ර_සි_සෙ'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'a h:mm',
            LTS: 'a h:mm:ss',
            L: 'YYYY/MM/DD',
            LL: 'YYYY MMMM D',
            LLL: 'YYYY MMMM D, a h:mm',
            LLLL: 'YYYY MMMM D [වැනි] dddd, a h:mm:ss',
        },
        calendar: {
            sameDay: '[අද] LT[ට]',
            nextDay: '[හෙට] LT[ට]',
            nextWeek: 'dddd LT[ට]',
            lastDay: '[ඊයේ] LT[ට]',
            lastWeek: '[පසුගිය] dddd LT[ට]',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%sකින්',
            past: '%sකට පෙර',
            s: 'තත්පර කිහිපය',
            ss: 'තත්පර %d',
            m: 'මිනිත්තුව',
            mm: 'මිනිත්තු %d',
            h: 'පැය',
            hh: 'පැය %d',
            d: 'දිනය',
            dd: 'දින %d',
            M: 'මාසය',
            MM: 'මාස %d',
            y: 'වසර',
            yy: 'වසර %d',
        },
        dayOfMonthOrdinalParse: /\d{1,2} වැනි/,
        ordinal: function (number) {
            return number + ' වැනි';
        },
        meridiemParse: /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
        isPM: function (input) {
            return input === 'ප.ව.' || input === 'පස් වරු';
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'ප.ව.' : 'පස් වරු';
            } else {
                return isLower ? 'පෙ.ව.' : 'පෙර වරු';
            }
        },
    });

    return si;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sk.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/sk.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Slovak [sk]
//! author : Martin Minka : https://github.com/k2s
//! based on work of petrbela : https://github.com/petrbela

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var months = 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split(
            '_'
        ),
        monthsShort = 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_');
    function plural(n) {
        return n > 1 && n < 5;
    }
    function translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's': // a few seconds / in a few seconds / a few seconds ago
                return withoutSuffix || isFuture ? 'pár sekúnd' : 'pár sekundami';
            case 'ss': // 9 seconds / in 9 seconds / 9 seconds ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'sekundy' : 'sekúnd');
                } else {
                    return result + 'sekundami';
                }
            case 'm': // a minute / in a minute / a minute ago
                return withoutSuffix ? 'minúta' : isFuture ? 'minútu' : 'minútou';
            case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'minúty' : 'minút');
                } else {
                    return result + 'minútami';
                }
            case 'h': // an hour / in an hour / an hour ago
                return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';
            case 'hh': // 9 hours / in 9 hours / 9 hours ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'hodiny' : 'hodín');
                } else {
                    return result + 'hodinami';
                }
            case 'd': // a day / in a day / a day ago
                return withoutSuffix || isFuture ? 'deň' : 'dňom';
            case 'dd': // 9 days / in 9 days / 9 days ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'dni' : 'dní');
                } else {
                    return result + 'dňami';
                }
            case 'M': // a month / in a month / a month ago
                return withoutSuffix || isFuture ? 'mesiac' : 'mesiacom';
            case 'MM': // 9 months / in 9 months / 9 months ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'mesiace' : 'mesiacov');
                } else {
                    return result + 'mesiacmi';
                }
            case 'y': // a year / in a year / a year ago
                return withoutSuffix || isFuture ? 'rok' : 'rokom';
            case 'yy': // 9 years / in 9 years / 9 years ago
                if (withoutSuffix || isFuture) {
                    return result + (plural(number) ? 'roky' : 'rokov');
                } else {
                    return result + 'rokmi';
                }
        }
    }

    var sk = moment.defineLocale('sk', {
        months: months,
        monthsShort: monthsShort,
        weekdays: 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
        weekdaysShort: 'ne_po_ut_st_št_pi_so'.split('_'),
        weekdaysMin: 'ne_po_ut_st_št_pi_so'.split('_'),
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd D. MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[dnes o] LT',
            nextDay: '[zajtra o] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[v nedeľu o] LT';
                    case 1:
                    case 2:
                        return '[v] dddd [o] LT';
                    case 3:
                        return '[v stredu o] LT';
                    case 4:
                        return '[vo štvrtok o] LT';
                    case 5:
                        return '[v piatok o] LT';
                    case 6:
                        return '[v sobotu o] LT';
                }
            },
            lastDay: '[včera o] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[minulú nedeľu o] LT';
                    case 1:
                    case 2:
                        return '[minulý] dddd [o] LT';
                    case 3:
                        return '[minulú stredu o] LT';
                    case 4:
                    case 5:
                        return '[minulý] dddd [o] LT';
                    case 6:
                        return '[minulú sobotu o] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'za %s',
            past: 'pred %s',
            s: translate,
            ss: translate,
            m: translate,
            mm: translate,
            h: translate,
            hh: translate,
            d: translate,
            dd: translate,
            M: translate,
            MM: translate,
            y: translate,
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return sk;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sl.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/sl.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Slovenian [sl]
//! author : Robert Sedovšek : https://github.com/sedovsek

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
            case 's':
                return withoutSuffix || isFuture
                    ? 'nekaj sekund'
                    : 'nekaj sekundami';
            case 'ss':
                if (number === 1) {
                    result += withoutSuffix ? 'sekundo' : 'sekundi';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'sekundi' : 'sekundah';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'sekunde' : 'sekundah';
                } else {
                    result += 'sekund';
                }
                return result;
            case 'm':
                return withoutSuffix ? 'ena minuta' : 'eno minuto';
            case 'mm':
                if (number === 1) {
                    result += withoutSuffix ? 'minuta' : 'minuto';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'minute' : 'minutami';
                } else {
                    result += withoutSuffix || isFuture ? 'minut' : 'minutami';
                }
                return result;
            case 'h':
                return withoutSuffix ? 'ena ura' : 'eno uro';
            case 'hh':
                if (number === 1) {
                    result += withoutSuffix ? 'ura' : 'uro';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'uri' : 'urama';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'ure' : 'urami';
                } else {
                    result += withoutSuffix || isFuture ? 'ur' : 'urami';
                }
                return result;
            case 'd':
                return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
            case 'dd':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'dan' : 'dnem';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
                } else {
                    result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
                }
                return result;
            case 'M':
                return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
            case 'MM':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
                } else {
                    result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
                }
                return result;
            case 'y':
                return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
            case 'yy':
                if (number === 1) {
                    result += withoutSuffix || isFuture ? 'leto' : 'letom';
                } else if (number === 2) {
                    result += withoutSuffix || isFuture ? 'leti' : 'letoma';
                } else if (number < 5) {
                    result += withoutSuffix || isFuture ? 'leta' : 'leti';
                } else {
                    result += withoutSuffix || isFuture ? 'let' : 'leti';
                }
                return result;
        }
    }

    var sl = moment.defineLocale('sl', {
        months: 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split(
            '_'
        ),
        monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
        weekdaysShort: 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
        weekdaysMin: 'ne_po_to_sr_če_pe_so'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm',
        },
        calendar: {
            sameDay: '[danes ob] LT',
            nextDay: '[jutri ob] LT',

            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[v] [nedeljo] [ob] LT';
                    case 3:
                        return '[v] [sredo] [ob] LT';
                    case 6:
                        return '[v] [soboto] [ob] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[v] dddd [ob] LT';
                }
            },
            lastDay: '[včeraj ob] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[prejšnjo] [nedeljo] [ob] LT';
                    case 3:
                        return '[prejšnjo] [sredo] [ob] LT';
                    case 6:
                        return '[prejšnjo] [soboto] [ob] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[prejšnji] dddd [ob] LT';
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'čez %s',
            past: 'pred %s',
            s: processRelativeTime,
            ss: processRelativeTime,
            m: processRelativeTime,
            mm: processRelativeTime,
            h: processRelativeTime,
            hh: processRelativeTime,
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return sl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sq.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/sq.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Albanian [sq]
//! author : Flakërim Ismani : https://github.com/flakerimi
//! author : Menelion Elensúle : https://github.com/Oire
//! author : Oerd Cukalla : https://github.com/oerd

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var sq = moment.defineLocale('sq', {
        months: 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor'.split(
            '_'
        ),
        monthsShort: 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj'.split('_'),
        weekdays: 'E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë'.split(
            '_'
        ),
        weekdaysShort: 'Die_Hën_Mar_Mër_Enj_Pre_Sht'.split('_'),
        weekdaysMin: 'D_H_Ma_Më_E_P_Sh'.split('_'),
        weekdaysParseExact: true,
        meridiemParse: /PD|MD/,
        isPM: function (input) {
            return input.charAt(0) === 'M';
        },
        meridiem: function (hours, minutes, isLower) {
            return hours < 12 ? 'PD' : 'MD';
        },
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Sot në] LT',
            nextDay: '[Nesër në] LT',
            nextWeek: 'dddd [në] LT',
            lastDay: '[Dje në] LT',
            lastWeek: 'dddd [e kaluar në] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'në %s',
            past: '%s më parë',
            s: 'disa sekonda',
            ss: '%d sekonda',
            m: 'një minutë',
            mm: '%d minuta',
            h: 'një orë',
            hh: '%d orë',
            d: 'një ditë',
            dd: '%d ditë',
            M: 'një muaj',
            MM: '%d muaj',
            y: 'një vit',
            yy: '%d vite',
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return sq;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sr-cyrl.js":
/*!***********************************************!*\
  !*** ./node_modules/moment/locale/sr-cyrl.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian Cyrillic [sr-cyrl]
//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j
//! author : Stefan Crnjaković <stefan@hotmail.rs> : https://github.com/crnjakovic

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var translator = {
        words: {
            //Different grammatical cases
            ss: ['секунда', 'секунде', 'секунди'],
            m: ['један минут', 'једне минуте'],
            mm: ['минут', 'минуте', 'минута'],
            h: ['један сат', 'једног сата'],
            hh: ['сат', 'сата', 'сати'],
            dd: ['дан', 'дана', 'дана'],
            MM: ['месец', 'месеца', 'месеци'],
            yy: ['година', 'године', 'година'],
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1
                ? wordKey[0]
                : number >= 2 && number <= 4
                ? wordKey[1]
                : wordKey[2];
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return (
                    number +
                    ' ' +
                    translator.correctGrammaticalCase(number, wordKey)
                );
            }
        },
    };

    var srCyrl = moment.defineLocale('sr-cyrl', {
        months: 'јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар'.split(
            '_'
        ),
        monthsShort: 'јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'недеља_понедељак_уторак_среда_четвртак_петак_субота'.split('_'),
        weekdaysShort: 'нед._пон._уто._сре._чет._пет._суб.'.split('_'),
        weekdaysMin: 'не_по_ут_ср_че_пе_су'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'D. M. YYYY.',
            LL: 'D. MMMM YYYY.',
            LLL: 'D. MMMM YYYY. H:mm',
            LLLL: 'dddd, D. MMMM YYYY. H:mm',
        },
        calendar: {
            sameDay: '[данас у] LT',
            nextDay: '[сутра у] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[у] [недељу] [у] LT';
                    case 3:
                        return '[у] [среду] [у] LT';
                    case 6:
                        return '[у] [суботу] [у] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[у] dddd [у] LT';
                }
            },
            lastDay: '[јуче у] LT',
            lastWeek: function () {
                var lastWeekDays = [
                    '[прошле] [недеље] [у] LT',
                    '[прошлог] [понедељка] [у] LT',
                    '[прошлог] [уторка] [у] LT',
                    '[прошле] [среде] [у] LT',
                    '[прошлог] [четвртка] [у] LT',
                    '[прошлог] [петка] [у] LT',
                    '[прошле] [суботе] [у] LT',
                ];
                return lastWeekDays[this.day()];
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'за %s',
            past: 'пре %s',
            s: 'неколико секунди',
            ss: translator.translate,
            m: translator.translate,
            mm: translator.translate,
            h: translator.translate,
            hh: translator.translate,
            d: 'дан',
            dd: translator.translate,
            M: 'месец',
            MM: translator.translate,
            y: 'годину',
            yy: translator.translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 1st is the first week of the year.
        },
    });

    return srCyrl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sr.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/sr.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian [sr]
//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j
//! author : Stefan Crnjaković <stefan@hotmail.rs> : https://github.com/crnjakovic

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var translator = {
        words: {
            //Different grammatical cases
            ss: ['sekunda', 'sekunde', 'sekundi'],
            m: ['jedan minut', 'jedne minute'],
            mm: ['minut', 'minute', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mesec', 'meseca', 'meseci'],
            yy: ['godina', 'godine', 'godina'],
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1
                ? wordKey[0]
                : number >= 2 && number <= 4
                ? wordKey[1]
                : wordKey[2];
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return (
                    number +
                    ' ' +
                    translator.correctGrammaticalCase(number, wordKey)
                );
            }
        },
    };

    var sr = moment.defineLocale('sr', {
        months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split(
            '_'
        ),
        monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota'.split(
            '_'
        ),
        weekdaysShort: 'ned._pon._uto._sre._čet._pet._sub.'.split('_'),
        weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'D. M. YYYY.',
            LL: 'D. MMMM YYYY.',
            LLL: 'D. MMMM YYYY. H:mm',
            LLLL: 'dddd, D. MMMM YYYY. H:mm',
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[u] [nedelju] [u] LT';
                    case 3:
                        return '[u] [sredu] [u] LT';
                    case 6:
                        return '[u] [subotu] [u] LT';
                    case 1:
                    case 2:
                    case 4:
                    case 5:
                        return '[u] dddd [u] LT';
                }
            },
            lastDay: '[juče u] LT',
            lastWeek: function () {
                var lastWeekDays = [
                    '[prošle] [nedelje] [u] LT',
                    '[prošlog] [ponedeljka] [u] LT',
                    '[prošlog] [utorka] [u] LT',
                    '[prošle] [srede] [u] LT',
                    '[prošlog] [četvrtka] [u] LT',
                    '[prošlog] [petka] [u] LT',
                    '[prošle] [subote] [u] LT',
                ];
                return lastWeekDays[this.day()];
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'za %s',
            past: 'pre %s',
            s: 'nekoliko sekundi',
            ss: translator.translate,
            m: translator.translate,
            mm: translator.translate,
            h: translator.translate,
            hh: translator.translate,
            d: 'dan',
            dd: translator.translate,
            M: 'mesec',
            MM: translator.translate,
            y: 'godinu',
            yy: translator.translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return sr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ss.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ss.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : siSwati [ss]
//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ss = moment.defineLocale('ss', {
        months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split(
            '_'
        ),
        monthsShort: 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
        weekdays: 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split(
            '_'
        ),
        weekdaysShort: 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
        weekdaysMin: 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendar: {
            sameDay: '[Namuhla nga] LT',
            nextDay: '[Kusasa nga] LT',
            nextWeek: 'dddd [nga] LT',
            lastDay: '[Itolo nga] LT',
            lastWeek: 'dddd [leliphelile] [nga] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'nga %s',
            past: 'wenteka nga %s',
            s: 'emizuzwana lomcane',
            ss: '%d mzuzwana',
            m: 'umzuzu',
            mm: '%d emizuzu',
            h: 'lihora',
            hh: '%d emahora',
            d: 'lilanga',
            dd: '%d emalanga',
            M: 'inyanga',
            MM: '%d tinyanga',
            y: 'umnyaka',
            yy: '%d iminyaka',
        },
        meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
        meridiem: function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'ekuseni';
            } else if (hours < 15) {
                return 'emini';
            } else if (hours < 19) {
                return 'entsambama';
            } else {
                return 'ebusuku';
            }
        },
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'ekuseni') {
                return hour;
            } else if (meridiem === 'emini') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
                if (hour === 0) {
                    return 0;
                }
                return hour + 12;
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: '%d',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return ss;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sv.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/sv.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Swedish [sv]
//! author : Jens Alm : https://github.com/ulmus

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var sv = moment.defineLocale('sv', {
        months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split(
            '_'
        ),
        monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays: 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
        weekdaysShort: 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
        weekdaysMin: 'sö_må_ti_on_to_fr_lö'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY [kl.] HH:mm',
            LLLL: 'dddd D MMMM YYYY [kl.] HH:mm',
            lll: 'D MMM YYYY HH:mm',
            llll: 'ddd D MMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Idag] LT',
            nextDay: '[Imorgon] LT',
            lastDay: '[Igår] LT',
            nextWeek: '[På] dddd LT',
            lastWeek: '[I] dddd[s] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'om %s',
            past: 'för %s sedan',
            s: 'några sekunder',
            ss: '%d sekunder',
            m: 'en minut',
            mm: '%d minuter',
            h: 'en timme',
            hh: '%d timmar',
            d: 'en dag',
            dd: '%d dagar',
            M: 'en månad',
            MM: '%d månader',
            y: 'ett år',
            yy: '%d år',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? ':e'
                        : b === 1
                        ? ':a'
                        : b === 2
                        ? ':a'
                        : b === 3
                        ? ':e'
                        : ':e';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return sv;

})));


/***/ }),

/***/ "./node_modules/moment/locale/sw.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/sw.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Swahili [sw]
//! author : Fahad Kassim : https://github.com/fadsel

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var sw = moment.defineLocale('sw', {
        months: 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split(
            '_'
        ),
        monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
        weekdays: 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split(
            '_'
        ),
        weekdaysShort: 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
        weekdaysMin: 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'hh:mm A',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[leo saa] LT',
            nextDay: '[kesho saa] LT',
            nextWeek: '[wiki ijayo] dddd [saat] LT',
            lastDay: '[jana] LT',
            lastWeek: '[wiki iliyopita] dddd [saat] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s baadaye',
            past: 'tokea %s',
            s: 'hivi punde',
            ss: 'sekunde %d',
            m: 'dakika moja',
            mm: 'dakika %d',
            h: 'saa limoja',
            hh: 'masaa %d',
            d: 'siku moja',
            dd: 'siku %d',
            M: 'mwezi mmoja',
            MM: 'miezi %d',
            y: 'mwaka mmoja',
            yy: 'miaka %d',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return sw;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ta.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ta.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tamil [ta]
//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var symbolMap = {
            1: '௧',
            2: '௨',
            3: '௩',
            4: '௪',
            5: '௫',
            6: '௬',
            7: '௭',
            8: '௮',
            9: '௯',
            0: '௦',
        },
        numberMap = {
            '௧': '1',
            '௨': '2',
            '௩': '3',
            '௪': '4',
            '௫': '5',
            '௬': '6',
            '௭': '7',
            '௮': '8',
            '௯': '9',
            '௦': '0',
        };

    var ta = moment.defineLocale('ta', {
        months: 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split(
            '_'
        ),
        monthsShort: 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split(
            '_'
        ),
        weekdays: 'ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை'.split(
            '_'
        ),
        weekdaysShort: 'ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி'.split(
            '_'
        ),
        weekdaysMin: 'ஞா_தி_செ_பு_வி_வெ_ச'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, HH:mm',
            LLLL: 'dddd, D MMMM YYYY, HH:mm',
        },
        calendar: {
            sameDay: '[இன்று] LT',
            nextDay: '[நாளை] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[நேற்று] LT',
            lastWeek: '[கடந்த வாரம்] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s இல்',
            past: '%s முன்',
            s: 'ஒரு சில விநாடிகள்',
            ss: '%d விநாடிகள்',
            m: 'ஒரு நிமிடம்',
            mm: '%d நிமிடங்கள்',
            h: 'ஒரு மணி நேரம்',
            hh: '%d மணி நேரம்',
            d: 'ஒரு நாள்',
            dd: '%d நாட்கள்',
            M: 'ஒரு மாதம்',
            MM: '%d மாதங்கள்',
            y: 'ஒரு வருடம்',
            yy: '%d ஆண்டுகள்',
        },
        dayOfMonthOrdinalParse: /\d{1,2}வது/,
        ordinal: function (number) {
            return number + 'வது';
        },
        preparse: function (string) {
            return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
                return numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return symbolMap[match];
            });
        },
        // refer http://ta.wikipedia.org/s/1er1
        meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
        meridiem: function (hour, minute, isLower) {
            if (hour < 2) {
                return ' யாமம்';
            } else if (hour < 6) {
                return ' வைகறை'; // வைகறை
            } else if (hour < 10) {
                return ' காலை'; // காலை
            } else if (hour < 14) {
                return ' நண்பகல்'; // நண்பகல்
            } else if (hour < 18) {
                return ' எற்பாடு'; // எற்பாடு
            } else if (hour < 22) {
                return ' மாலை'; // மாலை
            } else {
                return ' யாமம்';
            }
        },
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'யாமம்') {
                return hour < 2 ? hour : hour + 12;
            } else if (meridiem === 'வைகறை' || meridiem === 'காலை') {
                return hour;
            } else if (meridiem === 'நண்பகல்') {
                return hour >= 10 ? hour : hour + 12;
            } else {
                return hour + 12;
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return ta;

})));


/***/ }),

/***/ "./node_modules/moment/locale/te.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/te.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Telugu [te]
//! author : Krishna Chaitanya Thota : https://github.com/kcthota

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var te = moment.defineLocale('te', {
        months: 'జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జులై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్'.split(
            '_'
        ),
        monthsShort: 'జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జులై_ఆగ._సెప్._అక్టో._నవ._డిసె.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం'.split(
            '_'
        ),
        weekdaysShort: 'ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని'.split('_'),
        weekdaysMin: 'ఆ_సో_మం_బు_గు_శు_శ'.split('_'),
        longDateFormat: {
            LT: 'A h:mm',
            LTS: 'A h:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY, A h:mm',
            LLLL: 'dddd, D MMMM YYYY, A h:mm',
        },
        calendar: {
            sameDay: '[నేడు] LT',
            nextDay: '[రేపు] LT',
            nextWeek: 'dddd, LT',
            lastDay: '[నిన్న] LT',
            lastWeek: '[గత] dddd, LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s లో',
            past: '%s క్రితం',
            s: 'కొన్ని క్షణాలు',
            ss: '%d సెకన్లు',
            m: 'ఒక నిమిషం',
            mm: '%d నిమిషాలు',
            h: 'ఒక గంట',
            hh: '%d గంటలు',
            d: 'ఒక రోజు',
            dd: '%d రోజులు',
            M: 'ఒక నెల',
            MM: '%d నెలలు',
            y: 'ఒక సంవత్సరం',
            yy: '%d సంవత్సరాలు',
        },
        dayOfMonthOrdinalParse: /\d{1,2}వ/,
        ordinal: '%dవ',
        meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'రాత్రి') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'ఉదయం') {
                return hour;
            } else if (meridiem === 'మధ్యాహ్నం') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === 'సాయంత్రం') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'రాత్రి';
            } else if (hour < 10) {
                return 'ఉదయం';
            } else if (hour < 17) {
                return 'మధ్యాహ్నం';
            } else if (hour < 20) {
                return 'సాయంత్రం';
            } else {
                return 'రాత్రి';
            }
        },
        week: {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        },
    });

    return te;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tet.js":
/*!*******************************************!*\
  !*** ./node_modules/moment/locale/tet.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tetun Dili (East Timor) [tet]
//! author : Joshua Brooks : https://github.com/joshbrooks
//! author : Onorio De J. Afonso : https://github.com/marobo
//! author : Sonia Simoes : https://github.com/soniasimoes

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var tet = moment.defineLocale('tet', {
        months: 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juñu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split(
            '_'
        ),
        monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays: 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),
        weekdaysShort: 'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),
        weekdaysMin: 'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Ohin iha] LT',
            nextDay: '[Aban iha] LT',
            nextWeek: 'dddd [iha] LT',
            lastDay: '[Horiseik iha] LT',
            lastWeek: 'dddd [semana kotuk] [iha] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'iha %s',
            past: '%s liuba',
            s: 'segundu balun',
            ss: 'segundu %d',
            m: 'minutu ida',
            mm: 'minutu %d',
            h: 'oras ida',
            hh: 'oras %d',
            d: 'loron ida',
            dd: 'loron %d',
            M: 'fulan ida',
            MM: 'fulan %d',
            y: 'tinan ida',
            yy: 'tinan %d',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return tet;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tg.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/tg.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tajik [tg]
//! author : Orif N. Jr. : https://github.com/orif-jr

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var suffixes = {
        0: '-ум',
        1: '-ум',
        2: '-юм',
        3: '-юм',
        4: '-ум',
        5: '-ум',
        6: '-ум',
        7: '-ум',
        8: '-ум',
        9: '-ум',
        10: '-ум',
        12: '-ум',
        13: '-ум',
        20: '-ум',
        30: '-юм',
        40: '-ум',
        50: '-ум',
        60: '-ум',
        70: '-ум',
        80: '-ум',
        90: '-ум',
        100: '-ум',
    };

    var tg = moment.defineLocale('tg', {
        months: {
            format: 'январи_феврали_марти_апрели_майи_июни_июли_августи_сентябри_октябри_ноябри_декабри'.split(
                '_'
            ),
            standalone: 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split(
                '_'
            ),
        },
        monthsShort: 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
        weekdays: 'якшанбе_душанбе_сешанбе_чоршанбе_панҷшанбе_ҷумъа_шанбе'.split(
            '_'
        ),
        weekdaysShort: 'яшб_дшб_сшб_чшб_пшб_ҷум_шнб'.split('_'),
        weekdaysMin: 'яш_дш_сш_чш_пш_ҷм_шб'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Имрӯз соати] LT',
            nextDay: '[Фардо соати] LT',
            lastDay: '[Дирӯз соати] LT',
            nextWeek: 'dddd[и] [ҳафтаи оянда соати] LT',
            lastWeek: 'dddd[и] [ҳафтаи гузашта соати] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'баъди %s',
            past: '%s пеш',
            s: 'якчанд сония',
            m: 'як дақиқа',
            mm: '%d дақиқа',
            h: 'як соат',
            hh: '%d соат',
            d: 'як рӯз',
            dd: '%d рӯз',
            M: 'як моҳ',
            MM: '%d моҳ',
            y: 'як сол',
            yy: '%d сол',
        },
        meridiemParse: /шаб|субҳ|рӯз|бегоҳ/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'шаб') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === 'субҳ') {
                return hour;
            } else if (meridiem === 'рӯз') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'бегоҳ') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'шаб';
            } else if (hour < 11) {
                return 'субҳ';
            } else if (hour < 16) {
                return 'рӯз';
            } else if (hour < 19) {
                return 'бегоҳ';
            } else {
                return 'шаб';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(ум|юм)/,
        ordinal: function (number) {
            var a = number % 10,
                b = number >= 100 ? 100 : null;
            return number + (suffixes[number] || suffixes[a] || suffixes[b]);
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 1th is the first week of the year.
        },
    });

    return tg;

})));


/***/ }),

/***/ "./node_modules/moment/locale/th.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/th.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Thai [th]
//! author : Kridsada Thanabulpong : https://github.com/sirn

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var th = moment.defineLocale('th', {
        months: 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split(
            '_'
        ),
        monthsShort: 'ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
        weekdaysShort: 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'), // yes, three characters difference
        weekdaysMin: 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'H:mm',
            LTS: 'H:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY เวลา H:mm',
            LLLL: 'วันddddที่ D MMMM YYYY เวลา H:mm',
        },
        meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
        isPM: function (input) {
            return input === 'หลังเที่ยง';
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'ก่อนเที่ยง';
            } else {
                return 'หลังเที่ยง';
            }
        },
        calendar: {
            sameDay: '[วันนี้ เวลา] LT',
            nextDay: '[พรุ่งนี้ เวลา] LT',
            nextWeek: 'dddd[หน้า เวลา] LT',
            lastDay: '[เมื่อวานนี้ เวลา] LT',
            lastWeek: '[วัน]dddd[ที่แล้ว เวลา] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'อีก %s',
            past: '%sที่แล้ว',
            s: 'ไม่กี่วินาที',
            ss: '%d วินาที',
            m: '1 นาที',
            mm: '%d นาที',
            h: '1 ชั่วโมง',
            hh: '%d ชั่วโมง',
            d: '1 วัน',
            dd: '%d วัน',
            w: '1 สัปดาห์',
            ww: '%d สัปดาห์',
            M: '1 เดือน',
            MM: '%d เดือน',
            y: '1 ปี',
            yy: '%d ปี',
        },
    });

    return th;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tk.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/tk.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Turkmen [tk]
//! author : Atamyrat Abdyrahmanov : https://github.com/atamyratabdy

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var suffixes = {
        1: "'inji",
        5: "'inji",
        8: "'inji",
        70: "'inji",
        80: "'inji",
        2: "'nji",
        7: "'nji",
        20: "'nji",
        50: "'nji",
        3: "'ünji",
        4: "'ünji",
        100: "'ünji",
        6: "'njy",
        9: "'unjy",
        10: "'unjy",
        30: "'unjy",
        60: "'ynjy",
        90: "'ynjy",
    };

    var tk = moment.defineLocale('tk', {
        months: 'Ýanwar_Fewral_Mart_Aprel_Maý_Iýun_Iýul_Awgust_Sentýabr_Oktýabr_Noýabr_Dekabr'.split(
            '_'
        ),
        monthsShort: 'Ýan_Few_Mar_Apr_Maý_Iýn_Iýl_Awg_Sen_Okt_Noý_Dek'.split('_'),
        weekdays: 'Ýekşenbe_Duşenbe_Sişenbe_Çarşenbe_Penşenbe_Anna_Şenbe'.split(
            '_'
        ),
        weekdaysShort: 'Ýek_Duş_Siş_Çar_Pen_Ann_Şen'.split('_'),
        weekdaysMin: 'Ýk_Dş_Sş_Çr_Pn_An_Şn'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[bugün sagat] LT',
            nextDay: '[ertir sagat] LT',
            nextWeek: '[indiki] dddd [sagat] LT',
            lastDay: '[düýn] LT',
            lastWeek: '[geçen] dddd [sagat] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s soň',
            past: '%s öň',
            s: 'birnäçe sekunt',
            m: 'bir minut',
            mm: '%d minut',
            h: 'bir sagat',
            hh: '%d sagat',
            d: 'bir gün',
            dd: '%d gün',
            M: 'bir aý',
            MM: '%d aý',
            y: 'bir ýyl',
            yy: '%d ýyl',
        },
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'Do':
                case 'DD':
                    return number;
                default:
                    if (number === 0) {
                        // special case for zero
                        return number + "'unjy";
                    }
                    var a = number % 10,
                        b = (number % 100) - a,
                        c = number >= 100 ? 100 : null;
                    return number + (suffixes[a] || suffixes[b] || suffixes[c]);
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return tk;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tl-ph.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/tl-ph.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tagalog (Philippines) [tl-ph]
//! author : Dan Hagman : https://github.com/hagmandan

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var tlPh = moment.defineLocale('tl-ph', {
        months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split(
            '_'
        ),
        monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
        weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split(
            '_'
        ),
        weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
        weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'MM/D/YYYY',
            LL: 'MMMM D, YYYY',
            LLL: 'MMMM D, YYYY HH:mm',
            LLLL: 'dddd, MMMM DD, YYYY HH:mm',
        },
        calendar: {
            sameDay: 'LT [ngayong araw]',
            nextDay: '[Bukas ng] LT',
            nextWeek: 'LT [sa susunod na] dddd',
            lastDay: 'LT [kahapon]',
            lastWeek: 'LT [noong nakaraang] dddd',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'sa loob ng %s',
            past: '%s ang nakalipas',
            s: 'ilang segundo',
            ss: '%d segundo',
            m: 'isang minuto',
            mm: '%d minuto',
            h: 'isang oras',
            hh: '%d oras',
            d: 'isang araw',
            dd: '%d araw',
            M: 'isang buwan',
            MM: '%d buwan',
            y: 'isang taon',
            yy: '%d taon',
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function (number) {
            return number;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return tlPh;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tlh.js":
/*!*******************************************!*\
  !*** ./node_modules/moment/locale/tlh.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Klingon [tlh]
//! author : Dominika Kruk : https://github.com/amaranthrose

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var numbersNouns = 'pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

    function translateFuture(output) {
        var time = output;
        time =
            output.indexOf('jaj') !== -1
                ? time.slice(0, -3) + 'leS'
                : output.indexOf('jar') !== -1
                ? time.slice(0, -3) + 'waQ'
                : output.indexOf('DIS') !== -1
                ? time.slice(0, -3) + 'nem'
                : time + ' pIq';
        return time;
    }

    function translatePast(output) {
        var time = output;
        time =
            output.indexOf('jaj') !== -1
                ? time.slice(0, -3) + 'Hu’'
                : output.indexOf('jar') !== -1
                ? time.slice(0, -3) + 'wen'
                : output.indexOf('DIS') !== -1
                ? time.slice(0, -3) + 'ben'
                : time + ' ret';
        return time;
    }

    function translate(number, withoutSuffix, string, isFuture) {
        var numberNoun = numberAsNoun(number);
        switch (string) {
            case 'ss':
                return numberNoun + ' lup';
            case 'mm':
                return numberNoun + ' tup';
            case 'hh':
                return numberNoun + ' rep';
            case 'dd':
                return numberNoun + ' jaj';
            case 'MM':
                return numberNoun + ' jar';
            case 'yy':
                return numberNoun + ' DIS';
        }
    }

    function numberAsNoun(number) {
        var hundred = Math.floor((number % 1000) / 100),
            ten = Math.floor((number % 100) / 10),
            one = number % 10,
            word = '';
        if (hundred > 0) {
            word += numbersNouns[hundred] + 'vatlh';
        }
        if (ten > 0) {
            word += (word !== '' ? ' ' : '') + numbersNouns[ten] + 'maH';
        }
        if (one > 0) {
            word += (word !== '' ? ' ' : '') + numbersNouns[one];
        }
        return word === '' ? 'pagh' : word;
    }

    var tlh = moment.defineLocale('tlh', {
        months: 'tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’'.split(
            '_'
        ),
        monthsShort: 'jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split(
            '_'
        ),
        weekdaysShort: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split(
            '_'
        ),
        weekdaysMin: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split(
            '_'
        ),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[DaHjaj] LT',
            nextDay: '[wa’leS] LT',
            nextWeek: 'LLL',
            lastDay: '[wa’Hu’] LT',
            lastWeek: 'LLL',
            sameElse: 'L',
        },
        relativeTime: {
            future: translateFuture,
            past: translatePast,
            s: 'puS lup',
            ss: translate,
            m: 'wa’ tup',
            mm: translate,
            h: 'wa’ rep',
            hh: translate,
            d: 'wa’ jaj',
            dd: translate,
            M: 'wa’ jar',
            MM: translate,
            y: 'wa’ DIS',
            yy: translate,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return tlh;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tr.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/tr.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Turkish [tr]
//! authors : Erhan Gundogan : https://github.com/erhangundogan,
//!           Burak Yiğit Kaya: https://github.com/BYK

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var suffixes = {
        1: "'inci",
        5: "'inci",
        8: "'inci",
        70: "'inci",
        80: "'inci",
        2: "'nci",
        7: "'nci",
        20: "'nci",
        50: "'nci",
        3: "'üncü",
        4: "'üncü",
        100: "'üncü",
        6: "'ncı",
        9: "'uncu",
        10: "'uncu",
        30: "'uncu",
        60: "'ıncı",
        90: "'ıncı",
    };

    var tr = moment.defineLocale('tr', {
        months: 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split(
            '_'
        ),
        monthsShort: 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
        weekdays: 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split(
            '_'
        ),
        weekdaysShort: 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
        weekdaysMin: 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
        meridiem: function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'öö' : 'ÖÖ';
            } else {
                return isLower ? 'ös' : 'ÖS';
            }
        },
        meridiemParse: /öö|ÖÖ|ös|ÖS/,
        isPM: function (input) {
            return input === 'ös' || input === 'ÖS';
        },
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[bugün saat] LT',
            nextDay: '[yarın saat] LT',
            nextWeek: '[gelecek] dddd [saat] LT',
            lastDay: '[dün] LT',
            lastWeek: '[geçen] dddd [saat] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s sonra',
            past: '%s önce',
            s: 'birkaç saniye',
            ss: '%d saniye',
            m: 'bir dakika',
            mm: '%d dakika',
            h: 'bir saat',
            hh: '%d saat',
            d: 'bir gün',
            dd: '%d gün',
            w: 'bir hafta',
            ww: '%d hafta',
            M: 'bir ay',
            MM: '%d ay',
            y: 'bir yıl',
            yy: '%d yıl',
        },
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'Do':
                case 'DD':
                    return number;
                default:
                    if (number === 0) {
                        // special case for zero
                        return number + "'ıncı";
                    }
                    var a = number % 10,
                        b = (number % 100) - a,
                        c = number >= 100 ? 100 : null;
                    return number + (suffixes[a] || suffixes[b] || suffixes[c]);
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return tr;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tzl.js":
/*!*******************************************!*\
  !*** ./node_modules/moment/locale/tzl.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Talossan [tzl]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v
//! author : Iustì Canun

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
    // This is currently too difficult (maybe even impossible) to add.
    var tzl = moment.defineLocale('tzl', {
        months: 'Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar'.split(
            '_'
        ),
        monthsShort: 'Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
        weekdays: 'Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi'.split('_'),
        weekdaysShort: 'Súl_Lún_Mai_Már_Xhú_Vié_Sát'.split('_'),
        weekdaysMin: 'Sú_Lú_Ma_Má_Xh_Vi_Sá'.split('_'),
        longDateFormat: {
            LT: 'HH.mm',
            LTS: 'HH.mm.ss',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM [dallas] YYYY',
            LLL: 'D. MMMM [dallas] YYYY HH.mm',
            LLLL: 'dddd, [li] D. MMMM [dallas] YYYY HH.mm',
        },
        meridiemParse: /d\'o|d\'a/i,
        isPM: function (input) {
            return "d'o" === input.toLowerCase();
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? "d'o" : "D'O";
            } else {
                return isLower ? "d'a" : "D'A";
            }
        },
        calendar: {
            sameDay: '[oxhi à] LT',
            nextDay: '[demà à] LT',
            nextWeek: 'dddd [à] LT',
            lastDay: '[ieiri à] LT',
            lastWeek: '[sür el] dddd [lasteu à] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'osprei %s',
            past: 'ja%s',
            s: processRelativeTime,
            ss: processRelativeTime,
            m: processRelativeTime,
            mm: processRelativeTime,
            h: processRelativeTime,
            hh: processRelativeTime,
            d: processRelativeTime,
            dd: processRelativeTime,
            M: processRelativeTime,
            MM: processRelativeTime,
            y: processRelativeTime,
            yy: processRelativeTime,
        },
        dayOfMonthOrdinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    function processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            s: ['viensas secunds', "'iensas secunds"],
            ss: [number + ' secunds', '' + number + ' secunds'],
            m: ["'n míut", "'iens míut"],
            mm: [number + ' míuts', '' + number + ' míuts'],
            h: ["'n þora", "'iensa þora"],
            hh: [number + ' þoras', '' + number + ' þoras'],
            d: ["'n ziua", "'iensa ziua"],
            dd: [number + ' ziuas', '' + number + ' ziuas'],
            M: ["'n mes", "'iens mes"],
            MM: [number + ' mesen', '' + number + ' mesen'],
            y: ["'n ar", "'iens ar"],
            yy: [number + ' ars', '' + number + ' ars'],
        };
        return isFuture
            ? format[key][0]
            : withoutSuffix
            ? format[key][0]
            : format[key][1];
    }

    return tzl;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tzm-latn.js":
/*!************************************************!*\
  !*** ./node_modules/moment/locale/tzm-latn.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Central Atlas Tamazight Latin [tzm-latn]
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var tzmLatn = moment.defineLocale('tzm-latn', {
        months: 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split(
            '_'
        ),
        monthsShort: 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split(
            '_'
        ),
        weekdays: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        weekdaysShort: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        weekdaysMin: 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[asdkh g] LT',
            nextDay: '[aska g] LT',
            nextWeek: 'dddd [g] LT',
            lastDay: '[assant g] LT',
            lastWeek: 'dddd [g] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'dadkh s yan %s',
            past: 'yan %s',
            s: 'imik',
            ss: '%d imik',
            m: 'minuḍ',
            mm: '%d minuḍ',
            h: 'saɛa',
            hh: '%d tassaɛin',
            d: 'ass',
            dd: '%d ossan',
            M: 'ayowr',
            MM: '%d iyyirn',
            y: 'asgas',
            yy: '%d isgasn',
        },
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12, // The week that contains Jan 12th is the first week of the year.
        },
    });

    return tzmLatn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/tzm.js":
/*!*******************************************!*\
  !*** ./node_modules/moment/locale/tzm.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Central Atlas Tamazight [tzm]
//! author : Abdel Said : https://github.com/abdelsaid

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var tzm = moment.defineLocale('tzm', {
        months: 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split(
            '_'
        ),
        monthsShort: 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split(
            '_'
        ),
        weekdays: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        weekdaysShort: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        weekdaysMin: 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[ⴰⵙⴷⵅ ⴴ] LT',
            nextDay: '[ⴰⵙⴽⴰ ⴴ] LT',
            nextWeek: 'dddd [ⴴ] LT',
            lastDay: '[ⴰⵚⴰⵏⵜ ⴴ] LT',
            lastWeek: 'dddd [ⴴ] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s',
            past: 'ⵢⴰⵏ %s',
            s: 'ⵉⵎⵉⴽ',
            ss: '%d ⵉⵎⵉⴽ',
            m: 'ⵎⵉⵏⵓⴺ',
            mm: '%d ⵎⵉⵏⵓⴺ',
            h: 'ⵙⴰⵄⴰ',
            hh: '%d ⵜⴰⵙⵙⴰⵄⵉⵏ',
            d: 'ⴰⵙⵙ',
            dd: '%d oⵙⵙⴰⵏ',
            M: 'ⴰⵢoⵓⵔ',
            MM: '%d ⵉⵢⵢⵉⵔⵏ',
            y: 'ⴰⵙⴳⴰⵙ',
            yy: '%d ⵉⵙⴳⴰⵙⵏ',
        },
        week: {
            dow: 6, // Saturday is the first day of the week.
            doy: 12, // The week that contains Jan 12th is the first week of the year.
        },
    });

    return tzm;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ug-cn.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/ug-cn.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uyghur (China) [ug-cn]
//! author: boyaq : https://github.com/boyaq

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var ugCn = moment.defineLocale('ug-cn', {
        months: 'يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر'.split(
            '_'
        ),
        monthsShort: 'يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر'.split(
            '_'
        ),
        weekdays: 'يەكشەنبە_دۈشەنبە_سەيشەنبە_چارشەنبە_پەيشەنبە_جۈمە_شەنبە'.split(
            '_'
        ),
        weekdaysShort: 'يە_دۈ_سە_چا_پە_جۈ_شە'.split('_'),
        weekdaysMin: 'يە_دۈ_سە_چا_پە_جۈ_شە'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY-MM-DD',
            LL: 'YYYY-يىلىM-ئاينىڭD-كۈنى',
            LLL: 'YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm',
            LLLL: 'dddd، YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm',
        },
        meridiemParse: /يېرىم كېچە|سەھەر|چۈشتىن بۇرۇن|چۈش|چۈشتىن كېيىن|كەچ/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (
                meridiem === 'يېرىم كېچە' ||
                meridiem === 'سەھەر' ||
                meridiem === 'چۈشتىن بۇرۇن'
            ) {
                return hour;
            } else if (meridiem === 'چۈشتىن كېيىن' || meridiem === 'كەچ') {
                return hour + 12;
            } else {
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return 'يېرىم كېچە';
            } else if (hm < 900) {
                return 'سەھەر';
            } else if (hm < 1130) {
                return 'چۈشتىن بۇرۇن';
            } else if (hm < 1230) {
                return 'چۈش';
            } else if (hm < 1800) {
                return 'چۈشتىن كېيىن';
            } else {
                return 'كەچ';
            }
        },
        calendar: {
            sameDay: '[بۈگۈن سائەت] LT',
            nextDay: '[ئەتە سائەت] LT',
            nextWeek: '[كېلەركى] dddd [سائەت] LT',
            lastDay: '[تۆنۈگۈن] LT',
            lastWeek: '[ئالدىنقى] dddd [سائەت] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s كېيىن',
            past: '%s بۇرۇن',
            s: 'نەچچە سېكونت',
            ss: '%d سېكونت',
            m: 'بىر مىنۇت',
            mm: '%d مىنۇت',
            h: 'بىر سائەت',
            hh: '%d سائەت',
            d: 'بىر كۈن',
            dd: '%d كۈن',
            M: 'بىر ئاي',
            MM: '%d ئاي',
            y: 'بىر يىل',
            yy: '%d يىل',
        },

        dayOfMonthOrdinalParse: /\d{1,2}(-كۈنى|-ئاي|-ھەپتە)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '-كۈنى';
                case 'w':
                case 'W':
                    return number + '-ھەپتە';
                default:
                    return number;
            }
        },
        preparse: function (string) {
            return string.replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '،');
        },
        week: {
            // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 1st is the first week of the year.
        },
    });

    return ugCn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/uk.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/uk.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Ukrainian [uk]
//! author : zemlanin : https://github.com/zemlanin
//! Author : Menelion Elensúle : https://github.com/Oire

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    function plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11
            ? forms[0]
            : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20)
            ? forms[1]
            : forms[2];
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            ss: withoutSuffix ? 'секунда_секунди_секунд' : 'секунду_секунди_секунд',
            mm: withoutSuffix ? 'хвилина_хвилини_хвилин' : 'хвилину_хвилини_хвилин',
            hh: withoutSuffix ? 'година_години_годин' : 'годину_години_годин',
            dd: 'день_дні_днів',
            MM: 'місяць_місяці_місяців',
            yy: 'рік_роки_років',
        };
        if (key === 'm') {
            return withoutSuffix ? 'хвилина' : 'хвилину';
        } else if (key === 'h') {
            return withoutSuffix ? 'година' : 'годину';
        } else {
            return number + ' ' + plural(format[key], +number);
        }
    }
    function weekdaysCaseReplace(m, format) {
        var weekdays = {
                nominative: 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split(
                    '_'
                ),
                accusative: 'неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу'.split(
                    '_'
                ),
                genitive: 'неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи'.split(
                    '_'
                ),
            },
            nounCase;

        if (m === true) {
            return weekdays['nominative']
                .slice(1, 7)
                .concat(weekdays['nominative'].slice(0, 1));
        }
        if (!m) {
            return weekdays['nominative'];
        }

        nounCase = /(\[[ВвУу]\]) ?dddd/.test(format)
            ? 'accusative'
            : /\[?(?:минулої|наступної)? ?\] ?dddd/.test(format)
            ? 'genitive'
            : 'nominative';
        return weekdays[nounCase][m.day()];
    }
    function processHoursFunction(str) {
        return function () {
            return str + 'о' + (this.hours() === 11 ? 'б' : '') + '] LT';
        };
    }

    var uk = moment.defineLocale('uk', {
        months: {
            format: 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split(
                '_'
            ),
            standalone: 'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split(
                '_'
            ),
        },
        monthsShort: 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split(
            '_'
        ),
        weekdays: weekdaysCaseReplace,
        weekdaysShort: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        weekdaysMin: 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD.MM.YYYY',
            LL: 'D MMMM YYYY р.',
            LLL: 'D MMMM YYYY р., HH:mm',
            LLLL: 'dddd, D MMMM YYYY р., HH:mm',
        },
        calendar: {
            sameDay: processHoursFunction('[Сьогодні '),
            nextDay: processHoursFunction('[Завтра '),
            lastDay: processHoursFunction('[Вчора '),
            nextWeek: processHoursFunction('[У] dddd ['),
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                    case 3:
                    case 5:
                    case 6:
                        return processHoursFunction('[Минулої] dddd [').call(this);
                    case 1:
                    case 2:
                    case 4:
                        return processHoursFunction('[Минулого] dddd [').call(this);
                }
            },
            sameElse: 'L',
        },
        relativeTime: {
            future: 'за %s',
            past: '%s тому',
            s: 'декілька секунд',
            ss: relativeTimeWithPlural,
            m: relativeTimeWithPlural,
            mm: relativeTimeWithPlural,
            h: 'годину',
            hh: relativeTimeWithPlural,
            d: 'день',
            dd: relativeTimeWithPlural,
            M: 'місяць',
            MM: relativeTimeWithPlural,
            y: 'рік',
            yy: relativeTimeWithPlural,
        },
        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
        meridiemParse: /ночі|ранку|дня|вечора/,
        isPM: function (input) {
            return /^(дня|вечора)$/.test(input);
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return 'ночі';
            } else if (hour < 12) {
                return 'ранку';
            } else if (hour < 17) {
                return 'дня';
            } else {
                return 'вечора';
            }
        },
        dayOfMonthOrdinalParse: /\d{1,2}-(й|го)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'M':
                case 'd':
                case 'DDD':
                case 'w':
                case 'W':
                    return number + '-й';
                case 'D':
                    return number + '-го';
                default:
                    return number;
            }
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return uk;

})));


/***/ }),

/***/ "./node_modules/moment/locale/ur.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/ur.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Urdu [ur]
//! author : Sawood Alam : https://github.com/ibnesayeed
//! author : Zack : https://github.com/ZackVision

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var months = [
            'جنوری',
            'فروری',
            'مارچ',
            'اپریل',
            'مئی',
            'جون',
            'جولائی',
            'اگست',
            'ستمبر',
            'اکتوبر',
            'نومبر',
            'دسمبر',
        ],
        days = ['اتوار', 'پیر', 'منگل', 'بدھ', 'جمعرات', 'جمعہ', 'ہفتہ'];

    var ur = moment.defineLocale('ur', {
        months: months,
        monthsShort: months,
        weekdays: days,
        weekdaysShort: days,
        weekdaysMin: days,
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd، D MMMM YYYY HH:mm',
        },
        meridiemParse: /صبح|شام/,
        isPM: function (input) {
            return 'شام' === input;
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 12) {
                return 'صبح';
            }
            return 'شام';
        },
        calendar: {
            sameDay: '[آج بوقت] LT',
            nextDay: '[کل بوقت] LT',
            nextWeek: 'dddd [بوقت] LT',
            lastDay: '[گذشتہ روز بوقت] LT',
            lastWeek: '[گذشتہ] dddd [بوقت] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s بعد',
            past: '%s قبل',
            s: 'چند سیکنڈ',
            ss: '%d سیکنڈ',
            m: 'ایک منٹ',
            mm: '%d منٹ',
            h: 'ایک گھنٹہ',
            hh: '%d گھنٹے',
            d: 'ایک دن',
            dd: '%d دن',
            M: 'ایک ماہ',
            MM: '%d ماہ',
            y: 'ایک سال',
            yy: '%d سال',
        },
        preparse: function (string) {
            return string.replace(/،/g, ',');
        },
        postformat: function (string) {
            return string.replace(/,/g, '،');
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return ur;

})));


/***/ }),

/***/ "./node_modules/moment/locale/uz-latn.js":
/*!***********************************************!*\
  !*** ./node_modules/moment/locale/uz-latn.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uzbek Latin [uz-latn]
//! author : Rasulbek Mirzayev : github.com/Rasulbeeek

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var uzLatn = moment.defineLocale('uz-latn', {
        months: 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split(
            '_'
        ),
        monthsShort: 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
        weekdays: 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split(
            '_'
        ),
        weekdaysShort: 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
        weekdaysMin: 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'D MMMM YYYY, dddd HH:mm',
        },
        calendar: {
            sameDay: '[Bugun soat] LT [da]',
            nextDay: '[Ertaga] LT [da]',
            nextWeek: 'dddd [kuni soat] LT [da]',
            lastDay: '[Kecha soat] LT [da]',
            lastWeek: "[O'tgan] dddd [kuni soat] LT [da]",
            sameElse: 'L',
        },
        relativeTime: {
            future: 'Yaqin %s ichida',
            past: 'Bir necha %s oldin',
            s: 'soniya',
            ss: '%d soniya',
            m: 'bir daqiqa',
            mm: '%d daqiqa',
            h: 'bir soat',
            hh: '%d soat',
            d: 'bir kun',
            dd: '%d kun',
            M: 'bir oy',
            MM: '%d oy',
            y: 'bir yil',
            yy: '%d yil',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 7th is the first week of the year.
        },
    });

    return uzLatn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/uz.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/uz.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uzbek [uz]
//! author : Sardor Muminov : https://github.com/muminoff

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var uz = moment.defineLocale('uz', {
        months: 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split(
            '_'
        ),
        monthsShort: 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
        weekdays: 'Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба'.split('_'),
        weekdaysShort: 'Якш_Душ_Сеш_Чор_Пай_Жум_Шан'.split('_'),
        weekdaysMin: 'Як_Ду_Се_Чо_Па_Жу_Ша'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'D MMMM YYYY, dddd HH:mm',
        },
        calendar: {
            sameDay: '[Бугун соат] LT [да]',
            nextDay: '[Эртага] LT [да]',
            nextWeek: 'dddd [куни соат] LT [да]',
            lastDay: '[Кеча соат] LT [да]',
            lastWeek: '[Утган] dddd [куни соат] LT [да]',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'Якин %s ичида',
            past: 'Бир неча %s олдин',
            s: 'фурсат',
            ss: '%d фурсат',
            m: 'бир дакика',
            mm: '%d дакика',
            h: 'бир соат',
            hh: '%d соат',
            d: 'бир кун',
            dd: '%d кун',
            M: 'бир ой',
            MM: '%d ой',
            y: 'бир йил',
            yy: '%d йил',
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 7, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return uz;

})));


/***/ }),

/***/ "./node_modules/moment/locale/vi.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/vi.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Vietnamese [vi]
//! author : Bang Nguyen : https://github.com/bangnk
//! author : Chien Kira : https://github.com/chienkira

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var vi = moment.defineLocale('vi', {
        months: 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split(
            '_'
        ),
        monthsShort: 'Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split(
            '_'
        ),
        weekdaysShort: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysMin: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysParseExact: true,
        meridiemParse: /sa|ch/i,
        isPM: function (input) {
            return /^ch$/i.test(input);
        },
        meridiem: function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'sa' : 'SA';
            } else {
                return isLower ? 'ch' : 'CH';
            }
        },
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM [năm] YYYY',
            LLL: 'D MMMM [năm] YYYY HH:mm',
            LLLL: 'dddd, D MMMM [năm] YYYY HH:mm',
            l: 'DD/M/YYYY',
            ll: 'D MMM YYYY',
            lll: 'D MMM YYYY HH:mm',
            llll: 'ddd, D MMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[Hôm nay lúc] LT',
            nextDay: '[Ngày mai lúc] LT',
            nextWeek: 'dddd [tuần tới lúc] LT',
            lastDay: '[Hôm qua lúc] LT',
            lastWeek: 'dddd [tuần trước lúc] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: '%s tới',
            past: '%s trước',
            s: 'vài giây',
            ss: '%d giây',
            m: 'một phút',
            mm: '%d phút',
            h: 'một giờ',
            hh: '%d giờ',
            d: 'một ngày',
            dd: '%d ngày',
            w: 'một tuần',
            ww: '%d tuần',
            M: 'một tháng',
            MM: '%d tháng',
            y: 'một năm',
            yy: '%d năm',
        },
        dayOfMonthOrdinalParse: /\d{1,2}/,
        ordinal: function (number) {
            return number;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return vi;

})));


/***/ }),

/***/ "./node_modules/moment/locale/x-pseudo.js":
/*!************************************************!*\
  !*** ./node_modules/moment/locale/x-pseudo.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Pseudo [x-pseudo]
//! author : Andrew Hood : https://github.com/andrewhood125

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var xPseudo = moment.defineLocale('x-pseudo', {
        months: 'J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér'.split(
            '_'
        ),
        monthsShort: 'J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc'.split(
            '_'
        ),
        monthsParseExact: true,
        weekdays: 'S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý'.split(
            '_'
        ),
        weekdaysShort: 'S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát'.split('_'),
        weekdaysMin: 'S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá'.split('_'),
        weekdaysParseExact: true,
        longDateFormat: {
            LT: 'HH:mm',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm',
        },
        calendar: {
            sameDay: '[T~ódá~ý át] LT',
            nextDay: '[T~ómó~rró~w át] LT',
            nextWeek: 'dddd [át] LT',
            lastDay: '[Ý~ést~érdá~ý át] LT',
            lastWeek: '[L~ást] dddd [át] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'í~ñ %s',
            past: '%s á~gó',
            s: 'á ~féw ~sécó~ñds',
            ss: '%d s~écóñ~ds',
            m: 'á ~míñ~úté',
            mm: '%d m~íñú~tés',
            h: 'á~ñ hó~úr',
            hh: '%d h~óúrs',
            d: 'á ~dáý',
            dd: '%d d~áýs',
            M: 'á ~móñ~th',
            MM: '%d m~óñt~hs',
            y: 'á ~ýéár',
            yy: '%d ý~éárs',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    ~~((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return xPseudo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/yo.js":
/*!******************************************!*\
  !*** ./node_modules/moment/locale/yo.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Yoruba Nigeria [yo]
//! author : Atolagbe Abisoye : https://github.com/andela-batolagbe

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var yo = moment.defineLocale('yo', {
        months: 'Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀'.split(
            '_'
        ),
        monthsShort: 'Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀'.split('_'),
        weekdays: 'Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta'.split('_'),
        weekdaysShort: 'Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá'.split('_'),
        weekdaysMin: 'Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb'.split('_'),
        longDateFormat: {
            LT: 'h:mm A',
            LTS: 'h:mm:ss A',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY h:mm A',
            LLLL: 'dddd, D MMMM YYYY h:mm A',
        },
        calendar: {
            sameDay: '[Ònì ni] LT',
            nextDay: '[Ọ̀la ni] LT',
            nextWeek: "dddd [Ọsẹ̀ tón'bọ] [ni] LT",
            lastDay: '[Àna ni] LT',
            lastWeek: 'dddd [Ọsẹ̀ tólọ́] [ni] LT',
            sameElse: 'L',
        },
        relativeTime: {
            future: 'ní %s',
            past: '%s kọjá',
            s: 'ìsẹjú aayá die',
            ss: 'aayá %d',
            m: 'ìsẹjú kan',
            mm: 'ìsẹjú %d',
            h: 'wákati kan',
            hh: 'wákati %d',
            d: 'ọjọ́ kan',
            dd: 'ọjọ́ %d',
            M: 'osù kan',
            MM: 'osù %d',
            y: 'ọdún kan',
            yy: 'ọdún %d',
        },
        dayOfMonthOrdinalParse: /ọjọ́\s\d{1,2}/,
        ordinal: 'ọjọ́ %d',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return yo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/zh-cn.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/zh-cn.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (China) [zh-cn]
//! author : suupic : https://github.com/suupic
//! author : Zeno Zeng : https://github.com/zenozeng
//! author : uu109 : https://github.com/uu109

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var zhCn = moment.defineLocale('zh-cn', {
        months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split(
            '_'
        ),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split(
            '_'
        ),
        weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort: '周日_周一_周二_周三_周四_周五_周六'.split('_'),
        weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY/MM/DD',
            LL: 'YYYY年M月D日',
            LLL: 'YYYY年M月D日Ah点mm分',
            LLLL: 'YYYY年M月D日ddddAh点mm分',
            l: 'YYYY/M/D',
            ll: 'YYYY年M月D日',
            lll: 'YYYY年M月D日 HH:mm',
            llll: 'YYYY年M月D日dddd HH:mm',
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
                return hour;
            } else if (meridiem === '下午' || meridiem === '晚上') {
                return hour + 12;
            } else {
                // '中午'
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '凌晨';
            } else if (hm < 900) {
                return '早上';
            } else if (hm < 1130) {
                return '上午';
            } else if (hm < 1230) {
                return '中午';
            } else if (hm < 1800) {
                return '下午';
            } else {
                return '晚上';
            }
        },
        calendar: {
            sameDay: '[今天]LT',
            nextDay: '[明天]LT',
            nextWeek: function (now) {
                if (now.week() !== this.week()) {
                    return '[下]dddLT';
                } else {
                    return '[本]dddLT';
                }
            },
            lastDay: '[昨天]LT',
            lastWeek: function (now) {
                if (this.week() !== now.week()) {
                    return '[上]dddLT';
                } else {
                    return '[本]dddLT';
                }
            },
            sameElse: 'L',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '日';
                case 'M':
                    return number + '月';
                case 'w':
                case 'W':
                    return number + '周';
                default:
                    return number;
            }
        },
        relativeTime: {
            future: '%s后',
            past: '%s前',
            s: '几秒',
            ss: '%d 秒',
            m: '1 分钟',
            mm: '%d 分钟',
            h: '1 小时',
            hh: '%d 小时',
            d: '1 天',
            dd: '%d 天',
            w: '1 周',
            ww: '%d 周',
            M: '1 个月',
            MM: '%d 个月',
            y: '1 年',
            yy: '%d 年',
        },
        week: {
            // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
            dow: 1, // Monday is the first day of the week.
            doy: 4, // The week that contains Jan 4th is the first week of the year.
        },
    });

    return zhCn;

})));


/***/ }),

/***/ "./node_modules/moment/locale/zh-hk.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/zh-hk.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Hong Kong) [zh-hk]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
//! author : Konstantin : https://github.com/skfd
//! author : Anthony : https://github.com/anthonylau

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var zhHk = moment.defineLocale('zh-hk', {
        months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split(
            '_'
        ),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split(
            '_'
        ),
        weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort: '週日_週一_週二_週三_週四_週五_週六'.split('_'),
        weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY/MM/DD',
            LL: 'YYYY年M月D日',
            LLL: 'YYYY年M月D日 HH:mm',
            LLLL: 'YYYY年M月D日dddd HH:mm',
            l: 'YYYY/M/D',
            ll: 'YYYY年M月D日',
            lll: 'YYYY年M月D日 HH:mm',
            llll: 'YYYY年M月D日dddd HH:mm',
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
                return hour;
            } else if (meridiem === '中午') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '下午' || meridiem === '晚上') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '凌晨';
            } else if (hm < 900) {
                return '早上';
            } else if (hm < 1200) {
                return '上午';
            } else if (hm === 1200) {
                return '中午';
            } else if (hm < 1800) {
                return '下午';
            } else {
                return '晚上';
            }
        },
        calendar: {
            sameDay: '[今天]LT',
            nextDay: '[明天]LT',
            nextWeek: '[下]ddddLT',
            lastDay: '[昨天]LT',
            lastWeek: '[上]ddddLT',
            sameElse: 'L',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '日';
                case 'M':
                    return number + '月';
                case 'w':
                case 'W':
                    return number + '週';
                default:
                    return number;
            }
        },
        relativeTime: {
            future: '%s後',
            past: '%s前',
            s: '幾秒',
            ss: '%d 秒',
            m: '1 分鐘',
            mm: '%d 分鐘',
            h: '1 小時',
            hh: '%d 小時',
            d: '1 天',
            dd: '%d 天',
            M: '1 個月',
            MM: '%d 個月',
            y: '1 年',
            yy: '%d 年',
        },
    });

    return zhHk;

})));


/***/ }),

/***/ "./node_modules/moment/locale/zh-mo.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/zh-mo.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Macau) [zh-mo]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
//! author : Tan Yuanhong : https://github.com/le0tan

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var zhMo = moment.defineLocale('zh-mo', {
        months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split(
            '_'
        ),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split(
            '_'
        ),
        weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort: '週日_週一_週二_週三_週四_週五_週六'.split('_'),
        weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'YYYY年M月D日',
            LLL: 'YYYY年M月D日 HH:mm',
            LLLL: 'YYYY年M月D日dddd HH:mm',
            l: 'D/M/YYYY',
            ll: 'YYYY年M月D日',
            lll: 'YYYY年M月D日 HH:mm',
            llll: 'YYYY年M月D日dddd HH:mm',
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
                return hour;
            } else if (meridiem === '中午') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '下午' || meridiem === '晚上') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '凌晨';
            } else if (hm < 900) {
                return '早上';
            } else if (hm < 1130) {
                return '上午';
            } else if (hm < 1230) {
                return '中午';
            } else if (hm < 1800) {
                return '下午';
            } else {
                return '晚上';
            }
        },
        calendar: {
            sameDay: '[今天] LT',
            nextDay: '[明天] LT',
            nextWeek: '[下]dddd LT',
            lastDay: '[昨天] LT',
            lastWeek: '[上]dddd LT',
            sameElse: 'L',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '日';
                case 'M':
                    return number + '月';
                case 'w':
                case 'W':
                    return number + '週';
                default:
                    return number;
            }
        },
        relativeTime: {
            future: '%s內',
            past: '%s前',
            s: '幾秒',
            ss: '%d 秒',
            m: '1 分鐘',
            mm: '%d 分鐘',
            h: '1 小時',
            hh: '%d 小時',
            d: '1 天',
            dd: '%d 天',
            M: '1 個月',
            MM: '%d 個月',
            y: '1 年',
            yy: '%d 年',
        },
    });

    return zhMo;

})));


/***/ }),

/***/ "./node_modules/moment/locale/zh-tw.js":
/*!*********************************************!*\
  !*** ./node_modules/moment/locale/zh-tw.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Taiwan) [zh-tw]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris

;(function (global, factory) {
    true ? factory(__webpack_require__(/*! ../moment */ "./node_modules/moment/moment.js")) :
   0
}(this, (function (moment) { 'use strict';

    //! moment.js locale configuration

    var zhTw = moment.defineLocale('zh-tw', {
        months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split(
            '_'
        ),
        monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split(
            '_'
        ),
        weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
        weekdaysShort: '週日_週一_週二_週三_週四_週五_週六'.split('_'),
        weekdaysMin: '日_一_二_三_四_五_六'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'YYYY/MM/DD',
            LL: 'YYYY年M月D日',
            LLL: 'YYYY年M月D日 HH:mm',
            LLLL: 'YYYY年M月D日dddd HH:mm',
            l: 'YYYY/M/D',
            ll: 'YYYY年M月D日',
            lll: 'YYYY年M月D日 HH:mm',
            llll: 'YYYY年M月D日dddd HH:mm',
        },
        meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
                return hour;
            } else if (meridiem === '中午') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '下午' || meridiem === '晚上') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '凌晨';
            } else if (hm < 900) {
                return '早上';
            } else if (hm < 1130) {
                return '上午';
            } else if (hm < 1230) {
                return '中午';
            } else if (hm < 1800) {
                return '下午';
            } else {
                return '晚上';
            }
        },
        calendar: {
            sameDay: '[今天] LT',
            nextDay: '[明天] LT',
            nextWeek: '[下]dddd LT',
            lastDay: '[昨天] LT',
            lastWeek: '[上]dddd LT',
            sameElse: 'L',
        },
        dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
        ordinal: function (number, period) {
            switch (period) {
                case 'd':
                case 'D':
                case 'DDD':
                    return number + '日';
                case 'M':
                    return number + '月';
                case 'w':
                case 'W':
                    return number + '週';
                default:
                    return number;
            }
        },
        relativeTime: {
            future: '%s後',
            past: '%s前',
            s: '幾秒',
            ss: '%d 秒',
            m: '1 分鐘',
            mm: '%d 分鐘',
            h: '1 小時',
            hh: '%d 小時',
            d: '1 天',
            dd: '%d 天',
            M: '1 個月',
            MM: '%d 個月',
            y: '1 年',
            yy: '%d 年',
        },
    });

    return zhTw;

})));


/***/ }),

/***/ "./node_modules/moment/moment.js":
/*!***************************************!*\
  !*** ./node_modules/moment/moment.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
//! moment.js
//! version : 2.29.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
     true ? module.exports = factory() :
    0
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks() {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback(callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return (
            input instanceof Array ||
            Object.prototype.toString.call(input) === '[object Array]'
        );
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return (
            input != null &&
            Object.prototype.toString.call(input) === '[object Object]'
        );
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return Object.getOwnPropertyNames(obj).length === 0;
        } else {
            var k;
            for (k in obj) {
                if (hasOwnProp(obj, k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return (
            typeof input === 'number' ||
            Object.prototype.toString.call(input) === '[object Number]'
        );
    }

    function isDate(input) {
        return (
            input instanceof Date ||
            Object.prototype.toString.call(input) === '[object Date]'
        );
    }

    function map(arr, fn) {
        var res = [],
            i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidEra: null,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            era: null,
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false,
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this),
                len = t.length >>> 0,
                i;

            for (i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m),
                parsedParts = some.call(flags.parsedDateParts, function (i) {
                    return i != null;
                }),
                isNowValid =
                    !isNaN(m._d.getTime()) &&
                    flags.overflow < 0 &&
                    !flags.empty &&
                    !flags.invalidEra &&
                    !flags.invalidMonth &&
                    !flags.invalidWeekday &&
                    !flags.weekdayMismatch &&
                    !flags.nullInput &&
                    !flags.invalidFormat &&
                    !flags.userInvalidated &&
                    (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid =
                    isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            } else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = (hooks.momentProperties = []),
        updateInProgress = false;

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment(obj) {
        return (
            obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
        );
    }

    function warn(msg) {
        if (
            hooks.suppressDeprecationWarnings === false &&
            typeof console !== 'undefined' &&
            console.warn
        ) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [],
                    arg,
                    i,
                    key;
                for (i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (key in arguments[0]) {
                            if (hasOwnProp(arguments[0], key)) {
                                arg += key + ': ' + arguments[0][key] + ', ';
                            }
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(
                    msg +
                        '\nArguments: ' +
                        Array.prototype.slice.call(args).join('') +
                        '\n' +
                        new Error().stack
                );
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return (
            (typeof Function !== 'undefined' && input instanceof Function) ||
            Object.prototype.toString.call(input) === '[object Function]'
        );
    }

    function set(config) {
        var prop, i;
        for (i in config) {
            if (hasOwnProp(config, i)) {
                prop = config[i];
                if (isFunction(prop)) {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' +
                /\d{1,2}/.source
        );
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig),
            prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (
                hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])
            ) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i,
                res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L',
    };

    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (
            (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
            absNumber
        );
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
        formatFunctions = {},
        formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(
                    func.apply(this, arguments),
                    token
                );
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i,
            length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '',
                i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i])
                    ? array[i].call(mom, format)
                    : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] =
            formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(
                localFormattingTokens,
                replaceLongDateFormatTokens
            );
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A',
    };

    function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper
            .match(formattingTokens)
            .map(function (tok) {
                if (
                    tok === 'MMMM' ||
                    tok === 'MM' ||
                    tok === 'DD' ||
                    tok === 'dddd'
                ) {
                    return tok.slice(1);
                }
                return tok;
            })
            .join('');

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d',
        defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        w: 'a week',
        ww: '%d weeks',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years',
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output)
            ? output(number, withoutSuffix, string, isFuture)
            : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string'
            ? aliases[units] || aliases[units.toLowerCase()]
            : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [],
            u;
        for (u in unitsObj) {
            if (hasOwnProp(unitsObj, u)) {
                units.push({ unit: u, priority: priorities[u] });
            }
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function absFloor(number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    function makeGetSet(unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get(mom, unit) {
        return mom.isValid()
            ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
            : NaN;
    }

    function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (
                unit === 'FullYear' &&
                isLeapYear(mom.year()) &&
                mom.month() === 1 &&
                mom.date() === 29
            ) {
                value = toInt(value);
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                    value,
                    mom.month(),
                    daysInMonth(value, mom.month())
                );
            } else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }

    function stringSet(units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units),
                i;
            for (i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    var match1 = /\d/, //       0 - 9
        match2 = /\d\d/, //      00 - 99
        match3 = /\d{3}/, //     000 - 999
        match4 = /\d{4}/, //    0000 - 9999
        match6 = /[+-]?\d{6}/, // -999999 - 999999
        match1to2 = /\d\d?/, //       0 - 99
        match3to4 = /\d\d\d\d?/, //     999 - 9999
        match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
        match1to3 = /\d{1,3}/, //       0 - 999
        match1to4 = /\d{1,4}/, //       0 - 9999
        match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
        matchUnsigned = /\d+/, //       0 - inf
        matchSigned = /[+-]?\d+/, //    -inf - inf
        matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
        matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        // any word (or two) characters or numbers including two/three word month in arabic.
        // includes scottish gaelic two word and hyphenated months
        matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
        regexes;

    regexes = {};

    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex)
            ? regex
            : function (isStrict, localeData) {
                  return isStrict && strictRegex ? strictRegex : regex;
              };
    }

    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(
            s
                .replace('\\', '')
                .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (
                    matched,
                    p1,
                    p2,
                    p3,
                    p4
                ) {
                    return p1 || p2 || p3 || p4;
                })
        );
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
        var i,
            func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken(token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,
        WEEK = 7,
        WEEKDAY = 8;

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1
            ? isLeapYear(year)
                ? 29
                : 28
            : 31 - ((modMonth % 7) % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
        ),
        defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split(
            '_'
        ),
        MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
        defaultMonthsShortRegex = matchWord,
        defaultMonthsRegex = matchWord;

    function localeMonths(m, format) {
        if (!m) {
            return isArray(this._months)
                ? this._months
                : this._months['standalone'];
        }
        return isArray(this._months)
            ? this._months[m.month()]
            : this._months[
                  (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                      ? 'format'
                      : 'standalone'
              ][m.month()];
    }

    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray(this._monthsShort)
                ? this._monthsShort
                : this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort)
            ? this._monthsShort[m.month()]
            : this._monthsShort[
                  MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
              ][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp(
                    '^' + this.months(mom, '').replace('.', '') + '$',
                    'i'
                );
                this._shortMonthsParse[i] = new RegExp(
                    '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                    'i'
                );
            }
            if (!strict && !this._monthsParse[i]) {
                regex =
                    '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'MMMM' &&
                this._longMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'MMM' &&
                this._shortMonthsParse[i].test(monthName)
            ) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth(mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }

    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict
                ? this._monthsShortStrictRegex
                : this._monthsShortRegex;
        }
    }

    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict
                ? this._monthsStrictRegex
                : this._monthsRegex;
        }
    }

    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._monthsShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] =
            input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
        return isLeapYear(this.year());
    }

    function createDate(y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate(y) {
        var date, args;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear,
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear,
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (
        input,
        week,
        config,
        token
    ) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow: 0, // Sunday is the first day of the week.
        doy: 6, // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek() {
        return this._week.dow;
    }

    function localeFirstDayOfYear() {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
            '_'
        ),
        defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        defaultWeekdaysRegex = matchWord,
        defaultWeekdaysShortRegex = matchWord,
        defaultWeekdaysMinRegex = matchWord;

    function localeWeekdays(m, format) {
        var weekdays = isArray(this._weekdays)
            ? this._weekdays
            : this._weekdays[
                  m && m !== true && this._weekdays.isFormat.test(format)
                      ? 'format'
                      : 'standalone'
              ];
        return m === true
            ? shiftWeekdays(weekdays, this._week.dow)
            : m
            ? weekdays[m.day()]
            : weekdays;
    }

    function localeWeekdaysShort(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : m
            ? this._weekdaysShort[m.day()]
            : this._weekdaysShort;
    }

    function localeWeekdaysMin(m) {
        return m === true
            ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : m
            ? this._weekdaysMin[m.day()]
            : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(
                    mom,
                    ''
                ).toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._shortWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
                this._minWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                    'i'
                );
            }
            if (!this._weekdaysParse[i]) {
                regex =
                    '^' +
                    this.weekdays(mom, '') +
                    '|^' +
                    this.weekdaysShort(mom, '') +
                    '|^' +
                    this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (
                strict &&
                format === 'dddd' &&
                this._fullWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'ddd' &&
                this._shortWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (
                strict &&
                format === 'dd' &&
                this._minWeekdaysParse[i].test(weekdayName)
            ) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict
                ? this._weekdaysStrictRegex
                : this._weekdaysRegex;
        }
    }

    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict
                ? this._weekdaysShortStrictRegex
                : this._weekdaysShortRegex;
        }
    }

    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict
                ? this._weekdaysMinStrictRegex
                : this._weekdaysMinRegex;
        }
    }

    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = regexEscape(this.weekdaysMin(mom, ''));
            shortp = regexEscape(this.weekdaysShort(mom, ''));
            longp = regexEscape(this.weekdays(mom, ''));
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp(
            '^(' + longPieces.join('|') + ')',
            'i'
        );
        this._weekdaysShortStrictRegex = new RegExp(
            '^(' + shortPieces.join('|') + ')',
            'i'
        );
        this._weekdaysMinStrictRegex = new RegExp(
            '^(' + minPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return (
            '' +
            hFormat.apply(this) +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return (
            '' +
            this.hours() +
            zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2)
        );
    });

    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(
                this.hours(),
                this.minutes(),
                lowercase
            );
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4,
            pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return (input + '').toLowerCase().charAt(0) === 'p';
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
        // Setting the hour should keep the time, because the user explicitly
        // specified which hour they want. So trying to maintain the same hour (in
        // a new timezone) makes sense. Adding/subtracting hours does not follow
        // this rule.
        getSetHour = makeGetSet('Hours', true);

    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse,
    };

    // internal storage for locale config files
    var locales = {},
        localeFamilies = {},
        globalLocale;

    function commonPrefix(arr1, arr2) {
        var i,
            minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
            if (arr1[i] !== arr2[i]) {
                return i;
            }
        }
        return minl;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0,
            j,
            next,
            locale,
            split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (
                    next &&
                    next.length >= j &&
                    commonPrefix(split, next) >= j - 1
                ) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null,
            aliasedRequire;
        // TODO: Find a better way to register and load all the locales in Node
        if (
            locales[name] === undefined &&
            "object" !== 'undefined' &&
            module &&
            module.exports
        ) {
            try {
                oldLocale = globalLocale._abbr;
                aliasedRequire = undefined;
                __webpack_require__("./node_modules/moment/locale sync recursive ^\\.\\/.*$")("./" + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {
                // mark as not found to avoid repeating expensive file require call causing high CPU
                // when trying to find en-US, en_US, en-us for every format call
                locales[name] = null; // null means not found
            }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            } else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            } else {
                if (typeof console !== 'undefined' && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn(
                        'Locale ' + key + ' not found. Did you forget to load it?'
                    );
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale(name, config) {
        if (config !== null) {
            var locale,
                parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple(
                    'defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                );
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config,
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale,
                tmpLocale,
                parentConfig = baseConfig;

            if (locales[name] != null && locales[name].parentLocale != null) {
                // Update existing child locale in-place to avoid memory-leaks
                locales[name].set(mergeConfigs(locales[name]._config, config));
            } else {
                // MERGE
                tmpLocale = loadLocale(name);
                if (tmpLocale != null) {
                    parentConfig = tmpLocale._config;
                }
                config = mergeConfigs(parentConfig, config);
                if (tmpLocale == null) {
                    // updateLocale is called for creating a new locale
                    // Set abbr so it will have a name (getters return
                    // undefined otherwise).
                    config.abbr = name;
                }
                locale = new Locale(config);
                locale.parentLocale = locales[name];
                locales[name] = locale;
            }

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                    if (name === getSetGlobalLocale()) {
                        getSetGlobalLocale(name);
                    }
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale(key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow(m) {
        var overflow,
            a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH] < 0 || a[MONTH] > 11
                    ? MONTH
                    : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                    ? DATE
                    : a[HOUR] < 0 ||
                      a[HOUR] > 24 ||
                      (a[HOUR] === 24 &&
                          (a[MINUTE] !== 0 ||
                              a[SECOND] !== 0 ||
                              a[MILLISECOND] !== 0))
                    ? HOUR
                    : a[MINUTE] < 0 || a[MINUTE] > 59
                    ? MINUTE
                    : a[SECOND] < 0 || a[SECOND] > 59
                    ? SECOND
                    : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                    ? MILLISECOND
                    : -1;

            if (
                getParsingFlags(m)._overflowDayOfYear &&
                (overflow < YEAR || overflow > DATE)
            ) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
        tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
            ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
            ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
            ['YYYY-DDD', /\d{4}-\d{3}/],
            ['YYYY-MM', /\d{4}-\d\d/, false],
            ['YYYYYYMMDD', /[+-]\d{10}/],
            ['YYYYMMDD', /\d{8}/],
            ['GGGG[W]WWE', /\d{4}W\d{3}/],
            ['GGGG[W]WW', /\d{4}W\d{2}/, false],
            ['YYYYDDD', /\d{7}/],
            ['YYYYMM', /\d{6}/, false],
            ['YYYY', /\d{4}/, false],
        ],
        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
            ['HH:mm:ss', /\d\d:\d\d:\d\d/],
            ['HH:mm', /\d\d:\d\d/],
            ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
            ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
            ['HHmmss', /\d\d\d\d\d\d/],
            ['HHmm', /\d\d\d\d/],
            ['HH', /\d\d/],
        ],
        aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
        // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
        rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
        obsOffsets = {
            UT: 0,
            GMT: 0,
            EDT: -4 * 60,
            EST: -5 * 60,
            CDT: -5 * 60,
            CST: -6 * 60,
            MDT: -6 * 60,
            MST: -7 * 60,
            PDT: -7 * 60,
            PST: -8 * 60,
        };

    // date from iso format
    function configFromISO(config) {
        var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    function extractFromRFC2822Strings(
        yearStr,
        monthStr,
        dayStr,
        hourStr,
        minuteStr,
        secondStr
    ) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10),
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s
            .replace(/\([^)]*\)|[\n\t]/g, ' ')
            .replace(/(\s\s+)/g, ' ')
            .replace(/^\s\s*/, '')
            .replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(
                    parsedInput[0],
                    parsedInput[1],
                    parsedInput[2]
                ).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10),
                m = hm % 100,
                h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)),
            parsedArray;
        if (match) {
            parsedArray = extractFromRFC2822Strings(
                match[4],
                match[3],
                match[2],
                match[5],
                match[6],
                match[7]
            );
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        if (config._strict) {
            config._isValid = false;
        } else {
            // Final attempt, use Input Fallback
            hooks.createFromInputFallback(config);
        }
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
            'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
            'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [
                nowValue.getUTCFullYear(),
                nowValue.getUTCMonth(),
                nowValue.getUTCDate(),
            ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray(config) {
        var i,
            date,
            input = [],
            currentDate,
            expectedWeekday,
            yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (
                config._dayOfYear > daysInYear(yearToUse) ||
                config._dayOfYear === 0
            ) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] =
                config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (
            config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0
        ) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(
            null,
            input
        );
        expectedWeekday = config._useUTC
            ? config._d.getUTCDay()
            : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (
            config._w &&
            typeof config._w.d !== 'undefined' &&
            config._w.d !== expectedWeekday
        ) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(
                w.GG,
                config._a[YEAR],
                weekOfYear(createLocal(), 1, 4).year
            );
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0,
            era;

        tokens =
            expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(
                    string.indexOf(parsedInput) + parsedInput.length
                );
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver =
            stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (
            config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0
        ) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(
            config._locale,
            config._a[HOUR],
            config._meridiem
        );

        // handle era
        era = getParsingFlags(config).era;
        if (era !== null) {
            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }

        configFromArray(config);
        checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore,
            validFormatFound,
            bestFormatIsValid = false;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            validFormatFound = false;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (isValid(tempConfig)) {
                validFormatFound = true;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (!bestFormatIsValid) {
                if (
                    scoreToBeat == null ||
                    currentScore < scoreToBeat ||
                    validFormatFound
                ) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                    if (validFormatFound) {
                        bestFormatIsValid = true;
                    }
                }
            } else {
                if (currentScore < scoreToBeat) {
                    scoreToBeat = currentScore;
                    bestMoment = tempConfig;
                }
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i),
            dayOrDate = i.day === undefined ? i.date : i.day;
        config._a = map(
            [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
            function (obj) {
                return obj && parseInt(obj, 10);
            }
        );

        configFromArray(config);
    }

    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig(config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({ nullInput: true });
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (format === true || format === false) {
            strict = format;
            format = undefined;
        }

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if (
            (isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)
        ) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
            'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other < this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        ),
        prototypeMax = deprecate(
            'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
            function () {
                var other = createLocal.apply(null, arguments);
                if (this.isValid() && other.isValid()) {
                    return other > this ? this : other;
                } else {
                    return createInvalid();
                }
            }
        );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +new Date();
    };

    var ordering = [
        'year',
        'quarter',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second',
        'millisecond',
    ];

    function isDurationValid(m) {
        var key,
            unitHasDecimal = false,
            i;
        for (key in m) {
            if (
                hasOwnProp(m, key) &&
                !(
                    indexOf.call(ordering, key) !== -1 &&
                    (m[key] == null || !isNaN(m[key]))
                )
            ) {
                return false;
            }
        }

        for (i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds =
            +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days + weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months + quarters * 3 + years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration(obj) {
        return obj instanceof Duration;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if (
                (dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
            ) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    // FORMATTING

    function offset(token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset(),
                sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return (
                sign +
                zeroFill(~~(offset / 60), 2) +
                separator +
                zeroFill(~~offset % 60, 2)
            );
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher),
            chunk,
            parts,
            minutes;

        if (matches === null) {
            return null;
        }

        chunk = matches[matches.length - 1] || [];
        parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff =
                (isMoment(input) || isDate(input)
                    ? input.valueOf()
                    : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset());
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(
                        this,
                        createDuration(input - offset, 'm'),
                        1,
                        false
                    );
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            } else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {},
            other;

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted =
                this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        // and further modified to allow for strings containing both week and day
        isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months,
            };
        } else if (isNumber(input) || !isNaN(+input)) {
            duration = {};
            if (key) {
                duration[key] = +input;
            } else {
                duration.milliseconds = +input;
            }
        } else if ((match = aspNetRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
            };
        } else if ((match = isoRegex.exec(input))) {
            sign = match[1] === '-' ? -1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign),
            };
        } else if (duration == null) {
            // checks for null or undefined
            duration = {};
        } else if (
            typeof duration === 'object' &&
            ('from' in duration || 'to' in duration)
        ) {
            diffRes = momentsDifference(
                createLocal(duration.from),
                createLocal(duration.to)
            );

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        if (isDuration(input) && hasOwnProp(input, '_isValid')) {
            ret._isValid = input._isValid;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months =
            other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +base.clone().add(res.months, 'M');

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return { milliseconds: 0, months: 0 };
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(
                    name,
                    'moment().' +
                        name +
                        '(period, number) is deprecated. Please use moment().' +
                        name +
                        '(number, period). ' +
                        'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                );
                tmp = val;
                val = period;
                period = tmp;
            }

            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add = createAdder(1, 'add'),
        subtract = createAdder(-1, 'subtract');

    function isString(input) {
        return typeof input === 'string' || input instanceof String;
    }

    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
    function isMomentInput(input) {
        return (
            isMoment(input) ||
            isDate(input) ||
            isString(input) ||
            isNumber(input) ||
            isNumberOrStringArray(input) ||
            isMomentInputObject(input) ||
            input === null ||
            input === undefined
        );
    }

    function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'years',
                'year',
                'y',
                'months',
                'month',
                'M',
                'days',
                'day',
                'd',
                'dates',
                'date',
                'D',
                'hours',
                'hour',
                'h',
                'minutes',
                'minute',
                'm',
                'seconds',
                'second',
                's',
                'milliseconds',
                'millisecond',
                'ms',
            ],
            i,
            property;

        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function isNumberOrStringArray(input) {
        var arrayTest = isArray(input),
            dataTypeTest = false;
        if (arrayTest) {
            dataTypeTest =
                input.filter(function (item) {
                    return !isNumber(item) && isString(input);
                }).length === 0;
        }
        return arrayTest && dataTypeTest;
    }

    function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input),
            propertyTest = false,
            properties = [
                'sameDay',
                'nextDay',
                'lastDay',
                'nextWeek',
                'lastWeek',
                'sameElse',
            ],
            i,
            property;

        for (i = 0; i < properties.length; i += 1) {
            property = properties[i];
            propertyTest = propertyTest || hasOwnProp(input, property);
        }

        return objectTest && propertyTest;
    }

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6
            ? 'sameElse'
            : diff < -1
            ? 'lastWeek'
            : diff < 0
            ? 'lastDay'
            : diff < 1
            ? 'sameDay'
            : diff < 2
            ? 'nextDay'
            : diff < 7
            ? 'nextWeek'
            : 'sameElse';
    }

    function calendar$1(time, formats) {
        // Support for single parameter, formats only overload to the calendar function
        if (arguments.length === 1) {
            if (!arguments[0]) {
                time = undefined;
                formats = undefined;
            } else if (isMomentInput(arguments[0])) {
                time = arguments[0];
                formats = undefined;
            } else if (isCalendarSpec(arguments[0])) {
                formats = arguments[0];
                time = undefined;
            }
        }
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse',
            output =
                formats &&
                (isFunction(formats[format])
                    ? formats[format].call(this, now)
                    : formats[format]);

        return this.format(
            output || this.localeData().calendar(format, this, createLocal(now))
        );
    }

    function clone() {
        return new Moment(this);
    }

    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween(from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (
            (inclusivity[0] === '('
                ? this.isAfter(localFrom, units)
                : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')'
                ? this.isBefore(localTo, units)
                : !this.isAfter(localTo, units))
        );
    }

    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return (
                this.clone().startOf(units).valueOf() <= inputMs &&
                inputMs <= this.clone().endOf(units).valueOf()
            );
        }
    }

    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
        var that, zoneDelta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year':
                output = monthDiff(this, that) / 12;
                break;
            case 'month':
                output = monthDiff(this, that);
                break;
            case 'quarter':
                output = monthDiff(this, that) / 3;
                break;
            case 'second':
                output = (this - that) / 1e3;
                break; // 1000
            case 'minute':
                output = (this - that) / 6e4;
                break; // 1000 * 60
            case 'hour':
                output = (this - that) / 36e5;
                break; // 1000 * 60 * 60
            case 'day':
                output = (this - that - zoneDelta) / 864e5;
                break; // 1000 * 60 * 60 * 24, negate dst
            case 'week':
                output = (this - that - zoneDelta) / 6048e5;
                break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default:
                output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
        if (a.date() < b.date()) {
            // end-of-month calculations work correct when the start month has more
            // days than the end month.
            return -monthDiff(b, a);
        }
        // difference in months
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true,
            m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(
                m,
                utc
                    ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                    : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                    .toISOString()
                    .replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(
            m,
            utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
        );
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect() {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment',
            zone = '',
            prefix,
            year,
            datetime,
            suffix;
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        prefix = '[' + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
        datetime = '-MM-DD[T]HH:mm:ss.SSS';
        suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc()
                ? hooks.defaultFormatUtc
                : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ to: this, from: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
        if (
            this.isValid() &&
            ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
        ) {
            return createDuration({ from: this, to: time })
                .locale(this.locale())
                .humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale(key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData() {
        return this._locale;
    }

    var MS_PER_SECOND = 1000,
        MS_PER_MINUTE = 60 * MS_PER_SECOND,
        MS_PER_HOUR = 60 * MS_PER_MINUTE,
        MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return ((dividend % divisor) + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(
                    this.year(),
                    this.month() - (this.month() % 3),
                    1
                );
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - this.weekday()
                );
                break;
            case 'isoWeek':
                time = startOfDate(
                    this.year(),
                    this.month(),
                    this.date() - (this.isoWeekday() - 1)
                );
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(
                    time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                    MS_PER_HOUR
                );
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time =
                    startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3) + 3,
                        1
                    ) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday() + 7
                    ) - 1;
                break;
            case 'isoWeek':
                time =
                    startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1) + 7
                    ) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time +=
                    MS_PER_HOUR -
                    mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    ) -
                    1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 60000;
    }

    function unix() {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
        return new Date(this.valueOf());
    }

    function toArray() {
        var m = this;
        return [
            m.year(),
            m.month(),
            m.date(),
            m.hour(),
            m.minute(),
            m.second(),
            m.millisecond(),
        ];
    }

    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds(),
        };
    }

    function toJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
        return isValid(this);
    }

    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict,
        };
    }

    addFormatToken('N', 0, 0, 'eraAbbr');
    addFormatToken('NN', 0, 0, 'eraAbbr');
    addFormatToken('NNN', 0, 0, 'eraAbbr');
    addFormatToken('NNNN', 0, 0, 'eraName');
    addFormatToken('NNNNN', 0, 0, 'eraNarrow');

    addFormatToken('y', ['y', 1], 'yo', 'eraYear');
    addFormatToken('y', ['yy', 2], 0, 'eraYear');
    addFormatToken('y', ['yyy', 3], 0, 'eraYear');
    addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

    addRegexToken('N', matchEraAbbr);
    addRegexToken('NN', matchEraAbbr);
    addRegexToken('NNN', matchEraAbbr);
    addRegexToken('NNNN', matchEraName);
    addRegexToken('NNNNN', matchEraNarrow);

    addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (
        input,
        array,
        config,
        token
    ) {
        var era = config._locale.erasParse(input, token, config._strict);
        if (era) {
            getParsingFlags(config).era = era;
        } else {
            getParsingFlags(config).invalidEra = input;
        }
    });

    addRegexToken('y', matchUnsigned);
    addRegexToken('yy', matchUnsigned);
    addRegexToken('yyy', matchUnsigned);
    addRegexToken('yyyy', matchUnsigned);
    addRegexToken('yo', matchEraYearOrdinal);

    addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
    addParseToken(['yo'], function (input, array, config, token) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
            match = input.match(config._locale._eraYearOrdinalRegex);
        }

        if (config._locale.eraYearOrdinalParse) {
            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
            array[YEAR] = parseInt(input, 10);
        }
    });

    function localeEras(m, format) {
        var i,
            l,
            date,
            eras = this._eras || getLocale('en')._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
            switch (typeof eras[i].since) {
                case 'string':
                    // truncate time
                    date = hooks(eras[i].since).startOf('day');
                    eras[i].since = date.valueOf();
                    break;
            }

            switch (typeof eras[i].until) {
                case 'undefined':
                    eras[i].until = +Infinity;
                    break;
                case 'string':
                    // truncate time
                    date = hooks(eras[i].until).startOf('day').valueOf();
                    eras[i].until = date.valueOf();
                    break;
            }
        }
        return eras;
    }

    function localeErasParse(eraName, format, strict) {
        var i,
            l,
            eras = this.eras(),
            name,
            abbr,
            narrow;
        eraName = eraName.toUpperCase();

        for (i = 0, l = eras.length; i < l; ++i) {
            name = eras[i].name.toUpperCase();
            abbr = eras[i].abbr.toUpperCase();
            narrow = eras[i].narrow.toUpperCase();

            if (strict) {
                switch (format) {
                    case 'N':
                    case 'NN':
                    case 'NNN':
                        if (abbr === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNN':
                        if (name === eraName) {
                            return eras[i];
                        }
                        break;

                    case 'NNNNN':
                        if (narrow === eraName) {
                            return eras[i];
                        }
                        break;
                }
            } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                return eras[i];
            }
        }
    }

    function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? +1 : -1;
        if (year === undefined) {
            return hooks(era.since).year();
        } else {
            return hooks(era.since).year() + (year - era.offset) * dir;
        }
    }

    function getEraName() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].name;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].name;
            }
        }

        return '';
    }

    function getEraNarrow() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].narrow;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].narrow;
            }
        }

        return '';
    }

    function getEraAbbr() {
        var i,
            l,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (eras[i].since <= val && val <= eras[i].until) {
                return eras[i].abbr;
            }
            if (eras[i].until <= val && val <= eras[i].since) {
                return eras[i].abbr;
            }
        }

        return '';
    }

    function getEraYear() {
        var i,
            l,
            dir,
            val,
            eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
            dir = eras[i].since <= eras[i].until ? +1 : -1;

            // truncate time
            val = this.clone().startOf('day').valueOf();

            if (
                (eras[i].since <= val && val <= eras[i].until) ||
                (eras[i].until <= val && val <= eras[i].since)
            ) {
                return (
                    (this.year() - hooks(eras[i].since).year()) * dir +
                    eras[i].offset
                );
            }
        }

        return this.year();
    }

    function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNameRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
    }

    function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, '_erasAbbrRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }

    function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, '_erasNarrowRegex')) {
            computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }

    function matchEraAbbr(isStrict, locale) {
        return locale.erasAbbrRegex(isStrict);
    }

    function matchEraName(isStrict, locale) {
        return locale.erasNameRegex(isStrict);
    }

    function matchEraNarrow(isStrict, locale) {
        return locale.erasNarrowRegex(isStrict);
    }

    function matchEraYearOrdinal(isStrict, locale) {
        return locale._eraYearOrdinalRegex || matchUnsigned;
    }

    function computeErasParse() {
        var abbrPieces = [],
            namePieces = [],
            narrowPieces = [],
            mixedPieces = [],
            i,
            l,
            eras = this.eras();

        for (i = 0, l = eras.length; i < l; ++i) {
            namePieces.push(regexEscape(eras[i].name));
            abbrPieces.push(regexEscape(eras[i].abbr));
            narrowPieces.push(regexEscape(eras[i].narrow));

            mixedPieces.push(regexEscape(eras[i].name));
            mixedPieces.push(regexEscape(eras[i].abbr));
            mixedPieces.push(regexEscape(eras[i].narrow));
        }

        this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
        this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
        this._erasNarrowRegex = new RegExp(
            '^(' + narrowPieces.join('|') + ')',
            'i'
        );
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);

    // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (
        input,
        week,
        config,
        token
    ) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy
        );
    }

    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
            this,
            input,
            this.isoWeek(),
            this.isoWeekday(),
            1,
            4
        );
    }

    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }

    function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
    }

    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter(input) {
        return input == null
            ? Math.ceil((this.month() + 1) / 3)
            : this.month((input - 1) * 3 + (this.month() % 3));
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict
            ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
            : locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear(input) {
        var dayOfYear =
            Math.round(
                (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
            ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });

    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);

    var token, getSetMillisecond;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }

    getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== 'undefined' && Symbol.for != null) {
        proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
            return 'Moment<' + this.format() + '>';
        };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
        'dates accessor is deprecated. Use date instead.',
        getSetDayOfMonth
    );
    proto.months = deprecate(
        'months accessor is deprecated. Use month instead',
        getSetMonth
    );
    proto.years = deprecate(
        'years accessor is deprecated. Use year instead',
        getSetYear
    );
    proto.zone = deprecate(
        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
        getSetZone
    );
    proto.isDSTShifted = deprecate(
        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
        isDaylightSavingTimeShifted
    );

    function createUnix(input) {
        return createLocal(input * 1000);
    }

    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;

    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;

    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
        var locale = getLocale(),
            utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i,
            out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0,
            i,
            out = [];

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        eras: [
            {
                since: '0001-01-01',
                until: +Infinity,
                offset: 1,
                name: 'Anno Domini',
                narrow: 'AD',
                abbr: 'AD',
            },
            {
                since: '0000-12-31',
                until: -Infinity,
                offset: 1,
                name: 'Before Christ',
                narrow: 'BC',
                abbr: 'BC',
            },
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (number) {
            var b = number % 10,
                output =
                    toInt((number % 100) / 10) === 1
                        ? 'th'
                        : b === 1
                        ? 'st'
                        : b === 2
                        ? 'nd'
                        : b === 3
                        ? 'rd'
                        : 'th';
            return number + output;
        },
    });

    // Side effect imports

    hooks.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        getSetGlobalLocale
    );
    hooks.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        getLocale
    );

    var mathAbs = Math.abs;

    function abs() {
        var data = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);

        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);

        return this;
    }

    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble() {
        var milliseconds = this._milliseconds,
            days = this._days,
            months = this._months,
            data = this._data,
            seconds,
            minutes,
            hours,
            years,
            monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (
            !(
                (milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0)
            )
        ) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;

        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;

        hours = absFloor(minutes / 60);
        data.hours = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days = days;
        data.months = months;
        data.years = years;

        return this;
    }

    function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return (days * 4800) / 146097;
    }

    function monthsToDays(months) {
        // the reverse of daysToMonths
        return (months * 146097) / 4800;
    }

    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days,
            months,
            milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':
                    return months;
                case 'quarter':
                    return months / 3;
                case 'year':
                    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week':
                    return days / 7 + milliseconds / 6048e5;
                case 'day':
                    return days + milliseconds / 864e5;
                case 'hour':
                    return days * 24 + milliseconds / 36e5;
                case 'minute':
                    return days * 1440 + milliseconds / 6e4;
                case 'second':
                    return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond':
                    return Math.floor(days * 864e5) + milliseconds;
                default:
                    throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1() {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs(alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms'),
        asSeconds = makeAs('s'),
        asMinutes = makeAs('m'),
        asHours = makeAs('h'),
        asDays = makeAs('d'),
        asWeeks = makeAs('w'),
        asMonths = makeAs('M'),
        asQuarters = makeAs('Q'),
        asYears = makeAs('y');

    function clone$1() {
        return createDuration(this);
    }

    function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds'),
        seconds = makeGetter('seconds'),
        minutes = makeGetter('minutes'),
        hours = makeGetter('hours'),
        days = makeGetter('days'),
        months = makeGetter('months'),
        years = makeGetter('years');

    function weeks() {
        return absFloor(this.days() / 7);
    }

    var round = Math.round,
        thresholds = {
            ss: 44, // a few seconds to seconds
            s: 45, // seconds to minute
            m: 45, // minutes to hour
            h: 22, // hours to day
            d: 26, // days to month/week
            w: null, // weeks to month
            M: 11, // months to year
        };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
        var duration = createDuration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            weeks = round(duration.as('w')),
            years = round(duration.as('y')),
            a =
                (seconds <= thresholds.ss && ['s', seconds]) ||
                (seconds < thresholds.s && ['ss', seconds]) ||
                (minutes <= 1 && ['m']) ||
                (minutes < thresholds.m && ['mm', minutes]) ||
                (hours <= 1 && ['h']) ||
                (hours < thresholds.h && ['hh', hours]) ||
                (days <= 1 && ['d']) ||
                (days < thresholds.d && ['dd', days]);

        if (thresholds.w != null) {
            a =
                a ||
                (weeks <= 1 && ['w']) ||
                (weeks < thresholds.w && ['ww', weeks]);
        }
        a = a ||
            (months <= 1 && ['M']) ||
            (months < thresholds.M && ['MM', months]) ||
            (years <= 1 && ['y']) || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof roundingFunction === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var withSuffix = false,
            th = thresholds,
            locale,
            output;

        if (typeof argWithSuffix === 'object') {
            argThresholds = argWithSuffix;
            argWithSuffix = false;
        }
        if (typeof argWithSuffix === 'boolean') {
            withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === 'object') {
            th = Object.assign({}, thresholds, argThresholds);
            if (argThresholds.s != null && argThresholds.ss == null) {
                th.ss = argThresholds.s - 1;
            }
        }

        locale = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return (x > 0) - (x < 0) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000,
            days = abs$1(this._days),
            months = abs$1(this._months),
            minutes,
            hours,
            years,
            s,
            total = this.asSeconds(),
            totalSign,
            ymSign,
            daysSign,
            hmsSign;

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

        totalSign = total < 0 ? '-' : '';
        ymSign = sign(this._months) !== sign(total) ? '-' : '';
        daysSign = sign(this._days) !== sign(total) ? '-' : '';
        hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return (
            totalSign +
            'P' +
            (years ? ymSign + years + 'Y' : '') +
            (months ? ymSign + months + 'M' : '') +
            (days ? daysSign + days + 'D' : '') +
            (hours || minutes || seconds ? 'T' : '') +
            (hours ? hmsSign + hours + 'H' : '') +
            (minutes ? hmsSign + minutes + 'M' : '') +
            (seconds ? hmsSign + s + 'S' : '')
        );
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;

    proto$2.toIsoString = deprecate(
        'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
        toISOString$1
    );
    proto$2.lang = lang;

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    //! moment.js

    hooks.version = '2.29.1';

    setHookCallback(createLocal);

    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD', // <input type="date" />
        TIME: 'HH:mm', // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW', // <input type="week" />
        MONTH: 'YYYY-MM', // <input type="month" />
    };

    return hooks;

})));


/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js":
/*!*********************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/CommonTypes.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComparisonType": () => (/* binding */ ComparisonType),
/* harmony export */   "ViewMode": () => (/* binding */ ViewMode),
/* harmony export */   "FieldLabelPosition": () => (/* binding */ FieldLabelPosition),
/* harmony export */   "UIFieldType": () => (/* binding */ UIFieldType),
/* harmony export */   "defaultGetValue": () => (/* binding */ defaultGetValue),
/* harmony export */   "DATA_ID_ATTRIBUTE": () => (/* binding */ DATA_ID_ATTRIBUTE),
/* harmony export */   "DRAGGABLE_KEY_ID": () => (/* binding */ DRAGGABLE_KEY_ID),
/* harmony export */   "DRAGGABLE_TYPE": () => (/* binding */ DRAGGABLE_TYPE),
/* harmony export */   "DRAGGABLE_FROM": () => (/* binding */ DRAGGABLE_FROM),
/* harmony export */   "ItemEventType": () => (/* binding */ ItemEventType),
/* harmony export */   "BasicKeyAction": () => (/* binding */ BasicKeyAction)
/* harmony export */ });
var ComparisonType;
(function (ComparisonType) {
    ComparisonType[ComparisonType["equals"] = 0] = "equals";
    ComparisonType[ComparisonType["lessThan"] = 1] = "lessThan";
    ComparisonType[ComparisonType["lessThanEqual"] = 2] = "lessThanEqual";
    ComparisonType[ComparisonType["greaterThan"] = 3] = "greaterThan";
    ComparisonType[ComparisonType["greaterThanEqual"] = 4] = "greaterThanEqual";
    ComparisonType[ComparisonType["isNull"] = 5] = "isNull";
    ComparisonType[ComparisonType["isNotNull"] = 6] = "isNotNull";
    ComparisonType[ComparisonType["hasValue"] = 7] = "hasValue";
    ComparisonType[ComparisonType["isNotValue"] = 8] = "isNotValue";
})(ComparisonType || (ComparisonType = {}));
var ViewMode;
(function (ViewMode) {
    ViewMode[ViewMode["unset"] = -1] = "unset";
    ViewMode[ViewMode["create"] = 0] = "create";
    ViewMode[ViewMode["update"] = 1] = "update";
    ViewMode[ViewMode["displayOnly"] = 2] = "displayOnly";
    ViewMode[ViewMode["any"] = 3] = "any";
})(ViewMode || (ViewMode = {}));
var FieldLabelPosition;
(function (FieldLabelPosition) {
    FieldLabelPosition[FieldLabelPosition["aboveField"] = 0] = "aboveField";
    FieldLabelPosition[FieldLabelPosition["inlineWithField"] = 1] = "inlineWithField";
    FieldLabelPosition[FieldLabelPosition["noLabel"] = 2] = "noLabel";
})(FieldLabelPosition || (FieldLabelPosition = {}));
var UIFieldType;
(function (UIFieldType) {
    UIFieldType[UIFieldType["checkbox"] = 0] = "checkbox";
    UIFieldType[UIFieldType["email"] = 1] = "email";
    UIFieldType[UIFieldType["hidden"] = 2] = "hidden";
    UIFieldType[UIFieldType["number"] = 3] = "number";
    UIFieldType[UIFieldType["password"] = 4] = "password";
    UIFieldType[UIFieldType["text"] = 5] = "text";
    UIFieldType[UIFieldType["textarea"] = 6] = "textarea";
    UIFieldType[UIFieldType["select"] = 7] = "select";
    UIFieldType[UIFieldType["radioGroup"] = 8] = "radioGroup";
    UIFieldType[UIFieldType["tableData"] = 9] = "tableData";
    UIFieldType[UIFieldType["list"] = 10] = "list";
    UIFieldType[UIFieldType["composite"] = 11] = "composite";
    UIFieldType[UIFieldType["linked"] = 12] = "linked";
    UIFieldType[UIFieldType["linkedList"] = 13] = "linkedList";
})(UIFieldType || (UIFieldType = {}));
const defaultGetValue = (fieldUIConfig, currentValue) => {
    let result = currentValue;
    if (fieldUIConfig.renderer) {
        let value = fieldUIConfig.renderer.renderValue(null, fieldUIConfig.field, currentValue);
        if (value)
            result = value;
    }
    if (!result) {
        result = '';
    }
    return result;
};
const DATA_ID_ATTRIBUTE = 'data-id';
const DRAGGABLE_KEY_ID = 'text/plain';
const DRAGGABLE_TYPE = 'draggedType';
const DRAGGABLE_FROM = 'draggedFrom';
//export type getIcons = (name: string, item: any) => string[];
var ItemEventType;
(function (ItemEventType) {
    ItemEventType["SHOWN"] = "shown";
    ItemEventType["HIDDEN"] = "hidden";
    ItemEventType["CANCELLING"] = "cancelling";
    ItemEventType["CANCELLING_ABORTED"] = "cancelling-aborted";
    ItemEventType["CANCELLED"] = "cancelled";
    ItemEventType["SAVING"] = "saving";
    ItemEventType["SAVE_ABORTED"] = "save-aborted";
    ItemEventType["SAVED"] = "saved";
    ItemEventType["DELETING"] = "deleting";
    ItemEventType["DELETE_ABORTED"] = "delete-aborted";
    ItemEventType["DELETED"] = "deleted";
    ItemEventType["CREATING"] = "creating";
    ItemEventType["MODIFYING"] = "modifying";
    ItemEventType["DISPLAYING_READ_ONLY"] = "readonly";
    ItemEventType["RESETTING"] = "reset";
    ItemEventType["COMPOSITE_EDIT"] = "composite-edit";
    ItemEventType["COMPOSITE_ARRAY_EDIT"] = "composite-array-edit";
    ItemEventType["LINKED_EDIT"] = "linked-edit";
    ItemEventType["LINKED_ARRAY_EDIT"] = "linked-array-edit";
    ItemEventType["FIELD_ACTION"] = "field-action";
})(ItemEventType || (ItemEventType = {}));
var BasicKeyAction;
(function (BasicKeyAction) {
    BasicKeyAction["ok"] = "OK";
    BasicKeyAction["cancel"] = "Cancel";
})(BasicKeyAction || (BasicKeyAction = {}));
//# sourceMappingURL=CommonTypes.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/jsx/JSXParser.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/jsx/JSXParser.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "jsxCreateElement": () => (/* binding */ jsxCreateElement),
/* harmony export */   "jsxCreateFragment": () => (/* binding */ jsxCreateFragment)
/* harmony export */ });
function jsxCreateElement(tag, props, ...children) {
    if (typeof tag === "function")
        return tag(props, ...children);
    const element = document.createElement(tag);
    Object.entries(props || {}).forEach(([name, value]) => {
        if (name.startsWith("on") && name.toLowerCase() in window)
            element.addEventListener(name.toLowerCase().substr(2), value);
        else {
            if (name === 'className')
                name = 'class';
            // @ts-ignore
            element.setAttribute(name, value.toString());
        }
    });
    children.forEach((child) => {
        jsxAppendChild(element, child);
    });
    return element;
}
function jsxAppendChild(parent, child) {
    if (Array.isArray(child))
        child.forEach(nestedChild => jsxAppendChild(parent, nestedChild));
    else
        parent.appendChild(child.nodeType ? child : document.createTextNode(child));
}
function jsxCreateFragment(props, ...children) {
    return children;
}
//# sourceMappingURL=JSXParser.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/model/AbstractFieldOperations.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/model/AbstractFieldOperations.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractFieldOperations": () => (/* binding */ AbstractFieldOperations)
/* harmony export */ });
class AbstractFieldOperations {
}
//# sourceMappingURL=AbstractFieldOperations.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/model/BasicFieldOperations.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/model/BasicFieldOperations.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BasicFieldOperations": () => (/* binding */ BasicFieldOperations)
/* harmony export */ });
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DataObjectTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectTypeDefs.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ui/ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var _security_SecurityManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../security/SecurityManager */ "./node_modules/ui-framework-jps/dist/framework/security/SecurityManager.js");
/* harmony import */ var _AbstractFieldOperations__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AbstractFieldOperations */ "./node_modules/ui-framework-jps/dist/framework/model/AbstractFieldOperations.js");







const flogger = debug__WEBPACK_IMPORTED_MODULE_2___default()('basic-field-operations-formatter');
const vlogger = debug__WEBPACK_IMPORTED_MODULE_2___default()('basic-field-operations-validator');
const glogger = debug__WEBPACK_IMPORTED_MODULE_2___default()('basic-field-operations-generator');
const rlogger = debug__WEBPACK_IMPORTED_MODULE_2___default()('basic-field-operations-renderer');
class BasicFieldOperations extends _AbstractFieldOperations__WEBPACK_IMPORTED_MODULE_5__.AbstractFieldOperations {
    constructor() {
        super();
    }
    static getInstance() {
        if (!(BasicFieldOperations._instance)) {
            BasicFieldOperations._instance = new BasicFieldOperations();
        }
        return BasicFieldOperations._instance;
    }
    setSubElements(elements) {
    }
    // called when saving, change to final values
    formatValue(field, currentValue) {
        flogger(`Handling format value for field ${field.displayName} with value ${currentValue}`);
        let result = currentValue;
        switch (field.type) { // only need to change dates
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.date): {
                //convert to underlying number format
                if (currentValue.trim().length === 10) {
                    result = parseInt(moment__WEBPACK_IMPORTED_MODULE_0___default()(currentValue, 'DD/MM/YYYY').format('YYYYMMDD'));
                }
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.datetime): {
                //convert to underlying number format
                if (currentValue.trim().length === 19) {
                    result = parseInt(moment__WEBPACK_IMPORTED_MODULE_0___default()(currentValue, 'DD/MM/YYYY HH:mm:ss').format('YYYYMMDDHHmmss'));
                }
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.time): {
                //convert to underlying number format
                if (currentValue.trim().length === 8) {
                    result = parseInt(moment__WEBPACK_IMPORTED_MODULE_0___default()(currentValue, 'HH:mm:ss').format('HHmmss'));
                }
                else if (currentValue.trim().length === 6) {
                    result = parseInt(moment__WEBPACK_IMPORTED_MODULE_0___default()(currentValue, 'HHmmss').format('HHmmss'));
                }
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.shortTime): {
                //convert to underlying number format
                if (currentValue.trim().length === 5) {
                    result = parseInt(moment__WEBPACK_IMPORTED_MODULE_0___default()(currentValue, 'HH:mm').format('HHmm'));
                }
                else if (currentValue.trim().length === 4) {
                    result = parseInt(moment__WEBPACK_IMPORTED_MODULE_0___default()(currentValue, 'HHmm').format('HHmm'));
                }
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.boolean): {
                result = (currentValue.toLowerCase() === 'true');
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.id): {
                if (field.idType === _ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_3__.KeyType.number) {
                    let parsed = parseInt(currentValue);
                    if (!isNaN(parsed)) {
                        result = parsed;
                    }
                }
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.float): {
                let parsed = parseFloat(currentValue);
                if (!isNaN(parsed)) {
                    result = parsed;
                }
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.integer): {
                let parsed = parseFloat(currentValue);
                if (!isNaN(parsed)) {
                    result = parsed;
                }
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.compositeObject):
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.compositeObjectArray):
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.linkedObject):
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.linkedObjectArray):
                {
                    try {
                        result = JSON.parse(currentValue);
                    }
                    catch (err) {
                        flogger(`Handling format value for field ${field.displayName} with value ${currentValue} - WAS NOT JSON`);
                        result = {};
                        if ((field.type === _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.linkedObjectArray) || (field.type === _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.compositeObjectArray)) {
                            result = [];
                        }
                    }
                    break;
                }
        }
        flogger(`Handling format value for field ${field.displayName} with value ${currentValue} - result is ${result}`);
        return result;
    }
    isValidValue(field, currentValue) {
        vlogger(`Handling is valid value for field ${field.displayName} with value ${currentValue}`);
        let response = {
            isValid: true,
            resetOnFailure: false
        };
        // basics first, is the field mandatory?
        if (field.mandatory) {
            // do we have any content?
            if ((!currentValue) || (currentValue.trim().length === 0)) {
                response.isValid = false;
                response.message = `${field.displayName} is required. Please enter a valid value.`;
                vlogger(`Handling is valid value for field ${field.displayName} with value ${currentValue} - is valid is ${response.isValid} with message ${response.message}`);
                return response;
            }
            // boolean is a special case, and must be true
            // if (field.type === FieldType.boolean) {
            //     if (currentValue.trim().toLowerCase() !== 'true') {
            //         response.isValid = false;
            //         response.message = `${field.displayName} is required and must be selected.`;
            //         vlogger(`Handling is valid value for field ${field.displayName} with value ${currentValue} - is valid is ${response.isValid} with message ${response.message}`);
            //         return response;
            //     }
            // }
        }
        // ok, so we have some content, we need to check if the value is a valid format with regular expressions
        if (currentValue) {
            switch (field.type) {
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.datetime): {
                    response.isValid = BasicFieldOperations.dateTimeRegex.test(currentValue);
                    if (!response.isValid) {
                        response.message = `${field.displayName} must be DD/MM/YYYY hh:mm`;
                    }
                    break;
                }
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.date): {
                    response.isValid = BasicFieldOperations.dateRegex.test(currentValue);
                    if (!response.isValid) {
                        response.message = `${field.displayName} must be DD/MM/YYYY`;
                    }
                    break;
                }
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.float): {
                    response.isValid = BasicFieldOperations.floatRegexp.test(currentValue);
                    if (!response.isValid) {
                        response.message = `${field.displayName} must be 00.00`;
                    }
                    break;
                }
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.id): {
                    response.isValid = BasicFieldOperations.integerRegex.test(currentValue);
                    if (!response.isValid) {
                        response.message = `${field.displayName} must be an integer`;
                    }
                    break;
                }
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.email): {
                    response.isValid = BasicFieldOperations.emailRegex.test(currentValue);
                    if (!response.isValid) {
                        response.message = `${field.displayName} must be an email address`;
                    }
                    break;
                }
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.integer): {
                    response.isValid = BasicFieldOperations.integerRegex.test(currentValue);
                    if (!response.isValid) {
                        response.message = `${field.displayName} must be an integer`;
                    }
                    break;
                }
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.text): {
                    break;
                }
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.password): {
                    response.isValid = BasicFieldOperations.basicPasswordRegex.test(currentValue);
                    if (!response.isValid) {
                        response.message = `${field.displayName} must be 8 to 15 letters and digits only`;
                    }
                    break;
                }
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.time): {
                    response.isValid = BasicFieldOperations.timeRegex.test(currentValue);
                    if (!response.isValid) {
                        response.message = `${field.displayName} must be 24 hour time format HH:MM:SS`;
                    }
                    break;
                }
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.shortTime): {
                    response.isValid = BasicFieldOperations.shortTimeRegex.test(currentValue);
                    if (!response.isValid) {
                        response.message = `${field.displayName} must be 24 hour time format HH:MM`;
                    }
                    break;
                }
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.duration): {
                    response.isValid = BasicFieldOperations.durationRegexp.test(currentValue);
                    if (!response.isValid) {
                        response.message = `${field.displayName} must be in the format MM:SS or 999:MM:SS`;
                    }
                    break;
                }
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.boolean): {
                    response.isValid = BasicFieldOperations.booleanRegexp.test(currentValue);
                    if (!response.isValid) {
                        response.message = `${field.displayName} must be true or false`;
                    }
                    break;
                }
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.colour): {
                    response.isValid = BasicFieldOperations.colourRegexp.test(currentValue);
                    if (!response.isValid) {
                        response.message = `${field.displayName} must be a hex colour value #ffffff`;
                    }
                    break;
                }
            }
        }
        vlogger(`Handling is valid value for field ${field.displayName} with value ${currentValue} - is valid is ${response.isValid} with message ${response.message}`);
        return response;
    }
    renderValue(field, fieldDef, currentValue) {
        rlogger(`Rendering value for field ${fieldDef.displayName} with new value ${currentValue}`);
        if (currentValue) { // only attempt to render non-empty dates
            let newValue = currentValue;
            switch (fieldDef.type) {
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.date): {
                    currentValue += '';
                    if (currentValue.trim().length === 8) {
                        newValue = moment__WEBPACK_IMPORTED_MODULE_0___default()(currentValue, 'YYYYMMDD').format('DD/MM/YYYY');
                    }
                    else {
                        newValue = '';
                    }
                    break;
                }
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.time): {
                    currentValue += '';
                    if (currentValue.trim().length === 6) {
                        newValue = moment__WEBPACK_IMPORTED_MODULE_0___default()(currentValue, 'HHmmss').format('HH:mm:ss');
                    }
                    else if (currentValue.trim().length === 8) {
                        newValue = moment__WEBPACK_IMPORTED_MODULE_0___default()(currentValue, 'HH:mm:ss').format('HH:mm:ss');
                    }
                    else {
                        newValue = '';
                    }
                    break;
                }
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.shortTime): {
                    currentValue += '';
                    if (currentValue.trim().length === 4) {
                        newValue = moment__WEBPACK_IMPORTED_MODULE_0___default()(currentValue, 'HHmm').format('HH:mm');
                    }
                    else if (currentValue.trim().length === 5) {
                        newValue = moment__WEBPACK_IMPORTED_MODULE_0___default()(currentValue, 'HH:mm').format('HH:mm');
                    }
                    else {
                        newValue = '';
                    }
                    break;
                }
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.datetime): {
                    currentValue += '';
                    if (currentValue.trim().length === 14) {
                        newValue = moment__WEBPACK_IMPORTED_MODULE_0___default()(currentValue, 'YYYYMMDDHHmmss').format('DD/MM/YYYY HH:mm:ss');
                    }
                    else {
                        newValue = '';
                    }
                    break;
                }
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.compositeObject):
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.compositeObjectArray):
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.linkedObject):
                case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.linkedObjectArray):
                    {
                        newValue = JSON.stringify(currentValue);
                        break;
                    }
                default: {
                    if (currentValue) {
                        newValue = currentValue;
                    }
                    else {
                        newValue = '';
                    }
                }
            }
            // store the previous value
            // this.setPreviousValue(fieldDef, newValue);
            rlogger(`Rendering value for field ${fieldDef.displayName} with new value ${currentValue} - rendered to ${newValue}`);
            return newValue;
        }
        else {
            // empty value, no rendering required
            rlogger(`Rendering value for field ${fieldDef.displayName} with new value is empty - no rendering required`);
            return null;
        }
    }
    generate(field, isCreate) {
        let result = '';
        // are we generating the field?
        if (field.generator) {
            // are we only generating on create
            if (field.generator.onCreation && isCreate) {
                result = this.generateValue(field);
                glogger(`Generating value for field ${field.displayName} with on creation ${result}`);
            }
            // or if we are modifying and should also be modifying the value
            if (field.generator.onModify && !isCreate) {
                result = this.generateValue(field);
                glogger(`Generating value for field ${field.displayName} with on modify ${result}`);
            }
        }
        return result;
    }
    // private setPreviousValue(field: FieldDefinition, newValue: string) {
    //     rlogger(`Storing previous value for field ${field.displayName} with  new value ${newValue}`);
    //     let fieldValue: FieldNameValue;
    //
    //     let index = this.previousFieldValues.findIndex((fieldValue) => fieldValue.id === field.id);
    //     if (index >= 0) {
    //         //we have a previous value
    //         fieldValue = this.previousFieldValues[index];
    //         rlogger(`Storing previous value for field ${field.displayName} with new value ${newValue} - old value was ${fieldValue}`);
    //         fieldValue.value = newValue;
    //     } else {
    //         // create a new record of the value
    //         fieldValue = {
    //             id: field.id,
    //             value: newValue
    //         }
    //         rlogger(`Storing previous value for field ${field.displayName} with new value ${newValue} - NO previous`);
    //         this.previousFieldValues.push(fieldValue);
    //     }
    // }
    generateValue(field) {
        let result = '';
        switch (field.type) {
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.datetime): {
                result = moment__WEBPACK_IMPORTED_MODULE_0___default()().format('YYYYMMDDHHmmss');
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.date): {
                result = moment__WEBPACK_IMPORTED_MODULE_0___default()().format('YYYYMMDD');
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.float): {
                result = '0.0';
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.id): {
                result = '-1';
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.email): {
                result = 'me@me.com';
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.integer): {
                result = '0';
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.text): {
                result = '';
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.password): {
                result = '';
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.time): {
                result = moment__WEBPACK_IMPORTED_MODULE_0___default()().format('HH:mm:ss');
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.shortTime): {
                result = moment__WEBPACK_IMPORTED_MODULE_0___default()().format('HH:mm');
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.duration): {
                result = '00:00';
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.boolean): {
                result = 'false';
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.uuid): {
                result = (0,uuid__WEBPACK_IMPORTED_MODULE_6__["default"])();
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.userId): {
                result = `${_security_SecurityManager__WEBPACK_IMPORTED_MODULE_4__.SecurityManager.getInstance().getLoggedInUsername()}`;
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.colour): {
                result = `#ffffff`;
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.compositeObjectArray):
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.linkedObjectArray): {
                result = JSON.stringify([]);
                break;
            }
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.compositeObject):
            case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.linkedObject): {
                result = JSON.stringify({});
                break;
            }
        }
        return result;
    }
}
BasicFieldOperations.dateRegex = /^((0?[1-9]|[12]\d|30|31)\/(0?[13578]|1[012])\/(\d{2}|\d{4})|(0?[1-9]|[12]\d|30)\/(0?[469]|11])\/(\d{2}|\d{4})|(0?[1-9]|1\d|2[0-8])\/02\/(\d{2}|\d{4})|(29\/02\/(\d{2})?(0[48]|[2468][048]|[13579][26]))|(29\/02\/([02468][048]|[13579][26])00))$/;
BasicFieldOperations.emailRegex = /^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()\.,;\s@\"]+\.{0,1})+([^<>()\.,;:\s@\"]{2,}|[\d\.]+))$/;
BasicFieldOperations.shortTimeRegex = /^([01]\d|2[0-3]):?([0-5]\d)$/;
BasicFieldOperations.timeRegex = /^([01]\d|2[0-3]):?([0-5]\d):?([0-5]\d)$/;
BasicFieldOperations.dateTimeRegex = /^((0?[1-9]|[12]\d|30|31)\/(0?[13578]|1[012])\/(\d{2}|\d{4})|(0?[1-9]|[12]\d|30)\/(0?[469]|11])\/(\d{2}|\d{4})|(0?[1-9]|1\d|2[0-8])\/02\/(\d{2}|\d{4})|(29\/02\/(\d{2})?(0[48]|[2468][048]|[13579][26]))|(29\/02\/([02468][048]|[13579][26])00))\s([01]\d|2[0-3]):?([0-5]\d):?([0-5]\d)$/;
BasicFieldOperations.basicPasswordRegex = /^[a-zA-Z0-9]{8,15}$/;
BasicFieldOperations.integerRegex = /^[+-]?\d+$/;
BasicFieldOperations.floatRegexp = /^[+-]?\d+(\.\d+)?$/;
BasicFieldOperations.booleanRegexp = /^true|false$/;
BasicFieldOperations.durationRegexp = /^(\d+:)?[0-5]?\d:[0-5]\d$/;
BasicFieldOperations.colourRegexp = /^#[0-9a-f]{6}$/;
//# sourceMappingURL=BasicFieldOperations.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/model/BasicObjectDefinitionFactory.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/model/BasicObjectDefinitionFactory.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FIELD_ID": () => (/* binding */ FIELD_ID),
/* harmony export */   "FIELD_CreatedBy": () => (/* binding */ FIELD_CreatedBy),
/* harmony export */   "FIELD_ModifiedBy": () => (/* binding */ FIELD_ModifiedBy),
/* harmony export */   "FIELD_CreatedOn": () => (/* binding */ FIELD_CreatedOn),
/* harmony export */   "FIELD_ModifiedOn": () => (/* binding */ FIELD_ModifiedOn),
/* harmony export */   "FIELD_CreatedBy_Desc": () => (/* binding */ FIELD_CreatedBy_Desc),
/* harmony export */   "FIELD_ModifiedBy_Desc": () => (/* binding */ FIELD_ModifiedBy_Desc),
/* harmony export */   "FIELD_CreatedOn_Desc": () => (/* binding */ FIELD_CreatedOn_Desc),
/* harmony export */   "FIELD_ModifiedOn_Desc": () => (/* binding */ FIELD_ModifiedOn_Desc),
/* harmony export */   "BasicObjectDefinitionFactory": () => (/* binding */ BasicObjectDefinitionFactory)
/* harmony export */ });
/* harmony import */ var _ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ui/ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var _BasicFieldOperations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BasicFieldOperations */ "./node_modules/ui-framework-jps/dist/framework/model/BasicFieldOperations.js");
/* harmony import */ var _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DataObjectTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectTypeDefs.js");
/* harmony import */ var _DefaultDataObjectStringifier__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DefaultDataObjectStringifier */ "./node_modules/ui-framework-jps/dist/framework/model/DefaultDataObjectStringifier.js");




const FIELD_ID = 'id';
const FIELD_CreatedBy = 'createdBy';
const FIELD_ModifiedBy = 'modifiedBy';
const FIELD_CreatedOn = 'createdOn';
const FIELD_ModifiedOn = 'modifiedOn';
const FIELD_CreatedBy_Desc = 'Created By';
const FIELD_ModifiedBy_Desc = 'Last Modified By';
const FIELD_CreatedOn_Desc = 'Created On';
const FIELD_ModifiedOn_Desc = 'Last Modified On';
class BasicObjectDefinitionFactory {
    constructor() {
        this.ops = new _BasicFieldOperations__WEBPACK_IMPORTED_MODULE_1__.BasicFieldOperations();
    }
    static getInstance() {
        if (!(BasicObjectDefinitionFactory._instance)) {
            BasicObjectDefinitionFactory._instance = new BasicObjectDefinitionFactory();
        }
        return BasicObjectDefinitionFactory._instance;
    }
    generateStartingDisplayOrder(dataObjDef) {
        let result = [];
        dataObjDef.fields.forEach((fieldDef, index) => {
            let order = {
                fieldId: fieldDef.id,
                displayOrder: index
            };
            // is this the created or modified date
            if (fieldDef.id === FIELD_CreatedOn) {
                order.displayOrder += 100;
            }
            if (fieldDef.id === FIELD_ModifiedOn) {
                order.displayOrder += 101;
            }
            if (fieldDef.type === _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.userId) {
                order.displayOrder += 100;
            }
            result.push(order);
        });
        return result;
    }
    createBasicObjectDefinition(id, displayName, hasDataId, dataIdIsUUID, createModifierFields = true, idFieldName = FIELD_ID) {
        let objDef = {
            id: id,
            displayName: displayName,
            convertToString: new _DefaultDataObjectStringifier__WEBPACK_IMPORTED_MODULE_3__.DefaultDataObjectStringifier(),
            fields: []
        };
        // do we need an id field?
        if (hasDataId) {
            let fieldType = _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.id;
            if (dataIdIsUUID) {
                fieldType = _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.uuid;
            }
            let fieldDef = {
                id: idFieldName,
                isKey: true,
                idType: _ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.KeyType.number,
                type: fieldType,
                displayName: 'Id',
                mandatory: true,
                generator: {
                    generator: this.ops,
                    onModify: false,
                    onCreation: true
                }
            };
            objDef.fields.push(fieldDef);
        }
        // add fields for created and modified
        if (createModifierFields) {
            this.addCreatedDateToArray(objDef.fields);
            this.addCreatedByToArray(objDef.fields);
            this.addModifiedByToArray(objDef.fields);
            this.addModifiedDateToArray(objDef.fields);
        }
        return objDef;
    }
    addStringFieldToObjDefinition(objDef, id, displayName, type, isMandatory = false, description = null, datasource = null) {
        return this.addStringFieldToArray(objDef.fields, id, displayName, type, isMandatory, description, datasource);
    }
    addAnyFieldToObjDefinition(objDef, id, displayName) {
        return this.addStringFieldToArray(objDef.fields, id, displayName, _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.ANY, false);
    }
    addNumericFieldToObjDefinition(objDef, id, displayName, type, isMandatory = false, description = null, datasource = null) {
        return this.addNumericFieldToArray(objDef.fields, id, displayName, type, isMandatory, description, datasource);
    }
    addDerivedFieldToObjDefinition(objDef, id, displayName, type, keyType, calculator, isMandatory = false, description = null, dataSource = null) {
        let fieldDef;
        if (keyType === _ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.KeyType.number) {
            fieldDef = this.addNumericFieldToObjDefinition(objDef, id, displayName, type, isMandatory, description, dataSource);
        }
        else {
            fieldDef = this.addStringFieldToObjDefinition(objDef, id, displayName, type, isMandatory, description, dataSource);
        }
        fieldDef.derivedValue = calculator;
        return fieldDef;
    }
    addCreatedDateToArray(fields) {
        let fieldDef = this.addStringFieldToArray(fields, FIELD_CreatedOn, FIELD_CreatedOn_Desc, _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.datetime, true, FIELD_CreatedOn_Desc);
        // add generator
        fieldDef.generator = {
            generator: this.ops,
            onCreation: true,
            onModify: false
        };
        fieldDef.displayOnly = true;
    }
    addModifiedDateToArray(fields) {
        let fieldDef = this.addStringFieldToArray(fields, FIELD_ModifiedOn, FIELD_ModifiedOn_Desc, _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.datetime, true, FIELD_ModifiedOn_Desc);
        // add generator
        fieldDef.generator = {
            generator: this.ops,
            onCreation: true,
            onModify: true
        };
        fieldDef.displayOnly = true;
    }
    addCreatedByToArray(fields) {
        let fieldDef = this.addNumericFieldToArray(fields, FIELD_CreatedBy, FIELD_CreatedBy_Desc, _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.userId, true, FIELD_CreatedBy_Desc);
        // add generator
        fieldDef.generator = {
            generator: this.ops,
            onCreation: true,
            onModify: false
        };
        fieldDef.displayOnly = true;
    }
    addModifiedByToArray(fields) {
        let fieldDef = this.addStringFieldToArray(fields, FIELD_ModifiedBy, FIELD_ModifiedBy_Desc, _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.userId, true, FIELD_ModifiedBy_Desc);
        // add generator
        fieldDef.generator = {
            generator: this.ops,
            onCreation: true,
            onModify: true
        };
        fieldDef.displayOnly = true;
    }
    addFieldToArray(fields, keyType, id, displayName, type, isMandatory = false, description = null, datasource = null) {
        let fieldDef = {
            id: id,
            isKey: false,
            idType: keyType,
            type: type,
            displayName: displayName,
            mandatory: isMandatory,
            displayOnly: false,
        };
        if (isMandatory) {
            // add generator
            fieldDef.generator = {
                generator: this.ops,
                onCreation: true,
                onModify: false
            };
        }
        if (description)
            fieldDef.description = description;
        if (datasource)
            fieldDef.dataSource = datasource;
        fields.push(fieldDef);
        return fieldDef;
    }
    addStringFieldToArray(fields, id, displayName, type, isMandatory = false, description = null, datasource = null) {
        return this.addFieldToArray(fields, _ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.KeyType.string, id, displayName, type, isMandatory, description, datasource);
    }
    addNumericFieldToArray(fields, id, displayName, type, isMandatory = false, description = null, datasource = null) {
        return this.addFieldToArray(fields, _ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.KeyType.string, id, displayName, type, isMandatory, description, datasource);
    }
}
//# sourceMappingURL=BasicObjectDefinitionFactory.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectController.js":
/*!************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/model/DataObjectController.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataObjectController": () => (/* binding */ DataObjectController)
/* harmony export */ });
class DataObjectController {
    constructor(typeName) {
        this.isCreatingNew = false;
        this.typeName = typeName;
        this.listeners = [];
    }
    addListener(listener) {
        this.listeners.push(listener);
    }
    startNewObject(dataObj) {
        let result = false;
        if (!this.isCreatingNew) {
            result = this._startNewObject(dataObj);
            this.isCreatingNew = result;
        }
        return result;
    }
    isCreatingNewObject() {
        return this.isCreatingNew;
    }
    informListenersOfCreate(dataObj) {
        this.isCreatingNew = false;
        this.listeners.forEach((listener) => listener.create(this, this.typeName, dataObj));
    }
    informListenersOfUpdate(dataObj) {
        this.isCreatingNew = false;
        this.listeners.forEach((listener) => listener.update(this, this.typeName, dataObj));
    }
    informListenersOfDelete(dataObj) {
        this.isCreatingNew = false;
        this.listeners.forEach((listener) => listener.delete(this, this.typeName, dataObj));
    }
}
//# sourceMappingURL=DataObjectController.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectFactory.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/model/DataObjectFactory.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataObjectFactory": () => (/* binding */ DataObjectFactory)
/* harmony export */ });
/* harmony import */ var _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DataObjectTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectTypeDefs.js");
/* harmony import */ var _BasicFieldOperations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BasicFieldOperations */ "./node_modules/ui-framework-jps/dist/framework/model/BasicFieldOperations.js");
/* harmony import */ var _DefaultDataObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DefaultDataObject */ "./node_modules/ui-framework-jps/dist/framework/model/DefaultDataObject.js");
/* harmony import */ var _ObjectDefinitionRegistry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ObjectDefinitionRegistry */ "./node_modules/ui-framework-jps/dist/framework/model/ObjectDefinitionRegistry.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _DefinitionNotFoundError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DefinitionNotFoundError */ "./node_modules/ui-framework-jps/dist/framework/model/DefinitionNotFoundError.js");






const logger = debug__WEBPACK_IMPORTED_MODULE_4___default()('data-object-factory');
class DataObjectFactory {
    constructor() {
        DataObjectFactory.fieldOps = new _BasicFieldOperations__WEBPACK_IMPORTED_MODULE_1__.BasicFieldOperations();
    }
    static getInstance() {
        if (!(DataObjectFactory._instance)) {
            DataObjectFactory._instance = new DataObjectFactory();
        }
        return DataObjectFactory._instance;
    }
    createDataObjectFromDataAndDef(def, data, isComplete, fieldOps) {
        let result;
        let localFieldOps;
        if (fieldOps) {
            localFieldOps = fieldOps;
        }
        else {
            localFieldOps = DataObjectFactory.fieldOps;
        }
        result = new _DefaultDataObject__WEBPACK_IMPORTED_MODULE_2__.DefaultDataObject(def, data, localFieldOps);
        if (isComplete) {
            result.setComplete();
        }
        return result;
    }
    createDataObjectFromData(stateName, data, isComplete, fieldOps) {
        const def = _ObjectDefinitionRegistry__WEBPACK_IMPORTED_MODULE_3__.ObjectDefinitionRegistry.getInstance().findDefinition(stateName);
        if (def) {
            let localData = {};
            if (data) {
                localData = data;
            }
            return this.createDataObjectFromDataAndDef(def, localData, isComplete, fieldOps);
        }
        else {
            logger(`Not definition found for state name ${stateName}`);
            return data;
        }
    }
    createDataObjectsFromStateNameAndData(stateName, datas, isComplete, fieldOps) {
        let results = [];
        const def = _ObjectDefinitionRegistry__WEBPACK_IMPORTED_MODULE_3__.ObjectDefinitionRegistry.getInstance().findDefinition(stateName);
        if (def) {
            if (datas) {
                datas.forEach((data) => {
                    results.push(this.createDataObjectFromDataAndDef(def, data, isComplete, fieldOps));
                });
            }
        }
        else {
            logger(`Not definition found for state name ${stateName}`);
            results = datas;
        }
        return results;
    }
    instance(def, fieldOps) {
        logger(`Creating instance for definition ${def.id}`);
        let data = {};
        let localFieldOps = DataObjectFactory.fieldOps;
        if (fieldOps) {
            localFieldOps = fieldOps;
        }
        def.fields.forEach((fieldDef) => {
            if (fieldDef.generator && fieldDef.generator.onCreation) {
                let fieldValue = fieldDef.generator.generator.generate(fieldDef, true);
                switch (fieldDef.type) {
                    case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.date):
                    case (_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.datetime): {
                        break;
                    }
                    default: {
                        fieldValue = localFieldOps.formatValue(fieldDef, fieldValue);
                        break;
                    }
                }
                logger(`Setting default values for ${fieldDef.displayName} to ${fieldValue}`);
                data[fieldDef.id] = fieldValue;
            }
            if (fieldDef.type === _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.compositeObject) {
                if (fieldDef.linkedDataObjectDefinitionName) {
                    const compositeDef = _ObjectDefinitionRegistry__WEBPACK_IMPORTED_MODULE_3__.ObjectDefinitionRegistry.getInstance().findDefinition(fieldDef.linkedDataObjectDefinitionName);
                    if (compositeDef) {
                        const compositeDataObj = DataObjectFactory.getInstance().instance(compositeDef, localFieldOps);
                        data[fieldDef.id] = compositeDataObj;
                    }
                    else {
                        logger(`No definition found for composite object ${fieldDef.id} with linked def ${fieldDef.linkedDataObjectDefinitionName}`);
                        throw new _DefinitionNotFoundError__WEBPACK_IMPORTED_MODULE_5__.DefinitionNotFoundError(`No definition found for composite object ${fieldDef.id} with linked def ${fieldDef.linkedDataObjectDefinitionName}`);
                    }
                }
                else {
                    data[fieldDef.id] = {};
                }
            }
            if (fieldDef.type === _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.compositeObjectArray) {
                data[fieldDef.id] = [];
            }
            if (fieldDef.type === _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.linkedObject) {
                data[fieldDef.id] = ''; //will end up being uuid of a linked object
            }
            if (fieldDef.type === _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.linkedObjectArray) {
                data[fieldDef.id] = []; //will end up being array of uuids of a linked objects
            }
        });
        const dataObj = new _DefaultDataObject__WEBPACK_IMPORTED_MODULE_2__.DefaultDataObject(def, data, localFieldOps);
        dataObj.setPersisted(false);
        dataObj.setNew();
        return dataObj;
    }
}
//# sourceMappingURL=DataObjectFactory.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectPersistenceManager.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/model/DataObjectPersistenceManager.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataObjectPersistenceManager": () => (/* binding */ DataObjectPersistenceManager)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);

const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('data-object-persistence-manager');
class DataObjectPersistenceManager {
    constructor() {
        this.typeManagers = [];
    }
    static getInstance() {
        if (!(DataObjectPersistenceManager._instance)) {
            DataObjectPersistenceManager._instance = new DataObjectPersistenceManager();
        }
        return DataObjectPersistenceManager._instance;
    }
    addStateManagerForDataObjectType(type, manager) {
        this.typeManagers.push({ type, manager });
    }
    persist(dataObj) {
        // can only persist complete and changed objects
        logger(`Persisting data object ${dataObj.toString()}`);
        if (dataObj.isComplete() && dataObj.hasChanged()) {
            const def = dataObj.getDefinition();
            const foundIndex = this.typeManagers.findIndex((managerForType) => managerForType.type === def.id);
            if (foundIndex >= 0) {
                const stateManager = this.typeManagers[foundIndex].manager;
                if (dataObj.isNew()) {
                    stateManager.addNewItemToState(def.id, dataObj.getData(), false);
                }
                else {
                    stateManager.updateItemInState(def.id, dataObj.getData(), false);
                }
                dataObj.setPersisted(true);
            }
            else {
                logger(`Persisting data object ${dataObj.toString()} - NOT PERFORMED - no configured state manager for type ${def.id}`);
            }
        }
        else {
            logger(`Persisting data object ${dataObj.toString()} - NOT PERFORMED - not complete or no changes`);
        }
    }
    delete(dataObj) {
        // can only delete complete
        logger(`Deleting data object ${dataObj.toString()}`);
        if (dataObj.isComplete()) {
            const def = dataObj.getDefinition();
            const foundIndex = this.typeManagers.findIndex((managerForType) => managerForType.type === def.id);
            if (foundIndex >= 0) {
                const stateManager = this.typeManagers[foundIndex].manager;
                stateManager.removeItemFromState(def.id, dataObj.getData(), false);
            }
            else {
                logger(`Persisting data object ${dataObj.toString()} - NOT PERFORMED - no configured state manager for type ${def.id}`);
            }
        }
        else {
            logger(`Delete data object ${dataObj.toString()} - NOT PERFORMED - not complete`);
        }
    }
}
//# sourceMappingURL=DataObjectPersistenceManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectTypeDefs.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/model/DataObjectTypeDefs.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FieldType": () => (/* binding */ FieldType)
/* harmony export */ });
var FieldType;
(function (FieldType) {
    FieldType["id"] = "Id";
    FieldType["uuid"] = "UUID";
    FieldType["text"] = "Text";
    FieldType["integer"] = "Integer";
    FieldType["float"] = "Number";
    FieldType["date"] = "Date";
    FieldType["time"] = "Time";
    FieldType["shortTime"] = "Short Time";
    FieldType["datetime"] = "Datetime";
    FieldType["email"] = "Email";
    FieldType["password"] = "Password";
    FieldType["boolean"] = "True/False";
    FieldType["userId"] = "User";
    FieldType["choice"] = "Choice";
    FieldType["limitedChoice"] = "Limited Choice";
    FieldType["largeText"] = "TextArea";
    FieldType["duration"] = "Duration";
    FieldType["colour"] = "Colour";
    FieldType["compositeObject"] = "Sub Object";
    FieldType["compositeObjectArray"] = "Sub Object Array";
    FieldType["linkedObject"] = "Linked Object";
    FieldType["linkedObjectArray"] = "Linked Object Array";
    FieldType["ANY"] = "ANY";
})(FieldType || (FieldType = {}));
//# sourceMappingURL=DataObjectTypeDefs.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/model/DefaultDataObject.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/model/DefaultDataObject.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultDataObject": () => (/* binding */ DefaultDataObject)
/* harmony export */ });
/* harmony import */ var _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DataObjectTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectTypeDefs.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _util_MiscFunctions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/MiscFunctions */ "./node_modules/ui-framework-jps/dist/framework/util/MiscFunctions.js");
/* harmony import */ var _DataObjectFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DataObjectFactory */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectFactory.js");
/* harmony import */ var _DataObjectPersistenceManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DataObjectPersistenceManager */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectPersistenceManager.js");





const logger = debug__WEBPACK_IMPORTED_MODULE_1___default()('default-data-object');
class DefaultDataObject {
    constructor(definition, data, fieldOps) {
        this.bIsPersisted = true;
        this.bIsComplete = true;
        this.bHasChanged = false;
        this.bIsNew = false;
        this.data = data;
        Object.assign(this, data);
        this.definition = definition;
        this.fieldOps = fieldOps;
        this.setPersisted(true);
    }
    isNew() {
        return this.bIsNew;
    }
    setPersisted(persisted) {
        this.bHasChanged = !persisted;
        this.bIsPersisted = persisted;
        this.bIsComplete = persisted;
        this.bIsNew = !persisted;
    }
    setComplete() {
        this.bIsComplete = true;
    }
    hasChanged() {
        return this.bHasChanged;
    }
    toString() {
        return this.getDefinition().convertToString.toString(this);
    }
    isEqual(secondDataObj) {
        let result = false;
        if (this.getTypeName() === secondDataObj.getTypeName()) {
            if (this.getUniqueId() === secondDataObj.getUniqueId()) {
                result = true;
            }
        }
        return result;
    }
    getDefinition() {
        return this.definition;
    }
    getDescription() {
        return this.getDefinition().convertToString.getDescription(this.data);
    }
    getTypeName() {
        return this.getDefinition().id;
    }
    getUniqueId() {
        let result = '';
        let done = false;
        let index = 0;
        while (!done) {
            if (index < this.definition.fields.length) {
                const fieldDef = this.definition.fields[index];
                if ((fieldDef.type === _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.uuid) || (fieldDef.type === _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.id)) {
                    const value = this.getValue(fieldDef.id);
                    if (value) {
                        result = value + '';
                    }
                    done = true;
                }
            }
            else {
                done = true;
            }
        }
        return result;
    }
    getValue(fieldName) {
        let result = '';
        const foundIndex = this.definition.fields.findIndex((field) => field.id === fieldName);
        if (foundIndex >= 0) {
            const fieldDef = this.definition.fields[foundIndex];
            const value = this.data[fieldName];
            result = this.fieldOps.renderValue(null, fieldDef, value);
        }
        return result;
    }
    isComplete() {
        return this.bIsComplete;
    }
    isPersisted() {
        return this.bIsPersisted;
    }
    setValue(fieldName, value) {
        const foundIndex = this.definition.fields.findIndex((field) => field.id === fieldName);
        if (foundIndex >= 0) {
            const fieldDef = this.definition.fields[foundIndex];
            const value = this.data[fieldName];
            const newValue = this.fieldOps.formatValue(fieldDef, value);
            this.data[fieldName] = newValue;
            // @ts-ignore
            this[fieldName] = newValue;
            this.bHasChanged = true;
        }
    }
    setNew() {
        this.bIsNew = true;
    }
    setChanged() {
        this.bHasChanged = true;
    }
    clone() {
        const dataCopy = (0,_util_MiscFunctions__WEBPACK_IMPORTED_MODULE_2__.copyObject)(this.data);
        const result = new DefaultDataObject(this.definition, dataCopy, this.fieldOps);
        if (this.isPersisted())
            result.setPersisted(true);
        if (this.isNew())
            result.setNew();
        if (this.hasChanged())
            result.setChanged();
        return result;
    }
    instance() {
        return _DataObjectFactory__WEBPACK_IMPORTED_MODULE_3__.DataObjectFactory.getInstance().instance(this.definition, this.fieldOps);
    }
    // persistent
    persist() {
        _DataObjectPersistenceManager__WEBPACK_IMPORTED_MODULE_4__.DataObjectPersistenceManager.getInstance().persist(this);
    }
    delete() {
        _DataObjectPersistenceManager__WEBPACK_IMPORTED_MODULE_4__.DataObjectPersistenceManager.getInstance().delete(this);
    }
    getData() {
        return this.data;
    }
}
//# sourceMappingURL=DefaultDataObject.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/model/DefaultDataObjectStringifier.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/model/DefaultDataObjectStringifier.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultDataObjectStringifier": () => (/* binding */ DefaultDataObjectStringifier)
/* harmony export */ });
/* harmony import */ var _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DataObjectTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectTypeDefs.js");

class DefaultDataObjectStringifier {
    toString(dataObj) {
        let result = '';
        if (dataObj) {
            const def = dataObj.getDefinition();
            // assume the first non identifier field that is not hidden is the string to display
            let done = false;
            let index = 0;
            while (!done) {
                if (index < def.fields.length) {
                    const fieldDef = def.fields[index];
                    if ((fieldDef.type !== _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.uuid) && (fieldDef.type !== _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.id) && (fieldDef.type !== _DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.userId)) {
                        const value = dataObj.getValue(fieldDef.id);
                        if (value) {
                            result = value + '';
                        }
                        done = true;
                    }
                }
                else {
                    done = true;
                }
                index++;
            }
        }
        return result;
    }
    getDescription(dataObj) {
        return this.toString(dataObj);
    }
}
//# sourceMappingURL=DefaultDataObjectStringifier.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/model/DefinitionNotFoundError.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/model/DefinitionNotFoundError.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefinitionNotFoundError": () => (/* binding */ DefinitionNotFoundError)
/* harmony export */ });
class DefinitionNotFoundError extends Error {
    constructor(msg) {
        super(msg);
        Object.setPrototypeOf(this, DefinitionNotFoundError.prototype);
    }
}
//# sourceMappingURL=DefinitionNotFoundError.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/model/InvalidValueError.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/model/InvalidValueError.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InvalidValueError": () => (/* binding */ InvalidValueError)
/* harmony export */ });
class InvalidValueError extends Error {
    constructor(msg) {
        super(msg);
        Object.setPrototypeOf(this, InvalidValueError.prototype);
    }
}
//# sourceMappingURL=InvalidValueError.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/model/ObjectDefinitionRegistry.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/model/ObjectDefinitionRegistry.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObjectDefinitionRegistry": () => (/* binding */ ObjectDefinitionRegistry)
/* harmony export */ });
/* harmony import */ var _BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BasicObjectDefinitionFactory */ "./node_modules/ui-framework-jps/dist/framework/model/BasicObjectDefinitionFactory.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_1__);


const logger = debug__WEBPACK_IMPORTED_MODULE_1___default()('object-definition-registry');
class ObjectDefinitionRegistry {
    constructor() {
        this.definitions = [];
    }
    static getInstance() {
        if (!(ObjectDefinitionRegistry._instance)) {
            ObjectDefinitionRegistry._instance = new ObjectDefinitionRegistry();
        }
        return ObjectDefinitionRegistry._instance;
    }
    findDefinition(id) {
        let result = null;
        const index = this.definitions.findIndex((definition) => definition.id === id);
        if (index >= 0) {
            result = this.definitions[index];
        }
        return result;
    }
    addDefinition(id, displayName, hasDataId, dataIdIsUUID, createModifierFields = true, idFieldName = _BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_0__.FIELD_ID) {
        logger(`Adding definition for ${id} with name ${displayName}`);
        let result = this.findDefinition(id);
        if (result) {
            return result;
        }
        else {
            let definition = _BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_0__.BasicObjectDefinitionFactory.getInstance().createBasicObjectDefinition(id, displayName, hasDataId, dataIdIsUUID, createModifierFields, idFieldName);
            this.definitions.push(definition);
            return definition;
        }
    }
}
//# sourceMappingURL=ObjectDefinitionRegistry.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/network/ApiUtil.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/network/ApiUtil.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiUtil": () => (/* binding */ ApiUtil)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _security_SecurityManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../security/SecurityManager */ "./node_modules/ui-framework-jps/dist/framework/security/SecurityManager.js");
/* harmony import */ var _DownloadManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DownloadManager */ "./node_modules/ui-framework-jps/dist/framework/network/DownloadManager.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



const apiLogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('api-ts');
const apiResultsLogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('api-ts-results');
class ApiUtil {
    static getInstance() {
        if (!(ApiUtil._instance)) {
            ApiUtil._instance = new ApiUtil();
        }
        return ApiUtil._instance;
    }
    postFetchJSON(url, query) {
        return __awaiter(this, void 0, void 0, function* () {
            const postParameters = {
                method: "POST",
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query })
            };
            const response = yield fetch(url, postParameters);
            return response.json();
        });
    }
    /*
        Utility function for calling JSON POST requests
        Parameters:
        1.  URL to send the POST request too;
        2.  parameters object whose attribute (name/values) are the request parameters; and
        3.  A function to receive the results when the fetch has completed
            The callback function should have the following form
            callback (jsonDataReturned, httpStatusCode)
            a)  A successful fetch will return the JSON data in the first parameter and a status code of the server
            b)  Parameters that cannot be converted to JSON format will give a null data and code 404
            c)  A server error will give that code and no data
      */
    apiFetchJSONWithPost(request) {
        apiLogger(`Executing fetch with URL ${request.originalRequest.url} with body ${request.originalRequest.params}`);
        try {
            JSON.stringify(request.originalRequest.params);
        }
        catch (error) {
            apiLogger('Unable to convert parameters to JSON');
            apiLogger(request.originalRequest.params, 100);
            request.callback(null, 404, request.queueType, request.requestId);
        }
        const postParameters = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(Object.assign({}, request.originalRequest.params)),
        };
        this.fetchJSON(request.originalRequest, postParameters, request.callback, request.queueType, request.requestId);
    }
    apiFetchJSONWithGet(request) {
        apiLogger(`Executing GET fetch with URL ${request.originalRequest.url} with id ${request.originalRequest.params.id}`);
        const getParameters = {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' },
        };
        if (request.originalRequest.params.id && !request.wasOffline)
            request.originalRequest.url += `/${request.originalRequest.params.id}`;
        this.fetchJSON(request.originalRequest, getParameters, request.callback, request.queueType, request.requestId);
    }
    apiFetchJSONWithDelete(request) {
        apiLogger(`Executing DELETE fetch with URL ${request.originalRequest.url} with id ${request.originalRequest.params.id}`);
        const delParameters = {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
        };
        if (request.originalRequest.params.id && !request.wasOffline)
            request.originalRequest.url += `/${request.originalRequest.params.id}`;
        this.fetchJSON(request.originalRequest, delParameters, request.callback, request.queueType, request.requestId);
    }
    apiFetchJSONWithPut(request) {
        apiLogger(`Executing PUT fetch with URL ${request.originalRequest.url} with id ${request.originalRequest.params.id}`);
        const putParameters = {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(Object.assign({}, request.originalRequest.params)),
        };
        if (request.originalRequest.params.id && !request.wasOffline)
            request.originalRequest.url += `/${request.originalRequest.params.id}`;
        this.fetchJSON(request.originalRequest, putParameters, request.callback, request.queueType, request.requestId);
    }
    simplePOSTJSON(request) {
        let postParameters = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(Object.assign({}, request.body))
        };
        if (request.jwt) {
            // @ts-ignore
            postParameters.headers['authorization'] = request.jwt;
        }
        fetch(request.url, postParameters)
            .then((response) => {
            apiLogger(`Response code was ${response.status}`);
            if (response.status >= 200 && response.status <= 299) {
                return response.json();
            }
            if (response.status === 400) {
                apiResultsLogger(response.json());
            }
        })
            .then((data) => {
            apiResultsLogger(data);
            request.callback(data, 200);
        })
            .catch((error) => {
            apiLogger(error);
            request.callback(null, 500);
        });
    }
    simpleGETJSON(request) {
        let getParameters = {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' },
            //body:JSON.stringify({...request.body})
        };
        if (request.jwt) {
            // @ts-ignore
            postParameters.headers['authorization'] = request.jwt;
        }
        if (request.params) {
            request.params.forEach((key) => {
                request.url += `/${key}`;
            });
        }
        fetch(request.url, getParameters)
            .then((response) => {
            apiLogger(`Response code was ${response.status}`);
            if (response.status >= 200 && response.status <= 299) {
                return response.json();
            }
            if (response.status === 400) {
                apiResultsLogger(response.json());
            }
        })
            .then((data) => {
            apiResultsLogger(data);
            request.callback(data, 200);
        })
            .catch((error) => {
            apiLogger(error);
            request.callback(null, 500);
        });
    }
    simplePOSTFormData(request) {
        let postParameters = {
            method: 'POST',
            headers: {},
            body: request.body
        };
        if (request.jwt) {
            // @ts-ignore
            postParameters.headers['authorization'] = request.jwt;
        }
        fetch(request.url, postParameters)
            .then((response) => {
            apiLogger(`Response code was ${response.status}`);
            if (response.status >= 200 && response.status <= 299) {
                return response.json();
            }
            if (response.status === 400) {
                apiResultsLogger(response.json());
            }
        })
            .then((data) => {
            apiResultsLogger(data);
            request.callback(data, 200, request.context);
        })
            .catch((error) => {
            apiLogger(error);
            request.callback(null, 500);
        });
    }
    fetchJSON(originalRequest, parameters, callback, queueType, requestId) {
        // do we need to add a token the headers?
        if (_security_SecurityManager__WEBPACK_IMPORTED_MODULE_1__.SecurityManager.getInstance().callsRequireToken()) {
            apiLogger(`Security Manager - requires token for API calls`);
            const headerName = _security_SecurityManager__WEBPACK_IMPORTED_MODULE_1__.SecurityManager.getInstance().getTokenHeaderName();
            const token = _security_SecurityManager__WEBPACK_IMPORTED_MODULE_1__.SecurityManager.getInstance().getToken();
            apiLogger(`Header: ${headerName}:${token}`);
            // @ts-ignore
            parameters.headers[headerName] = token;
        }
        if (originalRequest.context) {
            parameters.headers[ApiUtil.CALL_CONTEXT_HEADER] = originalRequest.context;
        }
        fetch(originalRequest.url, parameters)
            .then((response) => {
            apiLogger(`Response code was ${response.status}`);
            if (response.status >= 200 && response.status <= 299) {
                return response.json();
            }
            if (response.status === 400) {
                apiResultsLogger(response.json());
            }
            if (response.status === 403) { // possibly web token expiry
                apiResultsLogger(`Forbidden request`);
                if (_security_SecurityManager__WEBPACK_IMPORTED_MODULE_1__.SecurityManager.getInstance().callsRequireToken()) {
                    apiLogger(`Refreshing token and putting request back into the queue`);
                    // ask for a new token
                    _security_SecurityManager__WEBPACK_IMPORTED_MODULE_1__.SecurityManager.getInstance().refreshToken();
                    // re-queue the request
                    _DownloadManager__WEBPACK_IMPORTED_MODULE_2__.DownloadManager.getInstance().addApiRequest(originalRequest, true, false);
                }
                else {
                    apiResultsLogger(response.json());
                }
            }
        })
            .then((data) => {
            apiResultsLogger(data);
            callback(data, 200, queueType, requestId);
        })
            .catch((error) => {
            apiLogger(error);
            callback(null, 500, queueType, requestId);
        });
    }
}
ApiUtil.CALL_CONTEXT_HEADER = 'API.CONTEXT.HEADER';
//# sourceMappingURL=ApiUtil.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/network/CallbackRegistry.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/network/CallbackRegistry.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CallbackRegistry": () => (/* binding */ CallbackRegistry)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);

const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('callback-registry');
class CallbackRegistry {
    constructor() {
        this.callbacks = [];
    }
    static getInstance() {
        if (!(CallbackRegistry._instance)) {
            CallbackRegistry._instance = new CallbackRegistry();
        }
        return CallbackRegistry._instance;
    }
    addRegisterCallback(id, fn) {
        logger(`Adding callback function with id ${id}`);
        this.callbacks.push({ id: id, fn: fn });
    }
    getCallbackById(id) {
        const defaultFn = function (data, status, associatedStateName) {
            console.error(`Callback received with status ${status}, state name ${associatedStateName} where the callback was never registered`);
        };
        const foundIndex = this.callbacks.findIndex((callback) => callback.id === id);
        if (foundIndex >= 0) {
            return this.callbacks[foundIndex].fn;
        }
        return defaultFn;
    }
}
//# sourceMappingURL=CallbackRegistry.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/network/DownloadManager.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/network/DownloadManager.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DownloadManager": () => (/* binding */ DownloadManager)
/* harmony export */ });
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Types */ "./node_modules/ui-framework-jps/dist/framework/network/Types.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _CallbackRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CallbackRegistry */ "./node_modules/ui-framework-jps/dist/framework/network/CallbackRegistry.js");
/* harmony import */ var _OfflineManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./OfflineManager */ "./node_modules/ui-framework-jps/dist/framework/network/OfflineManager.js");
/* harmony import */ var _ApiUtil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ApiUtil */ "./node_modules/ui-framework-jps/dist/framework/network/ApiUtil.js");
/* harmony import */ var _security_SecurityManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../security/SecurityManager */ "./node_modules/ui-framework-jps/dist/framework/security/SecurityManager.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







const logger = debug__WEBPACK_IMPORTED_MODULE_1___default()('download-manager');
class DownloadManager {
    constructor() {
        this.backgroundQueue = [];
        this.priorityQueue = [];
        this.inProgress = [];
        this.backgroundChangeListener = null;
        this.priorityChangeListener = null;
        this.callbackForQueueRequest = this.callbackForQueueRequest.bind(this);
        _security_SecurityManager__WEBPACK_IMPORTED_MODULE_5__.SecurityManager.getInstance().addListener(this);
    }
    static getInstance() {
        if (!(DownloadManager._instance)) {
            DownloadManager._instance = new DownloadManager();
        }
        return DownloadManager._instance;
    }
    processOfflineItems() {
        logger(`Checking for offline items`);
        _OfflineManager__WEBPACK_IMPORTED_MODULE_3__.OfflineManager.getInstance().processQueuedResults();
    }
    setBackgroundChangeListener(uiChangeListener) {
        this.backgroundChangeListener = uiChangeListener;
    }
    setPriorityChangeListener(uiChangeListener) {
        this.priorityChangeListener = uiChangeListener;
    }
    getPriorityQueueCount() {
        return this.priorityQueue.length;
    }
    getBackgroundQueueCount() {
        return this.backgroundQueue.length;
    }
    addQLApiRequest(url, query, variables, callbackId, state, isPriority = false) {
        let request = {
            url: url,
            type: _Types__WEBPACK_IMPORTED_MODULE_0__.RequestType.POST,
            params: { query: query, variables: variables },
            callbackId: callbackId,
            associatedStateName: state
        };
        this.addApiRequest(request, isPriority);
    }
    addQLMutationRequest(url, mutation, variables, callbackId, state, isPriority = false) {
        let request = {
            url: url,
            type: _Types__WEBPACK_IMPORTED_MODULE_0__.RequestType.POST,
            params: { mutation: mutation, variables: variables },
            callbackId: callbackId,
            associatedStateName: state
        };
        this.addApiRequest(request, isPriority);
    }
    addApiRequest(jsonRequest, isPriority = false, wasOffline = false) {
        return __awaiter(this, void 0, void 0, function* () {
            // add a new requestId to the request for future tracking
            const requestId = (0,uuid__WEBPACK_IMPORTED_MODULE_6__["default"])();
            logger(`Adding Queue Request ${requestId}`);
            logger(jsonRequest);
            // are we currently offline?
            if (_OfflineManager__WEBPACK_IMPORTED_MODULE_3__.OfflineManager.getInstance().areWeOffline()) {
                logger(`We are offline, queueing request for when server back online.`);
                _OfflineManager__WEBPACK_IMPORTED_MODULE_3__.OfflineManager.getInstance().addOfflineRequest(jsonRequest);
                // let the callback function know, with a custom code to let the receiver know there was a problem
                _CallbackRegistry__WEBPACK_IMPORTED_MODULE_2__.CallbackRegistry.getInstance().getCallbackById(jsonRequest.callbackId)(jsonRequest.params, 500, jsonRequest.associatedStateName, false);
                return;
            }
            // we are online (hopefully), continue for now, we will catch offline errors later
            if (isPriority) {
                let managerRequest = {
                    originalRequest: jsonRequest,
                    requestId: requestId,
                    queueType: _Types__WEBPACK_IMPORTED_MODULE_0__.queueType.PRIORITY,
                    callback: this.callbackForQueueRequest,
                    wasOffline: wasOffline
                };
                this.priorityQueue.push(managerRequest);
                if (this.priorityChangeListener)
                    this.priorityChangeListener.handleEventAddToQueue();
            }
            else {
                let managerRequest = {
                    originalRequest: jsonRequest,
                    requestId: requestId,
                    queueType: _Types__WEBPACK_IMPORTED_MODULE_0__.queueType.BACKGROUND,
                    callback: this.callbackForQueueRequest,
                    wasOffline: wasOffline
                };
                this.backgroundQueue.push(managerRequest);
                if (this.backgroundChangeListener)
                    this.backgroundChangeListener.handleEventAddToQueue();
            }
            this.processQueues();
        });
    }
    processPriorityQueue() {
        if (!(this.canProceed()))
            return;
        const queueItem = this.priorityQueue.shift();
        if (queueItem !== undefined) {
            this.inProgress.push(queueItem);
            this.initiateFetchForQueueItem(queueItem);
        }
    }
    processBackgroundQueue() {
        if (!(this.canProceed()))
            return;
        const queueItem = this.backgroundQueue.shift();
        if (queueItem !== undefined) {
            this.inProgress.push(queueItem);
            this.initiateFetchForQueueItem(queueItem);
        }
    }
    canProceed() {
        let result = false;
        if (_security_SecurityManager__WEBPACK_IMPORTED_MODULE_5__.SecurityManager.getInstance().callsRequireToken()) {
            if (_security_SecurityManager__WEBPACK_IMPORTED_MODULE_5__.SecurityManager.getInstance().hasToken()) {
                result = true;
            }
            else {
                logger(`Security manager requires a token and does not yet have one, pausing queues`);
            }
        }
        else {
            result = true;
        }
        return result;
    }
    processQueues() {
        // are we waiting for an authorisation token?
        if (!(this.canProceed()))
            return;
        let totalQueuedItems = this.priorityQueue.length + this.backgroundQueue.length;
        while (totalQueuedItems > 0) {
            logger(`processing queue, items remaining ${totalQueuedItems}`);
            // priority queue takes priority
            if (this.priorityQueue.length > 0) {
                this.processPriorityQueue();
            }
            else if (this.backgroundQueue.length > 0) {
                this.processBackgroundQueue();
            }
            totalQueuedItems = this.priorityQueue.length + this.backgroundQueue.length;
        }
    }
    callbackForQueueRequest(jsonData, httpStatus, queueId, requestId) {
        // let the listeners know about the completion
        if (queueId === _Types__WEBPACK_IMPORTED_MODULE_0__.queueType.PRIORITY) { // priority
            if (this.priorityChangeListener)
                this.priorityChangeListener.handleEventRemoveFromQueue();
        }
        else if (this.backgroundChangeListener)
            this.backgroundChangeListener.handleEventRemoveFromQueue();
        logger(`received callback for queue ${queueId} request ${requestId} with status ${httpStatus}`);
        // find the item in the in progress
        const foundIndex = this.inProgress.findIndex(element => element.requestId === requestId);
        if (foundIndex >= 0) {
            // remove from in progress
            const queueItem = this.inProgress[foundIndex];
            this.inProgress.splice(foundIndex, 1);
            logger(queueItem);
            // are we offline http status of 500
            if (httpStatus === 500) {
                logger(`queue item ${queueItem.requestId} - server offline, queueing for later`);
                _OfflineManager__WEBPACK_IMPORTED_MODULE_3__.OfflineManager.getInstance().addOfflineRequest(queueItem.originalRequest);
                // let the callback function know, with a custom code to let the receiver know there was a problem
                _CallbackRegistry__WEBPACK_IMPORTED_MODULE_2__.CallbackRegistry.getInstance().getCallbackById(queueItem.originalRequest.callbackId)(queueItem.originalRequest.params, httpStatus, queueItem.originalRequest.associatedStateName, queueItem.wasOffline);
            }
            else {
                logger(`finished for queue item ${queueItem.requestId} with possible offline id of ${queueItem.originalRequest._id}`);
                // let the callback function know
                _CallbackRegistry__WEBPACK_IMPORTED_MODULE_2__.CallbackRegistry.getInstance().getCallbackById(queueItem.originalRequest.callbackId)(jsonData, httpStatus, queueItem.originalRequest.associatedStateName, queueItem.wasOffline);
            }
        }
    }
    initiateFetchForQueueItem(item) {
        logger(`Download Manager: initiating fetch for queue item ${item.requestId}`);
        logger(item);
        switch (item.originalRequest.type) {
            case _Types__WEBPACK_IMPORTED_MODULE_0__.RequestType.POST: {
                _ApiUtil__WEBPACK_IMPORTED_MODULE_4__.ApiUtil.getInstance().apiFetchJSONWithPost(item);
                break;
            }
            case _Types__WEBPACK_IMPORTED_MODULE_0__.RequestType.GET: {
                _ApiUtil__WEBPACK_IMPORTED_MODULE_4__.ApiUtil.getInstance().apiFetchJSONWithGet(item);
                break;
            }
            case _Types__WEBPACK_IMPORTED_MODULE_0__.RequestType.DELETE: {
                _ApiUtil__WEBPACK_IMPORTED_MODULE_4__.ApiUtil.getInstance().apiFetchJSONWithDelete(item);
                break;
            }
            case _Types__WEBPACK_IMPORTED_MODULE_0__.RequestType.PUT: {
                _ApiUtil__WEBPACK_IMPORTED_MODULE_4__.ApiUtil.getInstance().apiFetchJSONWithPut(item);
                break;
            }
        }
    }
    tokenAvailable() {
        logger(`Token now available, restarting queues`);
        this.processQueues();
    }
}
//# sourceMappingURL=DownloadManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/network/OfflineManager.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/network/OfflineManager.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OfflineManager": () => (/* binding */ OfflineManager)
/* harmony export */ });
/* harmony import */ var _Poller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Poller */ "./node_modules/ui-framework-jps/dist/framework/network/Poller.js");
/* harmony import */ var _state_implementation_IndexedDBStateManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../state/implementation/IndexedDBStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/IndexedDBStateManager.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _DownloadManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DownloadManager */ "./node_modules/ui-framework-jps/dist/framework/network/DownloadManager.js");
/* harmony import */ var _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../notification/NotificationManager */ "./node_modules/ui-framework-jps/dist/framework/notification/NotificationManager.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _state_implementation_EncryptedIndexedDBStateManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../state/implementation/EncryptedIndexedDBStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/EncryptedIndexedDBStateManager.js");
/* harmony import */ var _model_ObjectDefinitionRegistry__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../model/ObjectDefinitionRegistry */ "./node_modules/ui-framework-jps/dist/framework/model/ObjectDefinitionRegistry.js");








const logger = debug__WEBPACK_IMPORTED_MODULE_4___default()('offline-manager');
class OfflineManager {
    constructor() {
        this.serverBackOnline = this.serverBackOnline.bind(this);
        const useEncryption = localStorage.getItem(OfflineManager.LOCALSTORAGE_KEY_USE_ENCRYPTION);
        let indexedDB;
        if (useEncryption) {
            indexedDB = new _state_implementation_EncryptedIndexedDBStateManager__WEBPACK_IMPORTED_MODULE_5__.EncryptedIndexedDBStateManager();
        }
        else {
            indexedDB = new _state_implementation_IndexedDBStateManager__WEBPACK_IMPORTED_MODULE_1__.IndexedDBStateManager();
        }
        indexedDB.initialise(OfflineManager.DB_NAME, [{ name: OfflineManager.OBJECT_STORE, keyField: '_id' }]);
        this.persistence = indexedDB;
        this.persistence.addChangeListenerForName(OfflineManager.OBJECT_STORE, this);
        _model_ObjectDefinitionRegistry__WEBPACK_IMPORTED_MODULE_6__.ObjectDefinitionRegistry.getInstance().addDefinition(OfflineManager.OBJECT_STORE, 'Offline Requests', true, false, false, "_id");
    }
    static getInstance() {
        if (!(OfflineManager._instance)) {
            OfflineManager._instance = new OfflineManager();
        }
        return OfflineManager._instance;
    }
    processQueuedResults() {
        // find any requests in the persistence
        this.persistence.getStateByName(OfflineManager.OBJECT_STORE);
    }
    serverBackOnline() {
        _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_3__.NotificationManager.getInstance().show('Server', 'Server is back online.', 'Offline Manager2');
        this.processQueuedResults();
    }
    areWeOffline() {
        return _Poller__WEBPACK_IMPORTED_MODULE_0__.Poller.getInstance().isPolling();
    }
    addOfflineRequest(jsonRequest) {
        if (!_Poller__WEBPACK_IMPORTED_MODULE_0__.Poller.getInstance().isPolling()) {
            _Poller__WEBPACK_IMPORTED_MODULE_0__.Poller.getInstance().startPolling(this.serverBackOnline);
            _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_3__.NotificationManager.getInstance().show('Server', 'Server is offline, queueing local changes for when server is available', 'Offline Manager3', _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_3__.NotificationType.warning);
        }
        // save the request with an id
        jsonRequest._id = (0,uuid__WEBPACK_IMPORTED_MODULE_7__["default"])();
        logger('Adding offline request');
        logger(jsonRequest);
        this.persistence.addNewItemToState(OfflineManager.OBJECT_STORE, jsonRequest, false);
    }
    getListenerName() {
        return "Offline manager";
    }
    stateChanged(managerName, name, offlineResults) {
        if (offlineResults && offlineResults.length > 0) {
            _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_3__.NotificationManager.getInstance().show('Queued Changes', `There are ${offlineResults.length} queued changes, sending to server.`, 'Offline Manager1', _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_3__.NotificationType.warning);
            offlineResults.forEach((request) => {
                this.persistence.removeItemFromState(OfflineManager.OBJECT_STORE, request, false);
                logger(`Processing offline request with priority and from offline`);
                logger(request);
                _DownloadManager__WEBPACK_IMPORTED_MODULE_2__.DownloadManager.getInstance().addApiRequest(request, true, true);
            });
        }
        this.persistence.forceResetForGet(OfflineManager.OBJECT_STORE);
    }
    stateChangedItemAdded(managerName, name, itemAdded) {
    }
    stateChangedItemRemoved(managerName, name, itemRemoved) {
    }
    stateChangedItemUpdated(managerName, name, itemUpdated, itemNewValue) {
    }
    filterResults(managerName, name, filterResults) {
    }
    foundResult(managerName, name, foundItem) {
    }
}
OfflineManager.DB_NAME = 'offline.manager.db';
OfflineManager.OBJECT_STORE = 'offline.manager.db.requests';
OfflineManager.LOCALSTORAGE_KEY_USE_ENCRYPTION = 'offline-manager.use-encryption';
//# sourceMappingURL=OfflineManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/network/Poller.js":
/*!************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/network/Poller.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Poller": () => (/* binding */ Poller)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);

const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('poller');
class Poller {
    constructor() {
        this.interval = null;
        this.isPollingBool = false;
    }
    static getInstance() {
        if (!(Poller._instance)) {
            Poller._instance = new Poller();
        }
        return Poller._instance;
    }
    startPolling(callback, delay = Poller.INTERVAL_DEFAULT) {
        this.isPollingBool = true;
        this.interval = setInterval(() => {
            logger(`Checking for server availability`);
            fetch(Poller.URL_CALL, { method: 'GET' }).then((response) => {
                logger(`Response code was ${response.status} - server is now available`);
                this.stopPolling();
                callback();
            }).catch((error) => {
                logger(error);
            });
        }, delay);
    }
    isPolling() {
        return this.isPollingBool;
    }
    stopPolling() {
        if (this.interval)
            clearInterval(this.interval);
        this.interval = null;
        this.isPollingBool = false;
    }
}
Poller.INTERVAL_DEFAULT = 10000; // 30 seconds
Poller.URL_CALL = '/ping';
//# sourceMappingURL=Poller.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/network/Types.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/network/Types.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RequestType": () => (/* binding */ RequestType),
/* harmony export */   "queueType": () => (/* binding */ queueType)
/* harmony export */ });
var RequestType;
(function (RequestType) {
    RequestType[RequestType["POST"] = 0] = "POST";
    RequestType[RequestType["GET"] = 1] = "GET";
    RequestType[RequestType["PUT"] = 2] = "PUT";
    RequestType[RequestType["DELETE"] = 3] = "DELETE";
})(RequestType || (RequestType = {}));
var queueType;
(function (queueType) {
    queueType[queueType["PRIORITY"] = 0] = "PRIORITY";
    queueType[queueType["BACKGROUND"] = 1] = "BACKGROUND";
})(queueType || (queueType = {}));
//# sourceMappingURL=Types.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/notification/BootstrapNotification.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/notification/BootstrapNotification.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BootstrapNotification": () => (/* binding */ BootstrapNotification)
/* harmony export */ });
/* harmony import */ var _Notification__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Notification */ "./node_modules/ui-framework-jps/dist/framework/notification/Notification.js");
/* harmony import */ var _NotificationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NotificationManager */ "./node_modules/ui-framework-jps/dist/framework/notification/NotificationManager.js");


class BootstrapNotification extends _Notification__WEBPACK_IMPORTED_MODULE_0__.Notification {
    constructor(notificationManager) {
        super(notificationManager);
    }
    // Make the notification visible on the screen
    show(title, message, topOffset = 0, context, duration = 3000) {
        let containerId = this.notificationManager.getContainerId();
        // convert the context to a background colour
        let bgColorClass = '';
        switch (context) {
            case _NotificationManager__WEBPACK_IMPORTED_MODULE_1__.NotificationType.info: {
                bgColorClass = 'bg-info';
                break;
            }
            case _NotificationManager__WEBPACK_IMPORTED_MODULE_1__.NotificationType.warning: {
                bgColorClass = 'bg-warning';
                break;
            }
            case _NotificationManager__WEBPACK_IMPORTED_MODULE_1__.NotificationType.message: {
                bgColorClass = 'bg-primary';
                break;
            }
            case _NotificationManager__WEBPACK_IMPORTED_MODULE_1__.NotificationType.priority: {
                bgColorClass = 'bg-danger';
                break;
            }
            default: {
                bgColorClass = "bg-info";
            }
        }
        // Creating the notification container div
        const containerNode = document.createElement('div');
        containerNode.className = 'notification toast';
        containerNode.style.top = `${topOffset}px`;
        containerNode.setAttribute("role", "alert");
        containerNode.setAttribute("data-autohide", "false");
        // Adding the notification title node
        const titleNode = document.createElement('div');
        titleNode.className = `toast-header text-white ${bgColorClass}`;
        const titleTextNode = document.createElement('strong');
        titleTextNode.className = "mr-auto";
        titleTextNode.textContent = title;
        // Adding a little button on the notification
        const closeButtonNode = document.createElement('button');
        closeButtonNode.className = 'ml-2 mb-1 close';
        closeButtonNode.textContent = 'x';
        closeButtonNode.addEventListener('click', () => {
            this.notificationManager.remove(containerNode);
        });
        // Adding the notification message content node
        const messageNode = document.createElement('div');
        messageNode.className = 'toast-body';
        messageNode.textContent = message;
        // Appending the container with all the elements newly created
        titleNode.appendChild(titleTextNode);
        titleNode.appendChild(closeButtonNode);
        containerNode.appendChild(titleNode);
        containerNode.appendChild(messageNode);
        containerNode.classList.add(`is-${context}`);
        // Inserting the notification to the page body
        const containerEl = document.getElementById(containerId);
        if (containerEl)
            containerEl.appendChild(containerNode);
        // activate it
        // @ts-ignore
        $(".notification").toast('show');
        // Default duration delay
        if (duration <= 0) {
            duration = 2000;
        }
        setTimeout(() => {
            this.notificationManager.remove(containerNode);
        }, duration);
        return containerNode;
    }
}
//# sourceMappingURL=BootstrapNotification.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/notification/Notification.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/notification/Notification.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Notification": () => (/* binding */ Notification)
/* harmony export */ });
class Notification {
    constructor(notificationManager) {
        this.show = this.show.bind(this);
        this.notificationManager = notificationManager;
        // Create DOM notification structure when instantiated
        this.containerId = this.notificationManager.getContainerId();
    }
}
//# sourceMappingURL=Notification.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/notification/NotificationFactory.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/notification/NotificationFactory.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NotificationFactory": () => (/* binding */ NotificationFactory)
/* harmony export */ });
/* harmony import */ var _BootstrapNotification__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BootstrapNotification */ "./node_modules/ui-framework-jps/dist/framework/notification/BootstrapNotification.js");

class NotificationFactory {
    constructor() {
    }
    static getInstance() {
        if (!(NotificationFactory._instance)) {
            NotificationFactory._instance = new NotificationFactory();
        }
        return NotificationFactory._instance;
    }
    createNotification(manager) {
        return new _BootstrapNotification__WEBPACK_IMPORTED_MODULE_0__.BootstrapNotification(manager);
    }
}
//# sourceMappingURL=NotificationFactory.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/notification/NotificationManager.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/notification/NotificationManager.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NotificationType": () => (/* binding */ NotificationType),
/* harmony export */   "NotificationManager": () => (/* binding */ NotificationManager)
/* harmony export */ });
/* harmony import */ var _NotificationFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NotificationFactory */ "./node_modules/ui-framework-jps/dist/framework/notification/NotificationFactory.js");

var NotificationType;
(function (NotificationType) {
    NotificationType[NotificationType["info"] = 0] = "info";
    NotificationType[NotificationType["warning"] = 1] = "warning";
    NotificationType[NotificationType["message"] = 2] = "message";
    NotificationType[NotificationType["priority"] = 3] = "priority";
})(NotificationType || (NotificationType = {}));
class NotificationManager {
    constructor() {
        this.notifications = [];
        this.list = [];
        this.currentCount = 0;
        this.offsetPerNotification = 120;
        this.containerId = 'notifications';
        this.show = this.show.bind(this);
    }
    static getInstance() {
        if (!(NotificationManager._instance)) {
            NotificationManager._instance = new NotificationManager();
        }
        return NotificationManager._instance;
    }
    getContainerId() {
        return this.containerId;
    }
    addIdToList(id) {
        if (this.isIdInList(id))
            return;
        this.list.push(id);
        if (this.list.length > NotificationManager.LIST_LIMIT) {
            this.list.splice(0, 1);
        }
    }
    removeIdFromList(id) {
        const foundIndex = this.list.findIndex((item) => item === id);
        if (foundIndex >= 0) {
            this.list.splice(foundIndex, 1);
        }
    }
    isIdInList(id) {
        let result = false;
        const foundIndex = this.list.findIndex((item) => item === id);
        if (foundIndex >= 0) {
            result = true;
        }
        return result;
    }
    show(title, message, id, context = NotificationType.info, duration = 5000) {
        if (this.isIdInList(id))
            return;
        this.addIdToList(id);
        const notification = _NotificationFactory__WEBPACK_IMPORTED_MODULE_0__.NotificationFactory.getInstance().createNotification(this);
        const notificationNode = notification.show(title, message, this.currentCount * this.offsetPerNotification, context, duration);
        setTimeout(() => {
            this.removeIdFromList(id);
        }, 1000);
        this.currentCount++;
        this.notifications.push(notificationNode);
    }
    remove(notificationNode) {
        const foundIndex = this.notifications.findIndex(element => element === notificationNode);
        if (foundIndex >= 0) {
            this.notifications.splice(foundIndex, 1);
            // re-arrange the remaining notifications
            this.notifications.map((notificationNode, index) => {
                // @ts-ignore
                notificationNode.style.top = `${this.offsetPerNotification * index}px`;
            });
        }
        const parentEl = notificationNode.parentElement;
        if (parentEl !== null)
            parentEl.removeChild(notificationNode);
        this.currentCount--;
        if (this.currentCount < 0)
            this.currentCount = 0;
    }
}
NotificationManager.LIST_LIMIT = 100;
//# sourceMappingURL=NotificationManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/security/SecurityManager.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/security/SecurityManager.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SecurityManager": () => (/* binding */ SecurityManager)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _network_ApiUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../network/ApiUtil */ "./node_modules/ui-framework-jps/dist/framework/network/ApiUtil.js");


const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('security-manager');
class SecurityManager {
    constructor() {
        this.hash = null;
        this.logoutEl = null;
        this.requiresToken = false;
        this.headerName = null;
        this.token = null;
        this.hasTokenValue = false;
        this.listeners = [];
        this.tokenURL = null;
        this.callbackForToken = this.callbackForToken.bind(this);
    }
    static getInstance() {
        if (!(SecurityManager._instance)) {
            SecurityManager._instance = new SecurityManager();
        }
        return SecurityManager._instance;
    }
    getToken() {
        return this.token;
    }
    hasToken() {
        return this.hasTokenValue;
    }
    getTokenHeaderName() {
        return this.headerName;
    }
    callsRequireToken() {
        return this.requiresToken;
    }
    addListener(listener) {
        this.listeners.push(listener);
    }
    callbackForToken(data, status) {
        logger(`Callback - Getting token`);
        if (status === 200) {
            logger(`Token received`);
            logger(data);
            this.token = data;
            this.hasTokenValue = true;
            this.listeners.forEach((listener) => listener.tokenAvailable());
        }
    }
    refreshToken() {
        this.hasTokenValue = false;
        this.token = null;
        if (this.tokenURL) {
            logger(`Getting token`);
            let request = {
                url: this.tokenURL,
                body: {},
                callback: this.callbackForToken
            };
            logger(request);
            _network_ApiUtil__WEBPACK_IMPORTED_MODULE_1__.ApiUtil.getInstance().simplePOSTJSON(request);
        }
    }
    setRequiresToken(httpHeaderName = SecurityManager.HTTP_HEADER_FOR_TOKEN, tokenRequestURL = SecurityManager.DEFAULT_URL_FOR_TOKEN_REQUEST) {
        this.requiresToken = true;
        this.headerName = httpHeaderName;
        // @ts-ignore
        this.tokenURL = tokenRequestURL;
        this.refreshToken();
    }
    onDocumentLoaded(logoutElementId) {
        this.logoutEl = document.getElementById(logoutElementId);
        // find the secret hash for the current user (if any)
        const username = this.getLoggedInUsername();
        if (username && username.trim().length > 0) {
            logger(`found user ${username}`);
            this.hash = localStorage.getItem(username);
            if (this.hash) {
                sessionStorage.setItem(username, this.hash);
            }
            else {
                this.hash = sessionStorage.getItem(username);
            }
            localStorage.removeItem(username);
            logger(`found user ${username} hash - removed from local storage`);
        }
        if (this.logoutEl) {
            this.logoutEl.addEventListener('click', (event) => {
                localStorage.removeItem(username);
                sessionStorage.removeItem(username);
            });
        }
    }
    isLoggedIn() {
        let isLoggedIn = false;
        try {
            // @ts-ignore
            if (loggedInUser) {
                isLoggedIn = true;
            }
        }
        catch (error) {
        }
        return isLoggedIn;
    }
    getLoggedInUserId() {
        let result = '';
        try {
            // @ts-ignore
            if (loggedInUser) {
                // @ts-ignore
                result = loggedInUser._id;
            }
        }
        catch (error) {
        }
        logger(`Logged in user id is ${result}`);
        return result;
    }
    getLoggedInUsername() {
        let result = '';
        try {
            // @ts-ignore
            if (loggedInUser) {
                // @ts-ignore
                result = loggedInUser.username;
            }
        }
        catch (error) {
        }
        logger(`Logged in user is ${result}`);
        return result;
    }
    getCurrentUser() {
        return this.getLoggedInUserId();
    }
    encryptString(value) {
        let result = value;
        if (this.hash) {
            // @ts-ignore
            result = CryptoJS.AES.encrypt(value, this.hash).toString();
        }
        return result;
    }
    decryptString(value) {
        let result = value;
        if (this.hash) {
            // @ts-ignore
            result = CryptoJS.AES.decrypt(value, this.hash).toString(CryptoJS.enc.Utf8);
        }
        return result;
    }
    encryptObject(dataObj) {
        return this.encryptString(JSON.stringify(dataObj));
    }
    decryptObject(value) {
        return JSON.parse(this.decryptString(value));
    }
}
SecurityManager.HTTP_HEADER_FOR_TOKEN = 'authorization';
SecurityManager.DEFAULT_URL_FOR_TOKEN_REQUEST = '/gettoken';
//# sourceMappingURL=SecurityManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/socket/ChatManager.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/socket/ChatManager.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChatManager": () => (/* binding */ ChatManager)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _SocketManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SocketManager */ "./node_modules/ui-framework-jps/dist/framework/socket/SocketManager.js");
/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Types */ "./node_modules/ui-framework-jps/dist/framework/socket/Types.js");
/* harmony import */ var _state_implementation_BrowserStorageStateManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../state/implementation/BrowserStorageStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/BrowserStorageStateManager.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _util_EqualityFunctions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/EqualityFunctions */ "./node_modules/ui-framework-jps/dist/framework/util/EqualityFunctions.js");







var UserStatus;
(function (UserStatus) {
    UserStatus[UserStatus["LoggedOut"] = 0] = "LoggedOut";
    UserStatus[UserStatus["LoggedIn"] = 1] = "LoggedIn";
})(UserStatus || (UserStatus = {}));
const cmLogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('chat-manager');
class ChatManager {
    constructor() {
        this.blockedList = [];
        this.favouriteList = [];
        this.loggedInUsers = [];
        this.currentUsername = '';
        this.unreadListener = null;
        cmLogger('Setting up chat logs, blocked list, and favourites');
        this.chatLogs = [];
        this.chatListeners = [];
        this.chatUserListeners = [];
        this.localStorage = new _state_implementation_BrowserStorageStateManager__WEBPACK_IMPORTED_MODULE_4__.BrowserStorageStateManager(true, true, _util_EqualityFunctions__WEBPACK_IMPORTED_MODULE_5__.isSameRoom);
        // connect to the socket manager
        _SocketManager__WEBPACK_IMPORTED_MODULE_2__.SocketManager.getInstance().addChatReceiver(this);
        // bind the receiver methods
        this.receiveLogin = this.receiveLogin.bind(this);
        this.receiveLogout = this.receiveLogout.bind(this);
        this.receiveInvitation = this.receiveInvitation.bind(this);
        this.receiveMessage = this.receiveMessage.bind(this);
        this.receiveQueuedMessages = this.receiveQueuedMessages.bind(this);
        this.receiveQueuedInvites = this.receiveQueuedInvites.bind(this);
        this.receiveJoinedRoom = this.receiveJoinedRoom.bind(this);
        this.receivedLeftRoom = this.receivedLeftRoom.bind(this);
    }
    static getInstance() {
        if (!(ChatManager._instance)) {
            ChatManager._instance = new ChatManager();
        }
        return ChatManager._instance;
    }
    addChatEventHandler(receiver) {
        this.chatListeners.push(receiver);
    }
    addChatUserEventHandler(receiver) {
        this.chatUserListeners.push(receiver);
    }
    isUserLoggedIn(username) {
        return (this.loggedInUsers.findIndex((name) => name === username) >= 0);
    }
    receiveUserList(users) {
        this.loggedInUsers = users;
        this.chatUserListeners.forEach((listener) => listener.handleLoggedInUsersUpdated(users));
    }
    addUserToBlockedList(username) {
        let index = this.blockedList.findIndex((blocked) => blocked === username);
        if (index < 0) {
            this.blockedList.push(username);
            this.saveBlockedList();
            this.chatUserListeners.forEach((listener) => listener.handleBlockedUsersChanged(this.favouriteList));
        }
    }
    removeUserFromBlockedList(username) {
        let index = this.blockedList.findIndex((blocked) => blocked === username);
        if (index >= 0) {
            this.blockedList.splice(index, 1);
            this.saveBlockedList();
            this.chatUserListeners.forEach((listener) => listener.handleBlockedUsersChanged(this.favouriteList));
        }
    }
    isUserInBlockedList(username) {
        return (this.blockedList.findIndex((blocked) => blocked === username) >= 0);
    }
    addUserToFavouriteList(username) {
        let index = this.favouriteList.findIndex((favourite) => favourite === username);
        if (index < 0) {
            this.favouriteList.push(username);
            this.saveFavouriteList();
            this.chatUserListeners.forEach((listener) => listener.handleFavouriteUsersChanged(this.favouriteList));
        }
    }
    removeUserFromFavouriteList(username) {
        let index = this.favouriteList.findIndex((blocked) => blocked === username);
        if (index >= 0) {
            this.favouriteList.splice(index, 1);
            this.saveFavouriteList();
            this.chatUserListeners.forEach((listener) => listener.handleFavouriteUsersChanged(this.favouriteList));
        }
    }
    isUserInFavouriteList(username) {
        return (this.favouriteList.findIndex((user) => user === username) >= 0);
    }
    getFavouriteUserList() {
        return [...this.favouriteList];
    }
    getBlockedUserList() {
        return [...this.blockedList];
    }
    setCurrentUser(username) {
        cmLogger(`Setting current user ${username}`);
        this.currentUsername = username;
        // load previous logs
        let savedLogs = this.localStorage.getStateByName(ChatManager.chatLogKey + this.currentUsername);
        cmLogger(savedLogs);
        if (savedLogs) {
            this.chatLogs = savedLogs;
        }
        // load previous blocked list
        let blockedList = this.localStorage.getStateByName(ChatManager.blockedListKey + this.currentUsername);
        cmLogger(blockedList);
        if (blockedList) {
            this.blockedList = blockedList;
        }
        // load previous favourite list
        let favouriteList = this.localStorage.getStateByName(ChatManager.favouriteListKey + this.currentUsername);
        cmLogger(favouriteList);
        if (favouriteList) {
            this.favouriteList = favouriteList;
        }
        this.chatListeners.forEach((listener) => listener.handleChatLogsUpdated());
    }
    getCurrentUser() {
        return this.currentUsername;
    }
    receiveJoinedRoom(users) {
        // we get this for all changes to a room, if the username is us can safely ignore
        //if (users.username === this.currentUsername) return;
        if (users.type !== _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom)
            return;
        let log = this.ensureChatLogExists(users.room);
        cmLogger(`User list for room ${users.room} - ${users.userList.join(',')}`);
        log.users = users.userList;
        // add a "message" for joined user
        let created = parseInt(moment__WEBPACK_IMPORTED_MODULE_1___default()().format('YYYYMMDDHHmmss'));
        const joinDateTime = moment__WEBPACK_IMPORTED_MODULE_1___default()().format('DD/MM/YYYY HH:mm');
        let message = {
            from: '',
            created: created,
            room: users.room,
            priority: _Types__WEBPACK_IMPORTED_MODULE_3__.Priority.Normal,
            type: _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom,
            message: `${users.username} joined the chat on ${joinDateTime}`
        };
        log.messages.push(message);
        this.saveLogs();
        this.chatListeners.forEach((listener) => listener.handleChatLogUpdated(log, false));
    }
    receivedLeftRoom(users) {
        // we get this for all changes to a room, if the username is us can safely ignore
        if (users.type !== _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom)
            return;
        if (users.username === this.currentUsername)
            return;
        let log = this.ensureChatLogExists(users.room);
        cmLogger(`User list for room ${users.room} - ${users.userList.join(',')}`);
        log.users = users.userList;
        // add a "message" for leaving user
        let created = parseInt(moment__WEBPACK_IMPORTED_MODULE_1___default()().format('YYYYMMDDHHmmss'));
        const joinDateTime = moment__WEBPACK_IMPORTED_MODULE_1___default()().format('DD/MM/YYYY HH:mm');
        let message = {
            from: '',
            created: created,
            room: users.room,
            priority: _Types__WEBPACK_IMPORTED_MODULE_3__.Priority.Normal,
            type: _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom,
            message: `${users.username} left the chat on ${joinDateTime}`
        };
        log.messages.push(message);
        this.saveLogs();
        this.chatListeners.forEach((listener) => listener.handleChatLogUpdated(log, false));
    }
    receiveInvitation(invite) {
        if (invite.type !== _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom)
            return;
        //  unless we are receiving an invite from someone in our blocked list, we automatically accept this invite
        if (!this.isUserInBlockedList(invite.from)) {
            cmLogger(`Invited to chat ${invite.room}`);
            const didChatAlreadyExist = this.doesChatRoomExist(invite.room);
            cmLogger(invite);
            cmLogger(`Letting the listeners know, if they are all happy to accept then we will join the room`);
            let happyToProceed = true;
            if (!didChatAlreadyExist) {
                this.chatListeners.forEach((listener) => {
                    if (!listener.handleNewInviteReceived(invite)) {
                        happyToProceed = false;
                    }
                });
            }
            if (happyToProceed) {
                let chatLog = this.ensureChatLogExists(invite.room);
                // keep a record of the type of invite
                chatLog.type = invite.type;
                // add the users in the invitation user list for the room, if not already added
                if (invite.userList) {
                    invite.userList.forEach((username) => {
                        if ((chatLog.users.findIndex((user) => user === username)) < 0)
                            chatLog.users.push(invite.from);
                    });
                }
                if ((chatLog.users.findIndex((user) => user === invite.from)) < 0)
                    chatLog.users.push(invite.from);
                this.saveLogs();
                cmLogger(`Joining chat ${invite.room}`);
                _SocketManager__WEBPACK_IMPORTED_MODULE_2__.SocketManager.getInstance().joinChat(this.getCurrentUser(), invite.room, _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom);
                this.chatListeners.forEach((listener) => listener.handleChatLogUpdated(chatLog, false));
            }
        }
        else {
            cmLogger(`User ${invite.from} blocked`);
        }
    }
    receiveLogin(username) {
        cmLogger(`Handle login received for ${username}`);
        // keep track of the logged in users
        let index = this.loggedInUsers.findIndex((user) => user === username);
        if (index < 0)
            this.loggedInUsers.push(username);
        cmLogger(this.loggedInUsers);
        this.chatUserListeners.forEach((listener) => listener.handleLoggedInUsersUpdated(this.loggedInUsers));
        // if the user in in favourites and not in blocked list passing this on to the listener
        if (!this.isUserInBlockedList(username) && this.isUserInFavouriteList(username)) {
            cmLogger(`User ${username} logging in`);
            this.chatUserListeners.forEach((listener) => listener.handleFavouriteUserLoggedIn(username));
        }
    }
    receiveLogout(username) {
        let index = this.loggedInUsers.findIndex((user) => user === username);
        if (index >= 0)
            this.loggedInUsers.splice(index, 1);
        this.chatUserListeners.forEach((listener) => listener.handleLoggedInUsersUpdated(this.loggedInUsers));
        // if the user in in favourites and not in blocked list passing this on to the listener
        if (!this.isUserInBlockedList(username) && this.isUserInFavouriteList(username)) {
            cmLogger(`User ${username} logging out`);
            this.chatUserListeners.forEach((listener) => listener.handleFavouriteUserLoggedOut(username));
        }
    }
    receiveDecline(room, username, type) {
        if (type !== _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom)
            return;
        // we get this for all changes to a room, if the username is us can safely ignore
        if (username === this.currentUsername)
            return;
        if (!this.isUserInBlockedList(username)) {
            cmLogger(`User ${username} declined invitation to room`);
            this.chatListeners.forEach((listener) => listener.handleInvitationDeclined(room, username));
        }
    }
    setUnreadCountListener(listener) {
        this.unreadListener = listener;
    }
    touchChatLog(room) {
        let chatLog = this.ensureChatLogExists(room);
        chatLog.unreadMessages = 0;
        chatLog.unreadHighMessages = 0;
        chatLog.unreadUrgentMessages = 0;
        chatLog.lastViewed = parseInt(moment__WEBPACK_IMPORTED_MODULE_1___default()().format('YYYYMMDDHHmmss'));
        this.emitUnreadMessageCountChanged();
        this.saveLogs();
    }
    getChatLog(room) {
        let log = null;
        let index = this.chatLogs.findIndex((log) => log.roomName === room);
        if (index >= 0)
            log = this.chatLogs[index];
        return log;
    }
    receiveMessage(message, wasOffline = false) {
        if (message.type !== _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom)
            return; // ignore messages that aren't for chat rooms
        // double check the message is not from us somehow
        if (message.from === this.getCurrentUser())
            return;
        // don't receive messages from the blocked users
        if (!this.isUserInBlockedList(message.from)) {
            // ok, so we need to add the message to the chat log, increase the new message count, save the logs and pass it on
            let chatLog = this.ensureChatLogExists(message.room);
            this.addSenderToRoomIfNotAlreadyPresent(chatLog, message.from);
            this.addMessageToChatLog(chatLog, message);
            cmLogger(`Message received`);
            cmLogger(message);
            this.chatListeners.forEach((listener) => listener.handleChatLogUpdated(chatLog, wasOffline));
        }
        else {
            cmLogger(`Message received from user ${message.from} - is in blocked list, not passed on.`);
        }
    }
    receiveQueuedInvites(invites) {
        // just loop through and process each invite
        invites.forEach((invite) => {
            this.receiveInvitation(invite);
        });
    }
    receiveQueuedMessages(messages) {
        // just loop through a process each message
        messages.forEach((message) => {
            this.receiveMessage(message, true);
        });
        this.chatListeners.forEach((listener) => listener.handleOfflineMessagesReceived(messages));
    }
    joinChat(room) {
        if (this.getCurrentUser().trim().length === 0)
            return; // we are not logged in
        this.ensureChatLogExists(room);
        _SocketManager__WEBPACK_IMPORTED_MODULE_2__.SocketManager.getInstance().joinChat(this.getCurrentUser(), room, _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom);
    }
    leaveChat(room) {
        if (this.getCurrentUser().trim().length === 0)
            return; // we are not logged in
        this.removeChatLog(room);
        _SocketManager__WEBPACK_IMPORTED_MODULE_2__.SocketManager.getInstance().leaveChat(this.getCurrentUser(), room, _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom);
        this.emitUnreadMessageCountChanged();
    }
    login() {
        if (this.getCurrentUser().trim().length === 0)
            return; // we are not logged in
        _SocketManager__WEBPACK_IMPORTED_MODULE_2__.SocketManager.getInstance().login(this.getCurrentUser());
        // get the current user list
        _SocketManager__WEBPACK_IMPORTED_MODULE_2__.SocketManager.getInstance().getUserList();
        // connect to the chat rooms already in logs
        this.chatLogs.forEach((log) => {
            if (log.type === _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom) {
                _SocketManager__WEBPACK_IMPORTED_MODULE_2__.SocketManager.getInstance().joinChat(this.currentUsername, log.roomName, _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom);
            }
        });
    }
    logout() {
        if (this.getCurrentUser().trim().length === 0)
            return; // we are not logged in
        _SocketManager__WEBPACK_IMPORTED_MODULE_2__.SocketManager.getInstance().logout(this.getCurrentUser());
    }
    declineInvite(room) {
        if (this.getCurrentUser().trim().length === 0)
            return; // we are not logged in
        _SocketManager__WEBPACK_IMPORTED_MODULE_2__.SocketManager.getInstance().sendDeclineInvite(room, this.getCurrentUser(), _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom);
    }
    sendInvite(to, room, type = _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom, requiresAcceptDecline = false, subject = '') {
        if (this.getCurrentUser().trim().length === 0)
            return; // we are not logged in
        // can't accidentally send an invite to blacklisted
        if (this.isUserInBlockedList(to))
            return;
        // only send an invite if the user isn't already in the room
        const log = this.ensureChatLogExists(room);
        if (log.users.findIndex((user) => user === to) < 0) {
            _SocketManager__WEBPACK_IMPORTED_MODULE_2__.SocketManager.getInstance().sendInvite(this.getCurrentUser(), to, room, type, requiresAcceptDecline, subject);
        }
    }
    sendMessage(room, content, priority = _Types__WEBPACK_IMPORTED_MODULE_3__.Priority.Normal, simpleAttachement, attachment) {
        if (this.getCurrentUser().trim().length === 0)
            return null; // we are not logged in
        let log = this.ensureChatLogExists(room);
        // send the message
        let created = parseInt(moment__WEBPACK_IMPORTED_MODULE_1___default()().format('YYYYMMDDHHmmss'));
        if (!(simpleAttachement))
            simpleAttachement = {
                identifier: '',
                type: '',
                displayText: ''
            };
        _SocketManager__WEBPACK_IMPORTED_MODULE_2__.SocketManager.getInstance().sendMessage(this.getCurrentUser(), room, content, created, _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom, priority, simpleAttachement, {});
        // add the message to the chat log
        if (!attachment)
            attachment = {};
        let sent = {
            from: this.getCurrentUser(),
            room: room,
            message: content,
            created: created,
            priority: priority,
            type: _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom,
            simpleAttachment: simpleAttachement,
            attachment: attachment
        };
        this.addMessageToChatLog(log, sent);
        return sent;
    }
    getChatLogs() {
        return [...this.chatLogs];
    }
    startChatWithUser(username) {
        let roomName = null;
        if (username) {
            if (this.doesChatAlreadyExistWithUser(username)) {
                cmLogger(`Already started chat with ${username}`);
                const existingChatLog = this.getExistingChatLogWithUser(username);
                // ok, lets connect to the server
                if (existingChatLog) {
                    _SocketManager__WEBPACK_IMPORTED_MODULE_2__.SocketManager.getInstance().joinChat(this.getCurrentUser(), existingChatLog.roomName, _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom);
                    roomName = existingChatLog.roomName;
                }
            }
            else {
                cmLogger(`Starting chat with ${username}`);
                // first thing, do we have a chat log with this user (and just this user) already?
                let chatLog = this.ensureChatLogExistsWithUser(username);
                this.chatListeners.forEach((listener) => listener.handleChatLogUpdated(chatLog, false));
                // invite the other user
                _SocketManager__WEBPACK_IMPORTED_MODULE_2__.SocketManager.getInstance().sendInvite(this.getCurrentUser(), username, chatLog.roomName, _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom, false, '');
                // ok, lets connect to the server
                _SocketManager__WEBPACK_IMPORTED_MODULE_2__.SocketManager.getInstance().joinChat(this.getCurrentUser(), chatLog.roomName, _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom);
                roomName = chatLog.roomName;
            }
        }
        return roomName;
    }
    saveLogs() {
        this.localStorage.setStateByName(ChatManager.chatLogKey + this.currentUsername, this.chatLogs, false);
    }
    saveBlockedList() {
        this.localStorage.setStateByName(ChatManager.blockedListKey + this.currentUsername, this.blockedList, false);
    }
    saveFavouriteList() {
        this.localStorage.setStateByName(ChatManager.favouriteListKey + this.currentUsername, this.favouriteList, false);
    }
    ensureChatLogExists(room) {
        let log;
        let index = this.chatLogs.findIndex((log) => log.roomName === room);
        if (index < 0) {
            log = {
                roomName: room,
                users: [this.getCurrentUser()],
                messages: [],
                lastViewed: parseInt(moment__WEBPACK_IMPORTED_MODULE_1___default()().format('YYYYMMDDHHmmss')),
                unreadMessages: 0,
                unreadHighMessages: 0,
                unreadUrgentMessages: 0,
                type: _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom,
            };
            this.chatLogs.push(log);
            this.saveLogs();
        }
        else {
            log = this.chatLogs[index];
        }
        return log;
    }
    doesChatAlreadyExistWithUser(username) {
        let foundLog = false;
        let index = 0;
        while (index < this.chatLogs.length) {
            let log = this.chatLogs[index];
            if (log.users.length === 2) {
                // is the username in the two of this room?
                if (log.users.findIndex((value) => value === username) >= 0) {
                    foundLog = true;
                    index = this.chatLogs.length;
                }
            }
            index++;
        }
        return foundLog;
    }
    getExistingChatLogWithUser(username) {
        let result = null;
        let foundLog = false;
        let index = 0;
        while (index < this.chatLogs.length) {
            let log = this.chatLogs[index];
            if (log.users.length === 2) {
                // is the username in the two of this room?
                if (log.users.findIndex((value) => value === username) >= 0) {
                    foundLog = true;
                    result = log;
                    index = this.chatLogs.length;
                }
            }
            index++;
        }
        return result;
    }
    ensureChatLogExistsWithUser(username) {
        let foundLog = null;
        foundLog = this.getExistingChatLogWithUser(username);
        if (!foundLog) {
            foundLog = {
                roomName: (0,uuid__WEBPACK_IMPORTED_MODULE_6__["default"])(),
                users: [this.getCurrentUser(), username],
                messages: [],
                lastViewed: parseInt(moment__WEBPACK_IMPORTED_MODULE_1___default()().format('YYYYMMDDHHmmss')),
                unreadMessages: 0,
                unreadHighMessages: 0,
                unreadUrgentMessages: 0,
                type: _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom
            };
            this.chatLogs.push(foundLog);
            this.saveLogs();
        }
        return foundLog;
    }
    doesChatRoomExist(room) {
        let index = this.chatLogs.findIndex((log) => log.roomName === room);
        return (index >= 0);
    }
    emitUnreadMessageCountChanged() {
        var _a;
        let unreadNormalMessages = 0;
        let unreadHighMessages = 0;
        let unreadUrgentMessages = 0;
        this.chatLogs.forEach((log) => {
            unreadNormalMessages += log.unreadMessages;
            unreadHighMessages += log.unreadHighMessages;
            unreadUrgentMessages += log.unreadUrgentMessages;
        });
        (_a = this.unreadListener) === null || _a === void 0 ? void 0 : _a.countChanged(unreadNormalMessages, unreadHighMessages, unreadUrgentMessages);
    }
    addMessageToChatLog(log, message) {
        switch (message.priority) {
            case _Types__WEBPACK_IMPORTED_MODULE_3__.Priority.Normal: {
                log.unreadMessages++;
                break;
            }
            case _Types__WEBPACK_IMPORTED_MODULE_3__.Priority.High: {
                log.unreadHighMessages++;
                break;
            }
            case _Types__WEBPACK_IMPORTED_MODULE_3__.Priority.Urgent: {
                log.unreadUrgentMessages++;
                break;
            }
        }
        log.messages.push(message);
        this.emitUnreadMessageCountChanged();
        if (message.from === this.getCurrentUser()) {
            this.touchChatLog(log.roomName); // this will also save the logs
        }
        else {
            this.saveLogs();
        }
    }
    addSenderToRoomIfNotAlreadyPresent(chatLog, sender) {
        let index = chatLog.users.findIndex((user) => user === sender);
        if (index < 0) {
            chatLog.users.push(sender);
        }
    }
    removeChatLog(room) {
        let index = this.chatLogs.findIndex((log) => log.roomName === room);
        if (index >= 0) {
            cmLogger(`Removing Chat log for room ${room}`);
            let result = this.chatLogs.splice(index, 1);
            cmLogger(result.length);
            this.saveLogs();
        }
    }
    clearAllChatLogs() {
        this.chatLogs = [];
        this.saveLogs();
    }
    clearAllUserLists() {
        this.blockedList = [];
        this.saveBlockedList();
        this.favouriteList = [];
        this.saveFavouriteList();
    }
    reset() {
        this.clearAllChatLogs();
        this.clearAllUserLists();
    }
}
ChatManager.chatLogKey = 'chat-logs';
ChatManager.blockedListKey = 'blocked-list';
ChatManager.favouriteListKey = 'favourite-list';
//# sourceMappingURL=ChatManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/socket/NotificationController.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/socket/NotificationController.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NotificationController": () => (/* binding */ NotificationController)
/* harmony export */ });
/* harmony import */ var _ChatManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ChatManager */ "./node_modules/ui-framework-jps/dist/framework/socket/ChatManager.js");
/* harmony import */ var _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../notification/NotificationManager */ "./node_modules/ui-framework-jps/dist/framework/notification/NotificationManager.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Types */ "./node_modules/ui-framework-jps/dist/framework/socket/Types.js");
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");





const logger = debug__WEBPACK_IMPORTED_MODULE_2___default()('notification-controller');
class NotificationController {
    constructor() {
        this.chatManager = _ChatManager__WEBPACK_IMPORTED_MODULE_0__.ChatManager.getInstance();
        this.chatListeners = [];
        this.chatUserListeners = [];
        this.notificationOptions = {
            showNormalPriorityMessageNotifications: true,
            showHighPriorityMessageNotifications: true,
            showUrgentPriorityMessageNotifications: true,
            showNormalPriorityMessageNotificationsInOS: true,
            showHighPriorityMessageNotificationsInOS: true,
            showUrgentPriorityMessageNotificationsInOS: true,
            showInvitationDeclinedNotifications: true,
            showInvitedNotifications: true,
            showOfflineMessageNotification: true,
            showFavouriteUserLoggedInNotification: true,
            showFavouriteUserLoggedOutNotification: true,
            showUserJoinLeaveChatNotification: true
        };
        //bind the methods
        this.handleChatLogUpdated = this.handleChatLogUpdated.bind(this);
        this.handleLoggedInUsersUpdated = this.handleLoggedInUsersUpdated.bind(this);
        this.handleFavouriteUserLoggedIn = this.handleFavouriteUserLoggedIn.bind(this);
        this.handleFavouriteUserLoggedOut = this.handleFavouriteUserLoggedOut.bind(this);
        this.chatManager.addChatEventHandler(this);
        this.chatManager.addChatUserEventHandler(this);
    }
    checkNotificationPromise() {
        try {
            Notification.requestPermission().then();
        }
        catch (e) {
            return false;
        }
        return true;
    }
    setupOSNotifications() {
        function handlePermission(permission) {
            switch (Notification.permission) {
                case "default":
                case "denied": {
                    logger('User declined to allow OS notifications');
                    break;
                }
            }
        }
        // Let's check if the browser supports notifications
        if (!('Notification' in window)) {
            logger("This browser does not support notifications.");
        }
        else {
            if (this.checkNotificationPromise()) {
                Notification.requestPermission()
                    .then((permission) => {
                    handlePermission(permission);
                });
            }
            else {
                Notification.requestPermission(function (permission) {
                    handlePermission(permission);
                });
            }
        }
    }
    onDocumentLoaded() {
        this.setupOSNotifications();
    }
    sendOSNotification(title, message, priority) {
        if (window.Notification && Notification.permission === "granted") {
            logger(`Sending OS notification ${Notification.permission}`);
            let showNotification = false;
            let tag = null;
            switch (priority) {
                case _Types__WEBPACK_IMPORTED_MODULE_3__.Priority.Normal: {
                    showNotification = (this.notificationOptions.showNormalPriorityMessageNotificationsInOS);
                    tag = 'normal';
                    break;
                }
                case _Types__WEBPACK_IMPORTED_MODULE_3__.Priority.High: {
                    showNotification = (this.notificationOptions.showHighPriorityMessageNotificationsInOS);
                    tag = 'high';
                    break;
                }
                case _Types__WEBPACK_IMPORTED_MODULE_3__.Priority.Urgent: {
                    showNotification = (this.notificationOptions.showUrgentPriorityMessageNotificationsInOS);
                    // no tag for urgent, want all of them to appear
                    break;
                }
            }
            logger(`Show notification? ${showNotification} OS Notification (title='${title},message='${message},tag=${tag}) - priority was ${priority}`);
            if (showNotification) {
                if (tag) {
                    new Notification(title, { body: message, tag: tag });
                }
                else {
                    new Notification(title, { body: message });
                }
            }
        }
        else {
            logger(`Sending OS notification ${Notification.permission} or not found in window object`);
        }
    }
    static getInstance() {
        if (!(NotificationController._instance)) {
            NotificationController._instance = new NotificationController();
        }
        return NotificationController._instance;
    }
    handleInvitationDeclined(room, username) {
        if (!this.notificationOptions.showInvitationDeclinedNotifications)
            return;
        // notify the user of the new chat
        _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_1__.NotificationManager.getInstance().show('Room', `User ${username} has declined the invitation to join you.`, room, _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_1__.NotificationType.info, 7000);
    }
    handleNewInviteReceived(invite) {
        let result = true;
        // is this a chat room or score sheet?
        if (invite.type !== _Types__WEBPACK_IMPORTED_MODULE_3__.InviteType.ChatRoom)
            return true;
        if (!invite.requiresAcceptDecline)
            return result;
        if (invite.requiresAcceptDecline) {
            // notify the user of the invitation
            //result = controller.askUserAboutInvitation(invite); ///////TO FIX
        }
        else {
            // notify the user of the new chat
            if (this.notificationOptions.showInvitedNotifications)
                _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_1__.NotificationManager.getInstance().show('Chat Room', `User ${invite.from} has invited you.`, invite.room, _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_1__.NotificationType.info, 7000);
        }
        return result;
    }
    addListener(listener) {
        this.chatListeners.push(listener);
    }
    addUserListener(listener) {
        this.chatUserListeners.push(listener);
    }
    blackListUser(username, isBlackedListed = true) {
        if (isBlackedListed) {
            this.chatManager.addUserToBlockedList(username);
        }
        else {
            this.chatManager.removeUserFromBlockedList(username);
        }
    }
    favouriteUser(username, isFavourited = true) {
        if (isFavourited) {
            this.chatManager.addUserToFavouriteList(username);
        }
        else {
            this.chatManager.removeUserFromFavouriteList(username);
        }
    }
    isFavouriteUser(username) {
        return this.chatManager.isUserInFavouriteList(username);
    }
    isBlockedUser(username) {
        return this.chatManager.isUserInBlockedList(username);
    }
    handleChatLogsUpdated() {
        this.chatListeners.forEach((listener) => listener.handleChatLogsUpdated());
    }
    handleChatLogUpdated(log, wasOffline = false) {
        logger(`Handle chat log updated`);
        logger(log);
        // pass on the changes
        this.chatListeners.forEach((listener) => listener.handleChatLogUpdated(log, wasOffline));
        if (!wasOffline) {
            // get the last message added, it won't be from ourselves (the chat manager takes care of that)
            if (log.messages.length > 0) {
                const displayMessage = log.messages[log.messages.length - 1];
                // is this a user join/leave?
                if ((displayMessage.from.trim().length === 0) && (!this.notificationOptions.showUserJoinLeaveChatNotification))
                    return;
                // is the message from us?
                if (displayMessage.from === _ChatManager__WEBPACK_IMPORTED_MODULE_0__.ChatManager.getInstance().getCurrentUser())
                    return;
                // provide visual notifications if do not disturb is not on, unless the message is marked priority
                let notificationType = _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_1__.NotificationType.message;
                let showNotification = this.notificationOptions.showNormalPriorityMessageNotifications;
                switch (displayMessage.priority) {
                    case _Types__WEBPACK_IMPORTED_MODULE_3__.Priority.High: {
                        notificationType = _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_1__.NotificationType.warning;
                        showNotification = this.notificationOptions.showHighPriorityMessageNotifications;
                        break;
                    }
                    case _Types__WEBPACK_IMPORTED_MODULE_3__.Priority.Urgent: {
                        notificationType = _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_1__.NotificationType.priority;
                        showNotification = this.notificationOptions.showUrgentPriorityMessageNotifications;
                        break;
                    }
                }
                if (showNotification) {
                    _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_1__.NotificationManager.getInstance().show(displayMessage.from, displayMessage.message, (0,uuid__WEBPACK_IMPORTED_MODULE_4__["default"])(), notificationType, 3000);
                    this.sendOSNotification(displayMessage.from, displayMessage.message, displayMessage.priority);
                }
            }
        }
    }
    handleLoggedInUsersUpdated(usernames) {
        logger(`Handle logged in users updated`);
        logger(usernames);
        // allow the view to change the user statuses
        this.chatUserListeners.forEach((listener) => listener.handleLoggedInUsersUpdated(usernames));
    }
    handleFavouriteUserLoggedIn(username) {
        logger(`Handle favourite user ${username} logged in`);
        // allow the view to change the user statuses
        this.chatUserListeners.forEach((listener) => listener.handleFavouriteUserLoggedIn(username));
        // provide visual notifications if do not disturb is not on
        if (this.notificationOptions.showFavouriteUserLoggedInNotification)
            _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_1__.NotificationManager.getInstance().show(username, `User ${username} has logged in.`, username, _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_1__.NotificationType.warning, 5000);
    }
    handleFavouriteUserLoggedOut(username) {
        logger(`Handle favourite user ${username} logged out`);
        // allow the view to change the user statuses
        this.chatUserListeners.forEach((listener) => listener.handleFavouriteUserLoggedOut(username));
        if (this.notificationOptions.showFavouriteUserLoggedOutNotification)
            _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_1__.NotificationManager.getInstance().show(username, `User ${username} has logged out.`, username, _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_1__.NotificationType.priority, 4000);
    }
    handleBlockedUsersChanged(usernames) {
        logger(`Handle blocked users changed to ${usernames}`);
        this.chatUserListeners.forEach((listener) => listener.handleBlockedUsersChanged(usernames));
    }
    handleFavouriteUsersChanged(usernames) {
        logger(`Handle favourite users changed to ${usernames}`);
        this.chatUserListeners.forEach((listener) => listener.handleFavouriteUsersChanged(usernames));
    }
    startChatWithUser(username) {
        return _ChatManager__WEBPACK_IMPORTED_MODULE_0__.ChatManager.getInstance().startChatWithUser(username);
    }
    handleChatStarted(log) {
        this.chatListeners.forEach((listener) => listener.handleChatStarted(log));
    }
    handleOfflineMessagesReceived(messages) {
        // provide visual notifications if do not disturb is not on
        if (messages.length === 0)
            return;
        if (this.notificationOptions.showOfflineMessageNotification)
            _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_1__.NotificationManager.getInstance().show("Offline messages received", `You have received ${messages.length} messages since you last logged out.`, 'Offline messages');
    }
    setOptions(options) {
        this.notificationOptions = options;
    }
}
//# sourceMappingURL=NotificationController.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/socket/SocketListener.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/socket/SocketListener.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataChangeType": () => (/* binding */ DataChangeType)
/* harmony export */ });
var DataChangeType;
(function (DataChangeType) {
    DataChangeType["create"] = "create";
    DataChangeType["update"] = "update";
    DataChangeType["delete"] = "delete";
    DataChangeType["batchCreate"] = "batchCreate";
    DataChangeType["batchUpdate"] = "batchUpdate";
    DataChangeType["batchDelete"] = "batchDelete";
    DataChangeType["custom1"] = "custom1";
    DataChangeType["custom2"] = "custom2";
    DataChangeType["custom3"] = "custom3";
    DataChangeType["custom4"] = "custom4";
    DataChangeType["custom5"] = "custom5";
    DataChangeType["custom6"] = "custom6";
    DataChangeType["custom7"] = "custom7";
    DataChangeType["custom8"] = "custom8";
    DataChangeType["custom9"] = "custom9";
})(DataChangeType || (DataChangeType = {}));
//# sourceMappingURL=SocketListener.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/socket/SocketManager.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/socket/SocketManager.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SocketManager": () => (/* binding */ SocketManager)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Types */ "./node_modules/ui-framework-jps/dist/framework/socket/Types.js");
/* harmony import */ var _security_SecurityManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../security/SecurityManager */ "./node_modules/ui-framework-jps/dist/framework/security/SecurityManager.js");



const sDebug = debug__WEBPACK_IMPORTED_MODULE_0___default()('socket-ts');
class SocketManager {
    constructor() {
        this.listeners = [];
        this.chatReceivers = [];
        this.isInitialised = false;
        this.socket = null;
        this.callbackForMessage = this.callbackForMessage.bind(this);
        this.callbackForData = this.callbackForData.bind(this);
        this.callbackForMessage = this.callbackForMessage.bind(this);
        this.callbackForLogin = this.callbackForLogin.bind(this);
        this.callbackForLogout = this.callbackForLogout.bind(this);
        this.callbackForJoinRoom = this.callbackForJoinRoom.bind(this);
        this.callbackForExitRoom = this.callbackForExitRoom.bind(this);
        this.callbackForInvite = this.callbackForInvite.bind(this);
        this.callbackForChat = this.callbackForChat.bind(this);
        this.callbackForQueue = this.callbackForQueue.bind(this);
        this.callbackForUserList = this.callbackForUserList.bind(this);
        this.callbackForDeclineInvite = this.callbackForDeclineInvite.bind(this);
    }
    static getInstance() {
        if (!(SocketManager._instance)) {
            SocketManager._instance = new SocketManager();
        }
        return SocketManager._instance;
    }
    addChatReceiver(receiver) {
        this.chatReceivers.push(receiver);
    }
    addListener(listener) {
        sDebug('Adding listener');
        this.listeners.push(listener);
        if (!(this.isInitialised)) {
            this.isInitialised = true;
            this.initialise();
        }
    }
    initialise() {
        sDebug('Creating socket connection');
        // @ts-ignore
        this.socket = io();
        sDebug('Waiting for messages');
        this.socket.on('message', this.callbackForMessage);
        this.socket.on('data', this.callbackForData);
        this.socket.on('login', this.callbackForLogin);
        this.socket.on('logout', this.callbackForLogout);
        this.socket.on('joinroom', this.callbackForJoinRoom);
        this.socket.on('exitroom', this.callbackForExitRoom);
        this.socket.on('invite', this.callbackForInvite);
        this.socket.on('declineinvite', this.callbackForDeclineInvite);
        this.socket.on('chat', this.callbackForChat);
        this.socket.on('queue', this.callbackForQueue);
        this.socket.on('userlist', this.callbackForUserList);
    }
    login(username) {
        this.socket.emit('login', { username });
    }
    logout(username) {
        this.socket.emit('logout', { username });
    }
    joinChat(username, room, type) {
        this.socket.emit('joinroom', { username, room, type });
    }
    leaveChat(username, room, type) {
        this.socket.emit('exitroom', { username, room, type });
    }
    sendInvite(from, to, room, type = _Types__WEBPACK_IMPORTED_MODULE_1__.InviteType.ChatRoom, requiresAcceptDecline = false, subject = '', attachment = {}) {
        let inviteObj = {
            from: from,
            to: to,
            room: room,
            type: type,
            requiresAcceptDecline: requiresAcceptDecline,
            subject: subject,
            attachment: attachment
        };
        sDebug(`Sending invite`);
        sDebug(inviteObj);
        this.socket.emit('invite', inviteObj);
    }
    sendMessage(from, room, message, created, type, priority = _Types__WEBPACK_IMPORTED_MODULE_1__.Priority.Normal, simpleAttachment, attachment = {}) {
        let messageObj = {
            from: from,
            room: room,
            message: message,
            created: created,
            priority: priority,
            type: type,
            simpleAttachment: simpleAttachment,
            attachment: attachment
        };
        this.socket.emit('chat', messageObj);
    }
    getUserList() {
        this.socket.emit('userlist');
    }
    sendDeclineInvite(room, from, type) {
        this.socket.emit('declineinvite', { room, from, type });
    }
    callbackForMessage(content) {
        sDebug(`Received message : ${content}`);
        try {
            sDebug(content);
            // should be a server side ChatMessage {room, message,user}
            const dataObj = JSON.parse(content);
            this.chatReceivers.forEach((receiver) => receiver.receiveMessage(dataObj));
        }
        catch (err) {
            sDebug(err);
            sDebug('Not JSON data');
        }
    }
    callbackForLogin(message) {
        sDebug(`Received login : ${message}`);
        this.chatReceivers.forEach((receiver) => receiver.receiveLogin(message));
    }
    callbackForUserList(message) {
        sDebug(`Received user list : ${message}`);
        this.chatReceivers.forEach((receiver) => receiver.receiveUserList(message));
    }
    callbackForLogout(message) {
        sDebug(`Received logout : ${message}`);
        this.chatReceivers.forEach((receiver) => receiver.receiveLogout(message));
    }
    callbackForJoinRoom(data) {
        sDebug(`Received joined room : ${data}`);
        try {
            const dataObj = JSON.parse(data);
            sDebug(dataObj);
            this.chatReceivers.forEach((receiver) => receiver.receiveJoinedRoom(dataObj));
        }
        catch (err) {
            sDebug('Not JSON data');
        }
    }
    callbackForExitRoom(data) {
        sDebug(`Received left room : ${data}`);
        try {
            const dataObj = JSON.parse(data);
            sDebug(dataObj);
            this.chatReceivers.forEach((receiver) => receiver.receivedLeftRoom(dataObj));
        }
        catch (err) {
            sDebug('Not JSON data');
        }
    }
    callbackForInvite(data) {
        sDebug(`Received invite : ${data}`);
        try {
            const dataObj = JSON.parse(data);
            sDebug(dataObj);
            this.chatReceivers.forEach((receiver) => receiver.receiveInvitation(dataObj));
        }
        catch (err) {
            sDebug('Not JSON data');
        }
    }
    callbackForDeclineInvite(data) {
        sDebug(`Received declined invite : ${data}`);
        try {
            const dataObj = JSON.parse(data);
            sDebug(dataObj);
            this.chatReceivers.forEach((receiver) => receiver.receiveDecline(dataObj.room, dataObj.username, dataObj.type));
        }
        catch (err) {
            sDebug(err);
            sDebug('Not JSON data');
        }
    }
    callbackForChat(content) {
        sDebug(`Received chat : ${content}`);
        try {
            // should be a server side ChatMessage {room, message,user}
            const dataObj = JSON.parse(content);
            sDebug(dataObj);
            this.chatReceivers.forEach((receiver) => receiver.receiveMessage(dataObj));
        }
        catch (err) {
            sDebug('Not JSON data');
        }
    }
    callbackForQueue(data) {
        sDebug(`Received queued items : ${data}`);
        try {
            const dataObj = JSON.parse(data);
            sDebug(dataObj);
            // this object should contain two arrays of invites and messages
            if (dataObj.invites && (dataObj.invites.length > 0)) {
                this.chatReceivers.forEach((receiver) => receiver.receiveQueuedInvites(dataObj.invites));
            }
            if (dataObj.messages && (dataObj.messages.length > 0)) {
                this.chatReceivers.forEach((receiver) => receiver.receiveQueuedMessages(dataObj.messages));
            }
        }
        catch (err) {
            sDebug('Not JSON data');
        }
    }
    /*
    *
    *  expecting a JSON data object with the following attributes
    *  1.  type: "create"|"update"|"delete"
    *  2.  objectType: string name of the object type changed
    *  3.  data: the new representation of the object
    *  4.  user: application specific id for the user who made the change
    *        - the application view is required to implement getCurrentUser() to compare the user who made the change
    *
     */
    callbackForData(message) {
        sDebug(`Received data`);
        try {
            const dataObj = JSON.parse(message);
            sDebug(dataObj);
            if (dataObj.user === _security_SecurityManager__WEBPACK_IMPORTED_MODULE_2__.SecurityManager.getInstance().getCurrentUser()) {
                sDebug("change made by this user, ignoring");
            }
            else {
                sDebug("change made by another user, passing off to the application");
                this.listeners.forEach((listener) => listener.handleDataChangedByAnotherUser(dataObj));
            }
        }
        catch (err) {
            sDebug('Not JSON data');
        }
    }
}
//# sourceMappingURL=SocketManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/socket/Types.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/socket/Types.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Priority": () => (/* binding */ Priority),
/* harmony export */   "InviteType": () => (/* binding */ InviteType)
/* harmony export */ });
var Priority;
(function (Priority) {
    Priority[Priority["Normal"] = 0] = "Normal";
    Priority[Priority["High"] = 1] = "High";
    Priority[Priority["Urgent"] = 2] = "Urgent";
})(Priority || (Priority = {}));
var InviteType;
(function (InviteType) {
    InviteType[InviteType["ChatRoom"] = 0] = "ChatRoom";
    InviteType[InviteType["CustomType1"] = 1] = "CustomType1";
    InviteType[InviteType["CustomType2"] = 2] = "CustomType2";
    InviteType[InviteType["CustomType3"] = 3] = "CustomType3";
    InviteType[InviteType["CustomType4"] = 4] = "CustomType4";
    InviteType[InviteType["CustomType5"] = 5] = "CustomType5";
    InviteType[InviteType["CustomType6"] = 6] = "CustomType6";
    InviteType[InviteType["CustomType7"] = 7] = "CustomType7";
    InviteType[InviteType["CustomType8"] = 8] = "CustomType8";
    InviteType[InviteType["CustomType9"] = 9] = "CustomType9";
})(InviteType || (InviteType = {}));
//# sourceMappingURL=Types.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/state/delegate/StateChangedDelegate.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/state/delegate/StateChangedDelegate.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StateChangedDelegate": () => (/* binding */ StateChangedDelegate)
/* harmony export */ });
/* harmony import */ var _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interface/StateManager */ "./node_modules/ui-framework-jps/dist/framework/state/interface/StateManager.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_1__);


const smLogger = debug__WEBPACK_IMPORTED_MODULE_1___default()('state-manager-delegate');
class StateChangedDelegate {
    constructor(managerName) {
        this.suppressEventEmits = false;
        this.managerName = managerName;
        this.stateChangeListeners = [];
    }
    suppressEvents() {
        this.suppressEventEmits = true;
    }
    emitEvents() {
        this.suppressEventEmits = false;
    }
    informChangeListenersForStateWithName(name, stateObjValue, eventType = _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.StateChanged, previousObjValue = null) {
        smLogger(`State Manager: Informing state listeners of ${name}`);
        if (this.suppressEventEmits) {
            smLogger(`State Manager: Events suppressed`);
            return;
        }
        const foundIndex = this.stateChangeListeners.findIndex(element => element.name === name);
        if (foundIndex >= 0) {
            smLogger(`State Manager: Found state listeners of ${name} with event type ${eventType}`);
            /* let each state change listener know */
            const changeListenersForName = this.stateChangeListeners[foundIndex];
            changeListenersForName.listeners.forEach((listener) => {
                smLogger(`State Manager: Found state listener of ${name} with name ${listener.getListenerName()} - informing`);
                try {
                    switch (eventType) {
                        case (_interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.StateChanged): {
                            listener.stateChanged(this.managerName, name, stateObjValue);
                            break;
                        }
                        case (_interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.ItemAdded): {
                            listener.stateChangedItemAdded(this.managerName, name, stateObjValue);
                            break;
                        }
                        case (_interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.ItemUpdated): {
                            listener.stateChangedItemUpdated(this.managerName, name, previousObjValue, stateObjValue);
                            break;
                        }
                        case (_interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.ItemDeleted): {
                            listener.stateChangedItemRemoved(this.managerName, name, stateObjValue);
                            break;
                        }
                        case (_interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.FilterResults): {
                            listener.filterResults(this.managerName, name, stateObjValue);
                            break;
                        }
                        case (_interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.FindItem): {
                            listener.foundResult(this.managerName, name, stateObjValue);
                            break;
                        }
                    }
                }
                catch (err) {
                    smLogger(err);
                }
            });
        }
    }
    /*
          Add a state listener for a given state name
          the listener should be a function with two parameters
          name - string - the name of the state variable that they want to be informed about
          stateObjValue - object - the new state value
         */
    addChangeListenerForName(name, listener) {
        this.ensureListenerSetupForName(name);
        smLogger(`State Manager: Adding state listener for ${name} with name ${listener.getListenerName()}`);
        const foundIndex = this.stateChangeListeners.findIndex(element => element.name === name);
        if (foundIndex >= 0) {
            smLogger(`State Manager: Adding state listener for ${name} with name ${listener.getListenerName()} with index ${foundIndex}`);
            let changeListenersForName = this.stateChangeListeners[foundIndex];
            changeListenersForName.listeners.push(listener);
        }
    }
    ensureListenerSetupForName(name) {
        const foundIndex = this.stateChangeListeners.findIndex(element => element.name === name);
        if (foundIndex < 0) {
            const listenersNameArrayPair = {
                name,
                listeners: [],
            };
            this.stateChangeListeners.push(listenersNameArrayPair);
        }
    }
    isEmittingEvents() {
        return !this.suppressEventEmits;
    }
}
//# sourceMappingURL=StateChangedDelegate.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/state/delegate/StateContextDelegate.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/state/delegate/StateContextDelegate.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StateContextDelegate": () => (/* binding */ StateContextDelegate)
/* harmony export */ });
class StateContextDelegate {
    constructor(owner, name, supplier) {
        this.owner = owner;
        this.name = name;
        this.supplier = supplier;
        this.supplier.addListener(this);
    }
    stateContextChanged(newContext) {
        this.owner.setStateByName(this.name, this.supplier.getStateFromContext(), true);
    }
    getContextForApi() {
        return this.supplier.getContextForApi();
    }
}
//# sourceMappingURL=StateContextDelegate.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/state/helper/AsyncStateManagerWrapper.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/state/helper/AsyncStateManagerWrapper.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsyncStateManagerWrapper": () => (/* binding */ AsyncStateManagerWrapper)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _implementation_AbstractStateManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../implementation/AbstractStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/AbstractStateManager.js");


const asyncLogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('state-manager-async');
class AsyncStateManagerWrapper extends _implementation_AbstractStateManager__WEBPACK_IMPORTED_MODULE_1__.AbstractStateManager {
    constructor(topLevelSM, wrappedSM, defaultEq) {
        super('async', defaultEq);
        this.topLevelSM = topLevelSM;
        this.wrappedSM = wrappedSM;
        this.forceSaves = false;
        this.wrappedSM.emitEvents();
        let stateNamesToMonitor = this.wrappedSM.getConfiguredStateNames();
        this.stateChanged = this.stateChanged.bind(this);
        this.stateChangedItemAdded = this.stateChangedItemAdded.bind(this);
        this.stateChangedItemRemoved = this.stateChangedItemRemoved.bind(this);
        this.stateChangedItemUpdated = this.stateChangedItemUpdated.bind(this);
        stateNamesToMonitor.forEach((stateName) => {
            this.wrappedSM.addChangeListenerForName(stateName, this);
        });
    }
    getAvailableStateNames() {
        return this.wrappedSM.getAvailableStateNames();
    }
    getType() {
        return this.wrappedSM.getType();
    }
    _findItemsInState(name, filters) {
        asyncLogger(`finding items with filters`);
        return this.wrappedSM.findItemsInState(name, filters);
    }
    _findItemInState(name, stateObj) {
        asyncLogger(`finding item `);
        return this.wrappedSM.findItemInState(name, stateObj);
    }
    _addItemToState(name, stateObj, isPersisted = false) {
        asyncLogger(`adding item to state ${name} - is persisted ${isPersisted}`);
        this.wrappedSM.addNewItemToState(name, stateObj, isPersisted);
    }
    _getState(name) {
        // assume wrapped SM is asynchronous
        // make the call to get state but supply the caller with an empty state for now
        asyncLogger(`getting state ${name}`);
        this.wrappedSM.getStateByName(name);
        return { name: name, value: [], hasBeenSet: false };
    }
    _removeItemFromState(name, stateObj, isPersisted) {
        asyncLogger(`removing item from state ${name} is persisted ${isPersisted}`);
        this.wrappedSM.removeItemFromState(name, stateObj, isPersisted);
    }
    _updateItemInState(name, stateObj, isPersisted) {
        asyncLogger(`updating item in state ${name}`);
        this.wrappedSM.updateItemInState(name, stateObj, isPersisted);
    }
    _ensureStatePresent(name) {
    } // assume already present
    _addNewNamedStateToStorage(state) {
    } // assume already present
    _replaceNamedStateInStorage(state) {
    } // not implemented, not replacing state wholesale
    _saveState(name, stateObj) {
    } // not implemented, not replacing state wholesale
    stateChangedItemRemoved(managerName, name, itemRemoved) {
    } // not implemented, assumes called to wrapped SM worked
    stateChangedItemUpdated(managerName, name, itemUpdated, itemNewValue) {
    } // not implemented, assumes called to wrapped SM worked
    stateChanged(managerName, name, newValue) {
        // received new state from the wrapped SM
        // pass the received state to the top level SM
        asyncLogger(`Wrapped SM has supplied new state ${name} passing to top level SM`);
        asyncLogger(newValue);
        this.topLevelSM.setStateByName(name, newValue);
    }
    stateChangedItemAdded(managerName, name, itemAdded) {
        asyncLogger(`Wrapped SM has supplied new completed item for state ${name} passing to top level SM`);
        this.topLevelSM.addNewItemToState(name, itemAdded, true);
    }
    getListenerName() {
        return "Async Manager";
    }
    filterResults(managerName, name, filterResults) {
        asyncLogger(`Wrapped SM has supplied filter results ${name} passing to top level SM`);
        this.topLevelSM.receivedFilterResults(name, filterResults);
    }
    foundResult(managerName, name, foundItem) {
        this.topLevelSM.receivedFoundItem(name, foundItem);
    }
    fireStateChangedForAllStates() {
    }
}
//# sourceMappingURL=AsyncStateManagerWrapper.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/state/helper/DefaultStateContextSupplier.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/state/helper/DefaultStateContextSupplier.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultStateContextSupplier": () => (/* binding */ DefaultStateContextSupplier)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);

const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('default-state-context-supplier');
class DefaultStateContextSupplier {
    constructor(name, supplyingStateManager, equalityFn, contextConfig) {
        this.currentContext = null;
        logger(`Setting up default context supplier for state ${name}`);
        this.name = name;
        this.listeners = [];
        this.equalityFn = equalityFn;
        this.contextConfig = contextConfig;
        supplyingStateManager.addChangeListenerForName(this.name, this);
    }
    addListener(listener) {
        this.listeners.push(listener);
    }
    foundResult(managerName, name, foundItem) {
        if (this.currentContext) {
            if (this.equalityFn(this.currentContext, foundItem)) {
                logger(`Found result for state ${name} - informing listeners of the new context`);
                this.listeners.forEach((listener) => listener.stateContextChanged(null));
            }
        }
    }
    getListenerName() {
        return "";
    }
    filterResults(managerName, name, filterResults) { }
    stateChanged(managerName, name, newValue) { }
    stateChangedItemAdded(managerName, name, itemAdded) { }
    stateChangedItemRemoved(managerName, name, itemRemoved) {
        // if the item removed was the current context, empty the context
        if (this.currentContext) {
            if (this.equalityFn(this.currentContext, itemRemoved)) {
                logger(`Context for state ${name} has been removed - informing listeners of the empty context`);
                this.currentContext = null;
                this.listeners.forEach((listener) => listener.stateContextChanged(null));
            }
        }
    }
    stateChangedItemUpdated(managerName, name, itemUpdated, itemNewValue) {
        // if the item update was the current context, update the context
        if (this.currentContext) {
            if (this.equalityFn(this.currentContext, itemNewValue)) {
                this.currentContext = itemNewValue;
                logger(`Context for state ${name} has been updated - informing listeners of the new context`);
                this.listeners.forEach((listener) => listener.stateContextChanged(itemNewValue));
            }
        }
    }
    clearContext() {
        logger(`Context has been cleared - informing listeners of the empty context`);
        this.currentContext = null;
        this.listeners.forEach((listener) => listener.stateContextChanged(null));
    }
    setContext(context) {
        logger(`Context has been set - informing listeners of the new context`);
        this.currentContext = context;
        this.listeners.forEach((listener) => listener.stateContextChanged(context));
    }
    getContext() {
        return this.currentContext;
    }
    getStateFromContext() {
        let result = [];
        if (this.contextConfig) {
            if (this.currentContext) {
                let stateValue = this.currentContext[this.contextConfig.contextObjectStateAttribute];
                if (stateValue) {
                    if (!this.contextConfig.contextObjectStateAttributeIsArray) {
                        stateValue = [stateValue];
                    }
                    result = stateValue;
                }
            }
        }
        return result;
    }
    getContextForApi() {
        let result = "";
        if (this.contextConfig) {
            if (this.currentContext) {
                result = this.currentContext[this.contextConfig.contextObjectId];
                if (!(result)) {
                    result = "";
                }
            }
        }
        return result;
    }
}
//# sourceMappingURL=DefaultStateContextSupplier.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/state/helper/PersistentLocalCache.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/state/helper/PersistentLocalCache.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PersistentLocalCache": () => (/* binding */ PersistentLocalCache)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _socket_SocketListener__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../socket/SocketListener */ "./node_modules/ui-framework-jps/dist/framework/socket/SocketListener.js");
/* harmony import */ var _implementation_IndexedDBStateManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../implementation/IndexedDBStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/IndexedDBStateManager.js");
/* harmony import */ var _security_SecurityManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../security/SecurityManager */ "./node_modules/ui-framework-jps/dist/framework/security/SecurityManager.js");
/* harmony import */ var _socket_SocketManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../socket/SocketManager */ "./node_modules/ui-framework-jps/dist/framework/socket/SocketManager.js");
/* harmony import */ var _network_ApiUtil__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../network/ApiUtil */ "./node_modules/ui-framework-jps/dist/framework/network/ApiUtil.js");
/* harmony import */ var _model_ObjectDefinitionRegistry__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../model/ObjectDefinitionRegistry */ "./node_modules/ui-framework-jps/dist/framework/model/ObjectDefinitionRegistry.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};









const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('persistent-local-cache');
class PersistentLocalCache {
    constructor() {
        this.cacheConfig = [];
        this.dbName = '';
        this.refreshDates = {};
        this.hasLoadedUpdatedDates = false;
        this.hasLoadedCache = false;
        this.hasLoadedRefreshDates = false;
        this.lastUpdatedDates = [];
        this.isLoadingLastUpdateDates = false;
        this.cache = new _implementation_IndexedDBStateManager__WEBPACK_IMPORTED_MODULE_3__.IndexedDBStateManager();
        this.callbackForLastUpdatedDates = this.callbackForLastUpdatedDates.bind(this);
        this.loadLastUpdatedDates();
        _model_ObjectDefinitionRegistry__WEBPACK_IMPORTED_MODULE_7__.ObjectDefinitionRegistry.getInstance().addDefinition(PersistentLocalCache.COLLECTION_NAME_LAST_REFRESHED, 'Local Cache', true, false, false, "_id");
    }
    static getInstance() {
        if (!(PersistentLocalCache._instance)) {
            PersistentLocalCache._instance = new PersistentLocalCache();
        }
        return PersistentLocalCache._instance;
    }
    getLocalStorageKey(collectionName) {
        return `${this.dbName}.${PersistentLocalCache.COLLECTION_NAME_PREFIX}${collectionName}`;
    }
    callbackForLastUpdatedDates(data, status) {
        logger(`Callback - Last updated dates`);
        if (status === 200) {
            logger(`Last updated dates`);
            this.hasLoadedUpdatedDates = true;
            this.lastUpdatedDates = data;
            this.loadCache();
        }
    }
    loadLastUpdatedDates() {
        if (this.isLoadingLastUpdateDates)
            return;
        this.isLoadingLastUpdateDates = true;
        logger(`Getting last updated dates`);
        let request = {
            url: PersistentLocalCache.DEFAULT_URL_FOR_LAST_UPDATED_DATES,
            body: {},
            callback: this.callbackForLastUpdatedDates
        };
        _network_ApiUtil__WEBPACK_IMPORTED_MODULE_6__.ApiUtil.getInstance().simplePOSTJSON(request);
    }
    stateChanged(managerName, name, newValue) {
        switch (managerName) {
            case 'indexeddb': {
                if (name === PersistentLocalCache.COLLECTION_NAME_LAST_REFRESHED) {
                    logger(`Loading last refresh dates`);
                    logger(newValue);
                    const nowAsNumber = parseInt(moment__WEBPACK_IMPORTED_MODULE_1___default()().format('YYYYMMDDHHmmss'));
                    if (newValue.length > 0) {
                        this.refreshDates = newValue[0];
                        this.cacheConfig.forEach((config) => {
                            const lastRefresh = this.refreshDates[config.name];
                            // when was the state last updated?
                            const foundIndex = this.lastUpdatedDates.findIndex((value) => value.name === config.name);
                            let lastUpdated = 0;
                            if (foundIndex >= 0) {
                                lastUpdated = this.lastUpdatedDates[foundIndex].lastUpdated;
                                logger(`collection ${config.name} last updated at server ${lastUpdated}`);
                            }
                            if (lastRefresh) {
                                // check to see if we need an update
                                logger(`collection ${config.name} last refreshed ${lastRefresh}`);
                                const lastRefreshPlusInterval = parseInt(moment__WEBPACK_IMPORTED_MODULE_1___default()(lastRefresh, 'YYYYMMDDHHmmss').add(config.refreshInterval, 'seconds').format('YYYYMMDDHHmmss'));
                                if (lastRefreshPlusInterval < nowAsNumber) {
                                    logger(`Refresh interval expired, should refresh`);
                                    localStorage.removeItem(this.getLocalStorageKey(config.name));
                                    config.lastRefreshed = nowAsNumber;
                                    this.refreshDates[config.name] = nowAsNumber;
                                    config.shouldRefresh = true;
                                }
                                if (lastUpdated > lastRefresh) {
                                    logger(`Last updated at server is after last refresh`);
                                    localStorage.removeItem(this.getLocalStorageKey(config.name));
                                    config.lastRefreshed = nowAsNumber;
                                    this.refreshDates[config.name] = nowAsNumber;
                                    config.shouldRefresh = true;
                                }
                            }
                            else {
                                logger(`No refresh, setting to now`);
                                localStorage.removeItem(this.getLocalStorageKey(config.name));
                                config.lastRefreshed = nowAsNumber;
                                this.refreshDates[config.name] = nowAsNumber;
                                config.shouldRefresh = true;
                            }
                        });
                    }
                    else {
                        logger(`No refresh dates, setting to now`);
                        this.refreshDates['_id'] = (0,uuid__WEBPACK_IMPORTED_MODULE_8__["default"])();
                        this.cacheConfig.forEach((config) => {
                            localStorage.removeItem(this.getLocalStorageKey(config.name));
                            config.lastRefreshed = nowAsNumber;
                            this.refreshDates[config.name] = nowAsNumber;
                            config.shouldRefresh = true;
                        });
                    }
                    logger(`New refresh dates are:`);
                    logger(this.refreshDates);
                    this.cache.updateItemInCollection(PersistentLocalCache.COLLECTION_NAME_LAST_REFRESHED, this.refreshDates, "_id");
                    this.hasLoadedRefreshDates = true;
                    this.loadCache();
                }
                else {
                    // is this one of the states we are monitoring
                    const foundIndex = this.cacheConfig.findIndex((config) => config.name === name);
                    if (foundIndex >= 0) {
                        const config = this.cacheConfig[foundIndex];
                        logger(`Collection ${config.name} received from local cache - loading into application state`);
                        this.applicationState.setStateByName(config.name, newValue, true);
                    }
                }
                break;
            }
            default: { // remote source
                // is this one of the states we are monitoring
                const foundIndex = this.cacheConfig.findIndex((config) => config.name === name);
                if (foundIndex >= 0) {
                    const config = this.cacheConfig[foundIndex];
                    const previouslyLoaded = localStorage.getItem(this.getLocalStorageKey(config.name));
                    if (config.shouldRefresh || (!(previouslyLoaded))) {
                        config.shouldRefresh = false;
                        config.lastRefreshed = parseInt(moment__WEBPACK_IMPORTED_MODULE_1___default()().format('YYYYMMDDHHmmss'));
                        localStorage.setItem(this.getLocalStorageKey(config.name), `${config.lastRefreshed}`);
                        this.refreshDates[config.name] = config.lastRefreshed;
                        logger(`Collection ${config.name} received from remote source - loading into cache`);
                        this.cache.setStateByName(config.name, newValue, false);
                        logger(`Updating last refreshed for ${config.name} to now`);
                        logger(this.refreshDates);
                        this.cache.updateItemInCollection(PersistentLocalCache.COLLECTION_NAME_LAST_REFRESHED, this.refreshDates, "_id");
                    }
                    else {
                        logger(`Already received ${config.name} from cache`);
                    }
                }
            }
        }
    }
    getListenerName() {
        return 'Persistent Cache';
    }
    addCollectionToCacheConfiguration(collectionName, keyField, source, refreshInSeconds) {
        this.cacheConfig.push({
            name: collectionName,
            keyField: keyField,
            source: source,
            refreshInterval: refreshInSeconds,
            lastRefreshed: 0,
            shouldRefresh: false
        });
        this.cache.addChangeListenerForName(collectionName, this);
        source.addChangeListenerForName(collectionName, this);
    }
    initialiseAfterCollectionsAddedToCacheConfiguration(dbName, applicationState) {
        return __awaiter(this, void 0, void 0, function* () {
            this.applicationState = applicationState;
            this.dbName = dbName;
            const collections = [];
            this.cacheConfig.forEach((config) => {
                collections.push({
                    name: config.name,
                    keyField: config.keyField
                });
            });
            // add the collection for the refresh dates
            collections.push({
                name: PersistentLocalCache.COLLECTION_NAME_LAST_REFRESHED,
                keyField: '_id'
            });
            this.cache.addChangeListenerForName(PersistentLocalCache.COLLECTION_NAME_LAST_REFRESHED, this);
            const result = yield this.cache.initialise(dbName, collections);
            // load the last refresh dates
            this.cache.getStateByName(PersistentLocalCache.COLLECTION_NAME_LAST_REFRESHED);
        });
    }
    isReadyToLoadCache() {
        return (this.hasLoadedRefreshDates && this.hasLoadedUpdatedDates);
    }
    loadCache() {
        logger(`loading cache - already loaded? ${this.hasLoadedCache}, updates dates from server loaded? ${this.hasLoadedUpdatedDates}, refresh dates loaded? ${this.hasLoadedRefreshDates}`);
        if (!(this.hasLoadedUpdatedDates))
            return;
        if (!(this.hasLoadedRefreshDates))
            return;
        if (this.hasLoadedCache)
            return;
        this.cacheConfig.forEach((config) => {
            // check to see if needs to be refreshed
            const cacheLoaded = localStorage.getItem(this.getLocalStorageKey(config.name));
            if (cacheLoaded) {
                logger(`${config.name} has been previously loaded, needs refresh? ${config.shouldRefresh}`);
                if (config.shouldRefresh) {
                    logger(`Loading ${config.name} from remote source`);
                    config.source.forceResetForGet(config.name);
                    config.source.getStateByName(config.name);
                }
                else {
                    logger(`Cache for ${config.name} is up to date, getting from cache`);
                    config.source.setCompletedRun(config.name, []);
                    this.cache.getStateByName(config.name);
                }
            }
            else {
                logger(`Loading ${config.name} from remote source`);
                config.source.forceResetForGet(config.name);
                config.source.getStateByName(config.name);
            }
        });
    }
    onDocumentLoaded() {
        _socket_SocketManager__WEBPACK_IMPORTED_MODULE_5__.SocketManager.getInstance().addListener(this);
        if (this.hasLoadedUpdatedDates) {
            if (this.hasLoadedRefreshDates) {
                this.loadCache();
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    stateChangedItemAdded(managerName, name, itemAdded) { }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    stateChangedItemRemoved(managerName, name, itemRemoved) { }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    stateChangedItemUpdated(managerName, name, itemUpdated, itemNewValue) { }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    filterResults(managerName, name, filterResults) { }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    foundResult(managerName, name, foundItem) { }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    handleMessage(message) { }
    getCurrentUser() {
        return _security_SecurityManager__WEBPACK_IMPORTED_MODULE_4__.SecurityManager.getInstance().getLoggedInUserId();
    }
    handleDataChangedByAnotherUser(message) {
        const stateObj = message.data;
        logger(stateObj);
        // update our local cache with the new changes (relies on the socket telling us about them!)
        try {
            const foundIndex = this.cacheConfig.findIndex((config) => config.name === message.stateName);
            if (foundIndex >= 0) {
                const config = this.cacheConfig[foundIndex];
                const nowAsNumber = parseInt(moment__WEBPACK_IMPORTED_MODULE_1___default()().format('YYYYMMDDHHmmss'));
                this.refreshDates[config.name] = nowAsNumber;
                logger(`Received data message for ${config.name} with message type ${message.type}`);
                this.cache.updateItemInCollection(PersistentLocalCache.COLLECTION_NAME_LAST_REFRESHED, this.refreshDates, "_id").then(() => {
                    switch (message.type) {
                        case _socket_SocketListener__WEBPACK_IMPORTED_MODULE_2__.DataChangeType.create: {
                            this.cache.addNewItemToState(config.name, stateObj, false);
                            break;
                        }
                        case _socket_SocketListener__WEBPACK_IMPORTED_MODULE_2__.DataChangeType.update: {
                            this.cache.updateItemInState(config.name, stateObj, false);
                            break;
                        }
                        case _socket_SocketListener__WEBPACK_IMPORTED_MODULE_2__.DataChangeType["delete"]: {
                            this.cache.removeItemFromState(config.name, stateObj, false);
                            break;
                        }
                    }
                });
            }
        }
        catch (err) {
            logger(err);
        }
    }
}
PersistentLocalCache.COLLECTION_NAME_LAST_REFRESHED = 'persistent-local-cache-last-refresh';
PersistentLocalCache.COLLECTION_NAME_PREFIX = 'persistent-local-cache-';
PersistentLocalCache.DEFAULT_URL_FOR_LAST_UPDATED_DATES = '/getlastupdateddates';
//# sourceMappingURL=PersistentLocalCache.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/state/helper/StateTimingManager.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/state/helper/StateTimingManager.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StateTimingManager": () => (/* binding */ StateTimingManager)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);

const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('state-timing-manager');
class StateTimingManager {
    constructor(applicationStateManager) {
        this.applicationStateManager = applicationStateManager;
        this.states = [];
        this.listeners = [];
        this.stateAllLoaded = false;
    }
    addListener(listener) {
        this.listeners.push(listener);
    }
    addCollectionToTimer(collectionName, displayName) {
        this.states.push({
            name: collectionName,
            displayName: displayName,
            isLoaded: false
        });
        this.applicationStateManager.addChangeListenerForName(collectionName, this);
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    stateChangedItemAdded(managerName, name, itemAdded) {
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    stateChangedItemRemoved(managerName, name, itemRemoved) {
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    stateChangedItemUpdated(managerName, name, itemUpdated, itemNewValue) {
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    filterResults(managerName, name, filterResults) {
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    foundResult(managerName, name, foundItem) {
    }
    getListenerName() {
        return "State Timing Manager";
    }
    getTotalStateCount() {
        return this.states.length;
    }
    getNumberOfStatesLoaded() {
        let result = 0;
        this.states.forEach((state) => {
            if (state.isLoaded) {
                result++;
            }
        });
        return result;
    }
    stateChanged(managerName, name, newValue) {
        if (this.stateAllLoaded)
            return;
        const foundIndex = this.states.findIndex((config) => config.name === name);
        if (foundIndex >= 0) {
            const config = this.states[foundIndex];
            logger(`Collection ${config.name} received - setting loaded`);
            config.isLoaded = true;
            this.listeners.forEach((listener) => listener.stateLoaded(config.name, config.displayName));
            logger(`Checking to see if all configured states loaded`);
            let loadedCount = 0;
            let buffer = 'Still waiting for ';
            this.states.forEach((state) => {
                if (state.isLoaded) {
                    loadedCount++;
                }
                else {
                    buffer += state.name + ', ';
                }
            });
            if (loadedCount === this.states.length) {
                logger(`All configured states loaded, informing listeners`);
                this.stateAllLoaded = true;
                this.listeners.forEach((listener) => listener.allConfiguredStatesAreLoaded());
            }
            else {
                logger(buffer);
            }
        }
        else {
            logger(`Collection ${name} received - NOT FOUND in config`);
        }
    }
}
//# sourceMappingURL=StateTimingManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/state/implementation/AbstractAsynchronousStateManager.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/state/implementation/AbstractAsynchronousStateManager.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractAsynchronousStateManager": () => (/* binding */ AbstractAsynchronousStateManager)
/* harmony export */ });
/* harmony import */ var _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interface/StateManager */ "./node_modules/ui-framework-jps/dist/framework/state/interface/StateManager.js");
/* harmony import */ var _delegate_StateContextDelegate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../delegate/StateContextDelegate */ "./node_modules/ui-framework-jps/dist/framework/state/delegate/StateContextDelegate.js");
/* harmony import */ var _delegate_StateChangedDelegate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../delegate/StateChangedDelegate */ "./node_modules/ui-framework-jps/dist/framework/state/delegate/StateChangedDelegate.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_3__);




const logger = debug__WEBPACK_IMPORTED_MODULE_3___default()('abstract-async-state-manager');
class AbstractAsynchronousStateManager {
    constructor(id, managerName) {
        this.contextDelegate = null;
        this.initialised = false;
        this.delegate = new _delegate_StateChangedDelegate__WEBPACK_IMPORTED_MODULE_2__.StateChangedDelegate(managerName);
        this.emitEvents();
        this.bHasCompletedRun = [];
        this.bIsRunInProgress = [];
        this.managerName = managerName;
        this.stateBuffers = [];
    }
    postInitialise() {
    }
    addChangeListenerForName(name, listener) {
        this.delegate.addChangeListenerForName(name, listener);
        /* have we already completed the run for the state? */
        if (this.hasCompletedRun(name)) {
            let foundIndex = this.stateBuffers.findIndex(element => element.name === name);
            if (foundIndex >= 0) {
                let state = this.stateBuffers[foundIndex];
                listener.stateChanged(this.managerName, name, state.value);
            }
        }
    }
    addStateNameToConfigurations(stateName) {
        let state = {
            name: stateName,
            value: [],
            hasBeenSet: false
        };
        this.stateBuffers.push(state);
        this.bIsRunInProgress.push(false);
        this.bHasCompletedRun.push(false);
    }
    forceResetForGet(stateName) {
        let foundIndex = this.stateBuffers.findIndex((config) => config.name === stateName);
        if (foundIndex >= 0) {
            this.bHasCompletedRun[foundIndex] = false;
            this.bIsRunInProgress[foundIndex] = false;
        }
    }
    getConfiguredStateNames() {
        let results = [];
        this.stateBuffers.forEach((config) => {
            results.push(config.name);
        });
        return results;
    }
    hasCompletedRun(stateName) {
        let result = false;
        let foundIndex = this.stateBuffers.findIndex((config) => config.name === stateName);
        if (foundIndex >= 0) {
            result = this.bHasCompletedRun[foundIndex];
        }
        return result;
    }
    setCompletedRun(stateName, values) {
        let foundIndex = this.stateBuffers.findIndex((config) => config.name === stateName);
        if (foundIndex >= 0) {
            this.bHasCompletedRun[foundIndex] = true;
            this.bIsRunInProgress[foundIndex] = false;
            this.stateBuffers[foundIndex].value = values;
        }
    }
    isRunInProgress(stateName) {
        let result = false;
        let foundIndex = this.stateBuffers.findIndex((config) => config.name === stateName);
        if (foundIndex >= 0) {
            result = this.bIsRunInProgress[foundIndex];
        }
        return result;
    }
    setRunInProgress(stateName) {
        let foundIndex = this.stateBuffers.findIndex((config) => config.name === stateName);
        if (foundIndex >= 0) {
            this.bIsRunInProgress[foundIndex] = true;
        }
    }
    clearRunInProgress(stateName) {
        let foundIndex = this.stateBuffers.findIndex((config) => config.name === stateName);
        if (foundIndex >= 0) {
            this.bIsRunInProgress[foundIndex] = false;
        }
    }
    setContextSupplier(name, supplier) {
        this.contextDelegate = new _delegate_StateContextDelegate__WEBPACK_IMPORTED_MODULE_1__.StateContextDelegate(this, name, supplier);
    }
    stateContextChanged(newContext) {
    }
    addNewItemToState(name, item, isPersisted) {
        this._addItemToState(name, item, isPersisted);
    }
    emitEvents() {
        this.delegate.emitEvents();
    }
    findItemInState(name, item) {
        return this._findItemInState(name, item);
    }
    getStateByName(name) {
        let result = [];
        if (this.isRunInProgress(name)) {
            logger(`Getting state for name ${name} in progress`);
            return [];
        }
        else if (this.hasCompletedRun(name)) {
            logger(`Getting state for name ${name} has already completed`);
            let foundIndex = this.stateBuffers.findIndex(element => element.name === name);
            if (foundIndex >= 0) {
                let state = this.stateBuffers[foundIndex];
                result = state.value;
            }
        }
        else {
            this._getState(name);
        }
        return result;
    }
    informChangeListenersForStateWithName(name, stateObjValue, eventType, previousObjValue) {
        this.delegate.informChangeListenersForStateWithName(name, stateObjValue, eventType, previousObjValue);
    }
    isItemInState(name, item) {
        return true;
    }
    removeItemFromState(name, item, isPersisted) {
        logger(`Removing item from state ${name} is persisted ${isPersisted}`);
        logger(item);
        this._removeItemFromState(name, item, isPersisted);
        return true;
    }
    setStateByName(name, stateObjectForName, informListeners) {
        // state supplied from elsewhere, set run completed
    }
    suppressEvents() {
        this.delegate.suppressEvents();
    }
    updateItemInState(name, item, isPersisted) {
        this._updateItemInState(name, item, isPersisted);
        return true;
    }
    findItemsInState(name, filters) {
        return this._findItemsInState(name, filters);
    }
    getType() {
        return _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateManagerType.AsyncRemote;
    }
    fireStateChanged(name) {
        if (this.isEmittingEvents()) {
            let foundIndex = this.stateBuffers.findIndex((config) => config.name === name);
            if (foundIndex >= 0) {
                const state = this.stateBuffers[foundIndex];
                this.delegate.informChangeListenersForStateWithName(name, state.value, _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.StateChanged, null);
            }
        }
    }
    fireStateChangedForAllStates() {
        if (this.isEmittingEvents()) {
            this.stateBuffers.forEach((state) => {
                this.delegate.informChangeListenersForStateWithName(state.name, state.value, _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.StateChanged, null);
            });
        }
    }
    isEmittingEvents() {
        return this.delegate.isEmittingEvents();
    }
    getAvailableStateNames() {
        return this.getConfiguredStateNames();
    }
    isInitialised() {
        return this.initialised;
    }
    setInitialised() {
        this.initialised = true;
    }
}
//# sourceMappingURL=AbstractAsynchronousStateManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/state/implementation/AbstractStateManager.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/state/implementation/AbstractStateManager.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractStateManager": () => (/* binding */ AbstractStateManager)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _interface_StateManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../interface/StateManager */ "./node_modules/ui-framework-jps/dist/framework/state/interface/StateManager.js");
/* harmony import */ var _delegate_StateChangedDelegate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../delegate/StateChangedDelegate */ "./node_modules/ui-framework-jps/dist/framework/state/delegate/StateChangedDelegate.js");
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");
/* harmony import */ var _delegate_StateContextDelegate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../delegate/StateContextDelegate */ "./node_modules/ui-framework-jps/dist/framework/state/delegate/StateContextDelegate.js");





const smLogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('state-manager-ts');
const smLoggerDetail = debug__WEBPACK_IMPORTED_MODULE_0___default()('state-manager-ts:detail');
class AbstractStateManager {
    constructor(managerName, defaultEquality, fnPerState = null) {
        this.forceSaves = true;
        this.managerName = '';
        this.equalityFns = null;
        this.contextDelegate = null;
        this.delegate = new _delegate_StateChangedDelegate__WEBPACK_IMPORTED_MODULE_2__.StateChangedDelegate(managerName);
        this.managerName = managerName;
        this.defaultEquality = defaultEquality;
        if (fnPerState) {
            this.equalityFns = fnPerState;
        }
        this.emitEvents();
        this.forceSaves = true;
    }
    setContextSupplier(name, supplier) {
        this.contextDelegate = new _delegate_StateContextDelegate__WEBPACK_IMPORTED_MODULE_4__.StateContextDelegate(this, name, supplier);
    }
    stateContextChanged(newContext) { }
    receivedFilterResults(name, filterResults) {
        this.delegate.informChangeListenersForStateWithName(name, filterResults, _interface_StateManager__WEBPACK_IMPORTED_MODULE_1__.StateEventType.FilterResults, null);
    }
    receivedFoundItem(name, foundItem) {
        this.delegate.informChangeListenersForStateWithName(name, foundItem, _interface_StateManager__WEBPACK_IMPORTED_MODULE_1__.StateEventType.FindItem, null);
    }
    suppressEvents() {
        this.delegate.suppressEvents();
    }
    emitEvents() {
        this.delegate.emitEvents();
    }
    dontForceSavesOnAddRemoveUpdate() {
        this.forceSaves = false;
    }
    forceSavesOnAddRemoveUpdate() {
        this.forceSaves = true;
    }
    informChangeListenersForStateWithName(name, stateObjValue, eventType = _interface_StateManager__WEBPACK_IMPORTED_MODULE_1__.StateEventType.StateChanged, previousObjValue = null) {
        this.delegate.informChangeListenersForStateWithName(name, stateObjValue, eventType, previousObjValue);
    }
    addChangeListenerForName(name, listener) {
        this.delegate.addChangeListenerForName(name, listener);
    }
    _findItemInState(name, item) {
        let result = {};
        const state = this.getStateByName(name);
        const foundIndex = state.findIndex((element) => this.getEqualityFnForName(name)(element, item));
        smLogger(`Finding item in state ${name} - found index ${foundIndex}`);
        smLogger(item);
        if (foundIndex >= 0) {
            result = state[foundIndex];
        }
        return result;
    }
    _findItemsInState(name, filters) {
        let results = [];
        const state = this._getState(name);
        try {
            state.value.forEach((item) => {
                let isMatch = false;
                filters.forEach((filter) => {
                    smLogger(`filter, finding state value for ${state.name} with filter and item`);
                    smLoggerDetail(filter);
                    smLoggerDetail(filter);
                    if (!isMatch) { // don't bother with other filters if we have already failed
                        let attributeValue = item[filter.attributeName];
                        smLoggerDetail(`filter, finding state value for ${state.name} with attribute value ${attributeValue}`);
                        if (filter.evaluator) {
                            isMatch = filter.evaluator(item, filter);
                            smLoggerDetail(`filter (evaluator), with attribute ${attributeValue}`);
                        }
                        else {
                            switch (filter.comparison) {
                                case _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ComparisonType.isNull: {
                                    smLoggerDetail(`filter (is Null), with attribute ${attributeValue}`);
                                    isMatch = !(attributeValue);
                                    break;
                                }
                                case _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ComparisonType.isNotNull: {
                                    smLoggerDetail(`filter (is Not Null), with attribute ${attributeValue}`);
                                    if (attributeValue) {
                                        isMatch = true;
                                    }
                                    break;
                                }
                                case _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ComparisonType.equals: {
                                    smLoggerDetail(`filter (===), with attribute ${attributeValue} and filter value ${filter.value}`);
                                    isMatch = ((attributeValue) && (attributeValue === filter.value));
                                    break;
                                }
                                case _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ComparisonType.lessThan: {
                                    smLoggerDetail(`filter (<), with attribute ${attributeValue} and filter value ${filter.value}`);
                                    isMatch = ((attributeValue) && (attributeValue < filter.value));
                                    break;
                                }
                                case _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ComparisonType.greaterThan: {
                                    smLoggerDetail(`filter (>), with attribute ${attributeValue} and filter value ${filter.value}`);
                                    isMatch = ((attributeValue) && (attributeValue > filter.value));
                                    break;
                                }
                                case _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ComparisonType.lessThanEqual: {
                                    smLoggerDetail(`filter (<=), with attribute ${attributeValue} and filter value ${filter.value}`);
                                    isMatch = ((attributeValue) && (attributeValue <= filter.value));
                                    break;
                                }
                                case _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ComparisonType.greaterThanEqual: {
                                    smLoggerDetail(`filter (>=), with attribute ${attributeValue} and filter value ${filter.value}`);
                                    isMatch = ((attributeValue) && (attributeValue >= filter.value));
                                    break;
                                }
                            }
                        }
                    }
                });
                smLoggerDetail(`filter, finding state value for ${state.name} is match? ${isMatch}`);
                if (isMatch)
                    results.push(item);
            });
        }
        catch (err) {
            smLogger(`filter, state value for ${state.name} is not any array`);
        }
        smLoggerDetail('Match results');
        smLoggerDetail(results);
        return results;
    }
    addStateByName(name, stateObjForName) {
        this._ensureStatePresent(name);
        /* create a new state attribute for the application state */
        const state = {
            name,
            value: stateObjForName,
            hasBeenSet: true
        };
        /* get the current state value and replace it */
        this._replaceNamedStateInStorage(state);
        this.informChangeListenersForStateWithName(name, stateObjForName, _interface_StateManager__WEBPACK_IMPORTED_MODULE_1__.StateEventType.StateChanged);
        return stateObjForName;
    }
    getStateByName(name) {
        this._ensureStatePresent(name);
        smLogger(`State Manager: Getting state for ${name}`);
        let stateValueObj = {};
        // get the current state
        const state = this._getState(name);
        stateValueObj = state.value;
        smLogger(`State Manager: Found previous state for ${name}`);
        smLogger(stateValueObj);
        return stateValueObj;
    }
    setStateByName(name, stateObjectForName, informListeners = true) {
        this._ensureStatePresent(name);
        smLogger(`State Manager: Setting state for ${name}`);
        smLogger(stateObjectForName);
        // set the current state
        const state = this._getState(name);
        state.value = stateObjectForName;
        state.hasBeenSet = true;
        if (this.forceSaves)
            this._saveState(name, stateObjectForName);
        if (informListeners)
            this.informChangeListenersForStateWithName(name, stateObjectForName);
        return stateObjectForName;
    }
    addNewItemToState(name, item, isPersisted = false) {
        this._ensureStatePresent(name);
        smLogger(`State Manager: Adding item to state ${name}`);
        // const state = this.getStateByName(name);
        // state.push(item);
        // smLogger(state);
        this._addItemToState(name, item, isPersisted);
        this.informChangeListenersForStateWithName(name, item, _interface_StateManager__WEBPACK_IMPORTED_MODULE_1__.StateEventType.ItemAdded);
    }
    findItemInState(name, item) {
        this._ensureStatePresent(name);
        return this._findItemInState(name, item);
    }
    isItemInState(name, item) {
        this._ensureStatePresent(name);
        let result = false;
        const state = this.getStateByName(name);
        const foundIndex = state.findIndex((element) => this.getEqualityFnForName(name)(element, item));
        if (foundIndex >= 0) {
            result = true;
        }
        return result;
    }
    removeItemFromState(name, item, isPersisted) {
        this._ensureStatePresent(name);
        let result = true;
        let oldItem = this.findItemInState(name, item);
        // remove the item from the state
        smLogger(`State Manager: Found item - removing, is persisted ${isPersisted}`);
        this._removeItemFromState(name, item, isPersisted);
        this.informChangeListenersForStateWithName(name, oldItem, _interface_StateManager__WEBPACK_IMPORTED_MODULE_1__.StateEventType.ItemDeleted);
        return result;
    }
    updateItemInState(name, item, isPersisted) {
        this._ensureStatePresent(name);
        let result = true;
        let oldItem = this.findItemInState(name, item);
        smLogger('State Manager: Found item - replacing ');
        this._updateItemInState(name, item, isPersisted);
        this.informChangeListenersForStateWithName(name, item, _interface_StateManager__WEBPACK_IMPORTED_MODULE_1__.StateEventType.ItemUpdated, oldItem);
        return result;
    }
    findItemsInState(name, filters) {
        this._ensureStatePresent(name);
        return this._findItemsInState(name, filters);
    }
    getType() {
        return _interface_StateManager__WEBPACK_IMPORTED_MODULE_1__.StateManagerType.Local;
    }
    getEqualityFnForName(name) {
        let result = this.defaultEquality;
        if (this.equalityFns) {
            const foundIndex = this.equalityFns.findIndex((fn) => fn.name === name);
            if (foundIndex >= 0)
                result = this.equalityFns[foundIndex].equality;
        }
        return result;
    }
    fireStateChanged(name) {
        if (this.isEmittingEvents()) {
            this._ensureStatePresent(name);
            const state = this.getStateByName(name);
            if (state) {
                this.delegate.informChangeListenersForStateWithName(name, state.value, _interface_StateManager__WEBPACK_IMPORTED_MODULE_1__.StateEventType.StateChanged, null);
            }
        }
    }
    isEmittingEvents() {
        return this.delegate.isEmittingEvents();
    }
}
//# sourceMappingURL=AbstractStateManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/state/implementation/AggregateStateManager.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/state/implementation/AggregateStateManager.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AggregateStateManager": () => (/* binding */ AggregateStateManager)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _AbstractStateManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbstractStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/AbstractStateManager.js");


const aggLogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('state-manager-aggregate');
class AggregateStateManager extends _AbstractStateManager__WEBPACK_IMPORTED_MODULE_1__.AbstractStateManager {
    constructor(defaultEq, equalityFns = null) {
        super('aggregate', defaultEq, equalityFns);
        this.stateManagers = [];
        this.emitEvents();
    }
    getAvailableStateNames() {
        let result = [];
        if (this.stateManagers.length > 0) {
            const manager = this.stateManagers[0].manager;
            result = manager.getAvailableStateNames();
        }
        return result;
    }
    fireStateChangedForAllStates() {
        if (this.stateManagers.length > 0) {
            const manager = this.stateManagers[0].manager;
            const stateNames = this.getAvailableStateNames();
            stateNames.forEach((name) => {
                const state = manager._getState(name);
                this.informChangeListenersForStateWithName(name, state.value);
            });
        }
    }
    addStateManager(stateManager, filters = [], emitEvents) {
        let mWF = {
            manager: stateManager,
            filters: filters
        };
        this.stateManagers.push(mWF);
        if (!emitEvents)
            stateManager.suppressEvents();
        aggLogger('adding state manager with/without filters');
    }
    _addNewNamedStateToStorage(state) {
        this.stateManagers.forEach((managerWithFilters) => {
            if (!this.stateNameInFilters(state.name, managerWithFilters.filters)) {
                managerWithFilters.manager._addNewNamedStateToStorage(state);
            }
        });
    }
    _getState(name) {
        let state = {
            name: name,
            value: [],
            hasBeenSet: false
        };
        this.stateManagers.forEach((sm) => {
            if (!this.stateNameInFilters(state.name, sm.filters)) {
                aggLogger(`get state from state manager for state ${name}`);
                aggLogger(sm.manager);
                sm.manager._getState(name);
            }
        });
        // assuming the state manager is holding all the values
        if (this.stateManagers.length > 0) {
            state = this.stateManagers[0].manager._getState(name);
        }
        return state;
    }
    _ensureStatePresent(name) {
        this.stateManagers.forEach((managerWithFilters) => {
            if (!this.stateNameInFilters(name, managerWithFilters.filters)) {
                managerWithFilters.manager._ensureStatePresent(name);
            }
        });
    }
    _replaceNamedStateInStorage(state) {
        this.stateManagers.forEach((managerWithFilters) => {
            if (!this.stateNameInFilters(state.name, managerWithFilters.filters)) {
                managerWithFilters.manager._replaceNamedStateInStorage(state);
            }
        });
    }
    _saveState(name, stateObj) {
        this.stateManagers.forEach((managerWithFilters) => {
            if (!this.stateNameInFilters(name, managerWithFilters.filters)) {
                aggLogger(`saving state in state manager for state ${name}`);
                aggLogger(managerWithFilters.manager);
                aggLogger(stateObj);
                managerWithFilters.manager._saveState(name, stateObj);
            }
        });
    }
    _addItemToState(name, stateObj, isPersisted = false) {
        this.stateManagers.forEach((managerWithFilters) => {
            if (!this.stateNameInFilters(name, managerWithFilters.filters)) {
                aggLogger(`adding item to state in  state manager for state ${name}, is persisted = ${isPersisted}`);
                aggLogger(managerWithFilters.manager);
                aggLogger(stateObj);
                managerWithFilters.manager._addItemToState(name, stateObj, isPersisted);
            }
        });
    }
    _removeItemFromState(name, stateObj, isPersisted) {
        this.stateManagers.forEach((managerWithFilters) => {
            if (!this.stateNameInFilters(name, managerWithFilters.filters)) {
                aggLogger(`removing item from state in state manager for state ${name}, is persisted = ${isPersisted}`);
                aggLogger(managerWithFilters.manager);
                aggLogger(stateObj);
                managerWithFilters.manager._removeItemFromState(name, stateObj, isPersisted);
            }
        });
    }
    _updateItemInState(name, stateObj, isPersisted) {
        this.stateManagers.forEach((managerWithFilters) => {
            if (!this.stateNameInFilters(name, managerWithFilters.filters)) {
                aggLogger(`updating item in state in  state manager for state ${name}`);
                aggLogger(managerWithFilters.manager);
                aggLogger(stateObj);
                managerWithFilters.manager._updateItemInState(name, stateObj, isPersisted);
            }
        });
    }
    _findItemsInState(name, filters) {
        // let state: StateValue = {
        //     name: name,
        //     value: []
        // }
        this.stateManagers.forEach((sm) => {
            if (!this.stateNameInFilters(name, sm.filters)) {
                aggLogger(`get state from state manager for state ${name}`);
                aggLogger(sm.manager);
                sm.manager._findItemsInState(name, filters);
            }
        });
        // assuming the state manager is holding all the values
        let results = [];
        if (this.stateManagers.length > 0) {
            results = this.stateManagers[0].manager._findItemsInState(name, filters);
        }
        return results;
    }
    _findItemInState(name, item) {
        let result = {};
        this.stateManagers.forEach((sm) => {
            if (!this.stateNameInFilters(name, sm.filters)) {
                aggLogger(`finding item from state manager for state ${name}`);
                aggLogger(sm.manager);
                sm.manager._findItemInState(name, item);
            }
        });
        // assuming the state manager is holding all the values
        if (this.stateManagers.length > 0) {
            result = this.stateManagers[0].manager._findItemInState(name, item);
        }
        return result;
    }
    stateNameInFilters(name, filters) {
        let foundIndex = filters.findIndex((filter) => filter === name);
        return (foundIndex >= 0);
    }
}
//# sourceMappingURL=AggregateStateManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/state/implementation/BrowserStorageStateManager.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/state/implementation/BrowserStorageStateManager.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BrowserStorageStateManager": () => (/* binding */ BrowserStorageStateManager)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _AbstractStateManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbstractStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/AbstractStateManager.js");


const lsLogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('browser-storage');
class BrowserStorageStateManager extends _AbstractStateManager__WEBPACK_IMPORTED_MODULE_1__.AbstractStateManager {
    constructor(useLocalStorage = false, allowPersistence = false, defaultEq, equalFns = null) {
        super('browser', defaultEq, equalFns);
        // @ts-ignore
        this.configuration = [];
        this.initialised = false;
        this.storage = window.sessionStorage;
        this.allowPersistence = allowPersistence;
        if (useLocalStorage)
            this.storage = window.localStorage;
        this.forceSaves = true;
    }
    isInitialised() {
        return this.initialised;
    }
    setInitialised() {
        this.initialised = true;
    }
    setCompletedRun(stateName) {
    }
    _ensureStatePresent(name) {
        if (this.storage.getItem(name) === null) {
            this._addNewNamedStateToStorage({ name: name, value: [], hasBeenSet: false });
        }
    }
    _addNewNamedStateToStorage(state) {
        lsLogger(`Local Storage: Saving with key ${state.name}`);
        lsLogger(state);
        const stringifiedSaveData = JSON.stringify(state.value);
        lsLogger(stringifiedSaveData);
        this.storage.setItem(state.name, stringifiedSaveData);
    }
    _replaceNamedStateInStorage(state) {
        this._addNewNamedStateToStorage(state);
    }
    _getState(name) {
        let state = {
            name: name,
            value: [],
            hasBeenSet: false
        };
        lsLogger(`Local Storage: Loading with key ${name}`);
        const savedResultsJSON = this.storage.getItem(name);
        lsLogger(savedResultsJSON);
        if (savedResultsJSON !== null) {
            state.value = JSON.parse(savedResultsJSON);
            state.hasBeenSet = true;
        }
        return state;
    }
    _saveState(name, newValue) {
        this._addNewNamedStateToStorage({ name: name, value: newValue, hasBeenSet: true });
    }
    _addItemToState(name, stateObj, isPersisted = false) {
        if (!isPersisted) {
            if (!this.allowPersistence) {
                return;
            }
        }
        let state = this._getState(name);
        lsLogger(`adding item to state ${name}`);
        lsLogger(stateObj);
        const valueIndex = state.value.findIndex((element) => this.getEqualityFnForName(name)(element, stateObj));
        if (valueIndex >= 0) {
            state.value.splice(valueIndex, 1, stateObj);
            lsLogger(`item was already in state, updating instead ${name}`);
        }
        else {
            state.value.push(stateObj);
        }
        this._replaceNamedStateInStorage(state);
    }
    _removeItemFromState(name, stateObj, isPersisted) {
        let state = this._getState(name);
        const valueIndex = state.value.findIndex((element) => this.getEqualityFnForName(name)(element, stateObj));
        if (valueIndex >= 0) {
            lsLogger(`removing item from state ${name}`);
            lsLogger(stateObj);
            state.value.splice(valueIndex, 1);
        }
        this._replaceNamedStateInStorage(state);
    }
    _updateItemInState(name, stateObj, isPersisted) {
        let state = this._getState(name);
        const valueIndex = state.value.findIndex((element) => this.getEqualityFnForName(name)(element, stateObj));
        if (valueIndex >= 0) {
            state.value.splice(valueIndex, 1, stateObj);
            lsLogger(`updating item in state ${name}`);
            lsLogger(stateObj);
        }
        this._replaceNamedStateInStorage(state);
    }
    forceResetForGet(stateName) {
    }
    getConfiguredStateNames() {
        return this.configuration;
    }
    hasCompletedRun(stateName) {
        return false;
    }
    initialise(config) {
        this.configuration = config;
        this.initialised = true;
    }
    fireStateChangedForAllStates() {
        if (this.isEmittingEvents()) {
            const stateNames = this.getConfiguredStateNames();
            stateNames.forEach((name) => {
                const state = this._getState(name);
                this.informChangeListenersForStateWithName(name, state.value);
            });
        }
    }
    getAvailableStateNames() {
        return this.getConfiguredStateNames();
    }
}
//# sourceMappingURL=BrowserStorageStateManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/state/implementation/EncryptedBrowserStorageStateManager.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/state/implementation/EncryptedBrowserStorageStateManager.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EncryptedBrowserStorageStateManager": () => (/* binding */ EncryptedBrowserStorageStateManager)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BrowserStorageStateManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BrowserStorageStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/BrowserStorageStateManager.js");
/* harmony import */ var _security_SecurityManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../security/SecurityManager */ "./node_modules/ui-framework-jps/dist/framework/security/SecurityManager.js");



const lsLogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('browser-storage-encrypted');
class EncryptedBrowserStorageStateManager extends _BrowserStorageStateManager__WEBPACK_IMPORTED_MODULE_1__.BrowserStorageStateManager {
    constructor(useLocalStorage = false, defaultEq, equalFns = null) {
        super(useLocalStorage, true, defaultEq, equalFns);
        this._addNewNamedStateToStorage = this._addNewNamedStateToStorage.bind(this);
    }
    _addNewNamedStateToStorage(state) {
        lsLogger(`Saving with key ${state.name}`);
        lsLogger(state);
        const stringifiedSaveData = _security_SecurityManager__WEBPACK_IMPORTED_MODULE_2__.SecurityManager.getInstance().encryptObject(state.value);
        lsLogger(stringifiedSaveData);
        const userStateName = _security_SecurityManager__WEBPACK_IMPORTED_MODULE_2__.SecurityManager.getInstance().getLoggedInUsername().trim() + '.' + state.name;
        this.storage.setItem(userStateName, stringifiedSaveData);
    }
    _getState(name) {
        let state = {
            name: name,
            value: [],
            hasBeenSet: false
        };
        lsLogger(`Loading with key ${name}`);
        const userStateName = _security_SecurityManager__WEBPACK_IMPORTED_MODULE_2__.SecurityManager.getInstance().getLoggedInUsername().trim() + '.' + name;
        const savedResultsJSON = this.storage.getItem(userStateName);
        if (savedResultsJSON !== null) {
            state.value = _security_SecurityManager__WEBPACK_IMPORTED_MODULE_2__.SecurityManager.getInstance().decryptObject(savedResultsJSON);
            state.hasBeenSet = true;
            lsLogger(`Loading with key ${name} decrypted to `);
            lsLogger(state.value);
        }
        return state;
    }
}
//# sourceMappingURL=EncryptedBrowserStorageStateManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/state/implementation/EncryptedIndexedDBStateManager.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/state/implementation/EncryptedIndexedDBStateManager.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EncryptedIndexedDBStateManager": () => (/* binding */ EncryptedIndexedDBStateManager)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! idb */ "./node_modules/idb/build/esm/index.js");
/* harmony import */ var _IndexedDBStateManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IndexedDBStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/IndexedDBStateManager.js");
/* harmony import */ var _security_SecurityManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../security/SecurityManager */ "./node_modules/ui-framework-jps/dist/framework/security/SecurityManager.js");
/* harmony import */ var _interface_StateManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../interface/StateManager */ "./node_modules/ui-framework-jps/dist/framework/state/interface/StateManager.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('indexeddb-ts-encrypted');
class EncryptedIndexedDBStateManager extends _IndexedDBStateManager__WEBPACK_IMPORTED_MODULE_2__.IndexedDBStateManager {
    constructor() {
        super();
        this.initialise = this.initialise.bind(this);
    }
    initialise(dbName, collections) {
        const _super = Object.create(null, {
            initialise: { get: () => super.initialise }
        });
        return __awaiter(this, void 0, void 0, function* () {
            logger(`opening encrypted database for ${dbName} with collections`);
            const username = _security_SecurityManager__WEBPACK_IMPORTED_MODULE_3__.SecurityManager.getInstance().getLoggedInUsername();
            this.dbName = `${username}.${dbName}`;
            _super.initialise.call(this, this.dbName, collections);
        });
    }
    /* add a new item to the local storage if not already there */
    addNewItemToCollection(key, item, keyField = 'id') {
        const _super = Object.create(null, {
            addNewItemToCollection: { get: () => super.addNewItemToCollection }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (item !== null) {
                let encrypted = {};
                // @ts-ignore
                encrypted[keyField] = item[keyField];
                // @ts-ignore
                encrypted.data = _security_SecurityManager__WEBPACK_IMPORTED_MODULE_3__.SecurityManager.getInstance().encryptObject(item);
                logger(encrypted);
                _super.addNewItemToCollection.call(this, key, encrypted, keyField);
            }
        });
    }
    updateItemInCollection(key, item, keyField = 'id') {
        const _super = Object.create(null, {
            updateItemInCollection: { get: () => super.updateItemInCollection }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (item) {
                let encrypted = {};
                // @ts-ignore
                encrypted[keyField] = item[keyField];
                // @ts-ignore
                encrypted.data = _security_SecurityManager__WEBPACK_IMPORTED_MODULE_3__.SecurityManager.getInstance().encryptObject(item);
                logger(encrypted);
                _super.updateItemInCollection.call(this, key, encrypted, keyField);
            }
        });
    }
    getWithCollectionKey(key, keyField = 'id') {
        return __awaiter(this, void 0, void 0, function* () {
            let savedResults = [];
            logger(`Loading with key ${key}`);
            let db = yield (0,idb__WEBPACK_IMPORTED_MODULE_1__.openDB)(this.dbName, 1);
            yield this.checkForObjectStore(db, key, keyField);
            // @ts-ignore
            let transaction = db.transaction([key]);
            // @ts-ignore
            let objectStore = transaction.store;
            // @ts-ignore
            let cursor = yield objectStore.openCursor();
            while (cursor) {
                let item = _security_SecurityManager__WEBPACK_IMPORTED_MODULE_3__.SecurityManager.getInstance().decryptObject(cursor.value.data);
                logger(item);
                // @ts-ignore
                savedResults.push(item);
                // @ts-ignore
                cursor = yield cursor.continue();
            }
            logger(savedResults);
            this.callbackForGetItems(savedResults, key);
        });
    }
    callbackForAddItem(data, associatedStateName) {
        return __awaiter(this, void 0, void 0, function* () {
            logger(`callback for add encrypted item for state ${associatedStateName}  - FORWARDING`);
            let decryptedItem = _security_SecurityManager__WEBPACK_IMPORTED_MODULE_3__.SecurityManager.getInstance().decryptObject(data.data);
            logger(decryptedItem);
            this.delegate.informChangeListenersForStateWithName(associatedStateName, decryptedItem, _interface_StateManager__WEBPACK_IMPORTED_MODULE_4__.StateEventType.ItemAdded, null);
        });
    }
}
//# sourceMappingURL=EncryptedIndexedDBStateManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/state/implementation/GraphQLApiStateManager.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/state/implementation/GraphQLApiStateManager.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GraphQLApiStateManager": () => (/* binding */ GraphQLApiStateManager)
/* harmony export */ });
/* harmony import */ var _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interface/StateManager */ "./node_modules/ui-framework-jps/dist/framework/state/interface/StateManager.js");
/* harmony import */ var _network_Types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../network/Types */ "./node_modules/ui-framework-jps/dist/framework/network/Types.js");
/* harmony import */ var _network_DownloadManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../network/DownloadManager */ "./node_modules/ui-framework-jps/dist/framework/network/DownloadManager.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _network_CallbackRegistry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../network/CallbackRegistry */ "./node_modules/ui-framework-jps/dist/framework/network/CallbackRegistry.js");
/* harmony import */ var _AbstractAsynchronousStateManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AbstractAsynchronousStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/AbstractAsynchronousStateManager.js");






/*
*
*   WORK IN PROGRESS
*
 */
const logger = debug__WEBPACK_IMPORTED_MODULE_3___default()('state-manager-graphql');
class GraphQLApiStateManager extends _AbstractAsynchronousStateManager__WEBPACK_IMPORTED_MODULE_5__.AbstractAsynchronousStateManager {
    constructor(id) {
        super(id, 'graphql');
        this.configuration = [];
        this.callbackForAddItem = this.callbackForAddItem.bind(this);
        this.callbackForRemoveItem = this.callbackForRemoveItem.bind(this);
        this.callbackForUpdateItem = this.callbackForUpdateItem.bind(this);
        this.callbackForGetItems = this.callbackForGetItems.bind(this);
        this.callbackForFindItem = this.callbackForFindItem.bind(this);
        // function ids
        this.functionIdAddItem = GraphQLApiStateManager.FUNCTION_ID_ADD_ITEM + id;
        this.functionIdRemoveItem = GraphQLApiStateManager.FUNCTION_ID_REMOVE_ITEM + id;
        this.functionIdUpdateItem = GraphQLApiStateManager.FUNCTION_ID_UPDATE_ITEM + id;
        this.functionIdGetItems = GraphQLApiStateManager.FUNCTION_ID_GET_ITEMS + id;
        this.functionIdFindItem = GraphQLApiStateManager.FUNCTION_ID_FIND_ITEM + id;
        _network_CallbackRegistry__WEBPACK_IMPORTED_MODULE_4__.CallbackRegistry.getInstance().addRegisterCallback(this.functionIdAddItem, this.callbackForAddItem);
        _network_CallbackRegistry__WEBPACK_IMPORTED_MODULE_4__.CallbackRegistry.getInstance().addRegisterCallback(this.functionIdRemoveItem, this.callbackForRemoveItem);
        _network_CallbackRegistry__WEBPACK_IMPORTED_MODULE_4__.CallbackRegistry.getInstance().addRegisterCallback(this.functionIdUpdateItem, this.callbackForUpdateItem);
        _network_CallbackRegistry__WEBPACK_IMPORTED_MODULE_4__.CallbackRegistry.getInstance().addRegisterCallback(this.functionIdGetItems, this.callbackForGetItems);
        _network_CallbackRegistry__WEBPACK_IMPORTED_MODULE_4__.CallbackRegistry.getInstance().addRegisterCallback(this.functionIdFindItem, this.callbackForFindItem);
    }
    static getInstance() {
        if (!(GraphQLApiStateManager._instance)) {
            GraphQLApiStateManager._instance = new GraphQLApiStateManager("1");
        }
        return GraphQLApiStateManager._instance;
    }
    initialise(configs) {
        configs.forEach((config) => {
            this.addConfig(config);
        });
        this.initialised = true;
    }
    addConfig(config) {
        this.configuration.push(config);
        this.addStateNameToConfigurations(config.stateName);
        this.initialised = true;
    }
    _addNewNamedStateToStorage(state) {
    }
    _getState(name) {
        logger(`Getting All ${name}`);
        if (this.hasCompletedRun(name)) {
            logger(`Getting All ${name} - not done - previously retrieved`);
        }
        else {
            if (!this.isRunInProgress(name)) {
                this.setRunInProgress(name);
                let config = this.getConfigurationForStateName(name);
                if (config.isActive && (config.apis.findAll.trim().length > 0)) {
                    let query = config.apis.findAll;
                    const jsonRequest = {
                        url: config.serverURL + config.apiURL,
                        type: _network_Types__WEBPACK_IMPORTED_MODULE_1__.RequestType.POST,
                        params: { query },
                        callbackId: this.functionIdGetItems,
                        associatedStateName: name
                    };
                    logger(`Getting All ${name} with query "${query}"`);
                    if (this.contextDelegate) {
                        jsonRequest.context = this.contextDelegate.getContextForApi();
                    }
                    _network_DownloadManager__WEBPACK_IMPORTED_MODULE_2__.DownloadManager.getInstance().addApiRequest(jsonRequest, true);
                }
                else {
                    logger(`No configuration for state ${name}`);
                }
            }
        }
        let state = { name: name, value: [], hasBeenSet: false };
        return state;
    }
    _ensureStatePresent(name) {
    }
    _replaceNamedStateInStorage(state) {
    }
    _saveState(name, stateObj) {
    }
    _addItemToState(name, stateObj, isPersisted = false) {
        if (isPersisted)
            return; // dont add complete objects to the state - they are already processed
        logger(`Adding item to ${name}`);
        logger(stateObj);
        let config = this.getConfigurationForStateName(name);
        if (config.isActive && (config.apis.create.trim().length > 0)) {
            let variables = {
                data: stateObj
            };
            // do we have context?
            if (this.contextDelegate) {
                // @ts-ignore
                variables.context = this.contextDelegate.getContextForApi();
            }
            _network_DownloadManager__WEBPACK_IMPORTED_MODULE_2__.DownloadManager.getInstance().addQLApiRequest(config.serverURL + config.apiURL, config.apis.create, variables, this.functionIdAddItem, name, false);
        }
        else {
            logger(`No configuration for state ${name}`);
        }
    }
    _findItemInState(name, stateObj) {
        logger(`Finding item in ${name}`);
        logger(stateObj);
        let config = this.getConfigurationForStateName(name);
        if (config.isActive && (config.apis.find.trim().length > 0)) {
            let identifier = stateObj.id;
            if (config.idField) {
                identifier = stateObj[config.idField];
            }
            let variables = {
                identifier: identifier
            };
            // do we have context?
            if (this.contextDelegate) {
                // @ts-ignore
                variables.context = this.contextDelegate.getContextForApi();
            }
            _network_DownloadManager__WEBPACK_IMPORTED_MODULE_2__.DownloadManager.getInstance().addQLApiRequest(config.serverURL + config.apiURL, config.apis.find, variables, this.functionIdFindItem, name, true);
        }
        else {
            logger(`No configuration for state ${name}`);
        }
    }
    _removeItemFromState(name, stateObj, isPersisted) {
        if (isPersisted)
            return; // dont remove complete objects to the state - they are already processed
        logger(`Removing item to ${name}`);
        logger(stateObj);
        let config = this.getConfigurationForStateName(name);
        if (config.isActive && (config.apis.destroy.trim().length > 0)) {
            let identifier = stateObj.id;
            if (config.idField) {
                identifier = stateObj[config.idField];
            }
            let variables = {
                identifier: identifier
            };
            // do we have context?
            if (this.contextDelegate) {
                // @ts-ignore
                variables.context = this.contextDelegate.getContextForApi();
            }
            _network_DownloadManager__WEBPACK_IMPORTED_MODULE_2__.DownloadManager.getInstance().addQLApiRequest(config.serverURL + config.apiURL, config.apis.destroy, variables, this.functionIdRemoveItem, name, false);
        }
        else {
            logger(`No configuration for state ${name}`);
        }
    }
    _updateItemInState(name, stateObj, isPersisted) {
        if (isPersisted)
            return; // dont update complete objects to the state - they are already processed
        logger(`Updating item in ${name}`);
        logger(stateObj);
        let config = this.getConfigurationForStateName(name);
        if (config.isActive && (config.apis.update.trim().length > 0)) {
            let variables = {
                data: stateObj
            };
            // do we have context?
            if (this.contextDelegate) {
                // @ts-ignore
                variables.context = this.contextDelegate.getContextForApi();
            }
            _network_DownloadManager__WEBPACK_IMPORTED_MODULE_2__.DownloadManager.getInstance().addQLApiRequest(config.serverURL + config.apiURL, config.apis.update, variables, this.functionIdUpdateItem, name, false);
        }
        else {
            logger(`No configuration for state ${name}`);
        }
    }
    _findItemsInState(name, filters) {
        return [];
    }
    getConfigurationForStateName(name) {
        let config = {
            stateName: name,
            serverURL: '',
            apiURL: '/graphql',
            apis: {
                findAll: '',
                create: '',
                destroy: '',
                update: '',
                find: ''
            },
            data: {
                findAll: '',
                create: '',
                destroy: '',
                update: '',
                find: ''
            },
            isActive: false
        };
        let foundIndex = this.configuration.findIndex((config) => config.stateName === name);
        if (foundIndex >= 0) {
            config = this.configuration[foundIndex];
        }
        return config;
    }
    callbackForRemoveItem(data, status, associatedStateName) {
        logger(`callback for remove item for state ${associatedStateName} with status ${status} - not forwarded`);
        if (status >= 200 && status <= 299) { // do we have any data?
        }
        logger(data);
    }
    callbackForUpdateItem(data, status, associatedStateName) {
        logger(`callback for update item for state ${associatedStateName} with status ${status} - not forwarded`);
        if (status >= 200 && status <= 299) { // do we have any data?
        }
        logger(data);
    }
    callbackForGetItems(data, status, associatedStateName) {
        logger(`callback for get items for state ${associatedStateName} with status ${status} - FORWARDING`);
        if (status >= 200 && status <= 299) { // do we have any data?
            logger(data);
            let config = this.getConfigurationForStateName(associatedStateName);
            let dataAttribute = config.data.findAll;
            this.setCompletedRun(associatedStateName, data.data[dataAttribute]);
            this.clearRunInProgress(associatedStateName);
            this.delegate.informChangeListenersForStateWithName(associatedStateName, data.data[dataAttribute], _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.StateChanged, null);
        }
    }
    callbackForAddItem(data, status, associatedStateName, wasOffline) {
        logger(`callback for add item for state ${associatedStateName} with status ${status} - FORWARDING`);
        let config = this.getConfigurationForStateName(associatedStateName);
        let dataAttribute = config.data.create;
        if (status >= 200 && status <= 299) { // do we have any data?
            logger(data);
            if (!wasOffline) {
                this.delegate.informChangeListenersForStateWithName(associatedStateName, data.data[dataAttribute], _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.ItemAdded, null);
            }
            else {
                logger('Item was added offline, update the current data');
                this.delegate.informChangeListenersForStateWithName(associatedStateName, data.data[dataAttribute], _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.ItemUpdated, null);
            }
        }
        // did the call fail? (server loss)
        if (status === 500) {
            logger(`Item adding - offline, but will be queued later`);
            this.delegate.informChangeListenersForStateWithName(associatedStateName, data.data[dataAttribute], _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.ItemAdded, null);
        }
    }
    callbackForFindItem(data, status, associatedStateName) {
        logger(`callback for find item for state ${associatedStateName} with status ${status} - FORWARDING`);
        if (status >= 200 && status <= 299) { // do we have any data?
            logger(data);
            this.delegate.informChangeListenersForStateWithName(associatedStateName, data, _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.FindItem, null);
        }
    }
}
GraphQLApiStateManager.FUNCTION_ID_ADD_ITEM = 'graphql.api.state.manager.add.item.';
GraphQLApiStateManager.FUNCTION_ID_REMOVE_ITEM = 'graphql.api.state.manager.remove.item.';
GraphQLApiStateManager.FUNCTION_ID_UPDATE_ITEM = 'graphql.api.state.manager.update.item.';
GraphQLApiStateManager.FUNCTION_ID_GET_ITEMS = 'graphql.api.state.manager.get.items.';
GraphQLApiStateManager.FUNCTION_ID_FIND_ITEM = 'graphql.api.state.manager.find.item.';
//# sourceMappingURL=GraphQLApiStateManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/state/implementation/IndexedDBStateManager.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/state/implementation/IndexedDBStateManager.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IndexedDBStateManager": () => (/* binding */ IndexedDBStateManager)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! idb */ "./node_modules/idb/build/esm/index.js");
/* harmony import */ var _interface_StateManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../interface/StateManager */ "./node_modules/ui-framework-jps/dist/framework/state/interface/StateManager.js");
/* harmony import */ var _AbstractAsynchronousStateManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AbstractAsynchronousStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/AbstractAsynchronousStateManager.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('indexeddb-ts');
const loggerInit = debug__WEBPACK_IMPORTED_MODULE_0___default()('indexeddb-ts:init');
class IndexedDBStateManager extends _AbstractAsynchronousStateManager__WEBPACK_IMPORTED_MODULE_3__.AbstractAsynchronousStateManager {
    constructor() {
        super('indexeddb', 'indexeddb');
        this.dbName = 'default';
        this.collections = [];
        this.callbackForAddItem = this.callbackForAddItem.bind(this);
        this.callbackForRemoveItem = this.callbackForRemoveItem.bind(this);
        this.callbackForUpdateItem = this.callbackForUpdateItem.bind(this);
        this.callbackForGetItems = this.callbackForGetItems.bind(this);
        this.setStateByName = this.setStateByName.bind(this);
        this.getType = this.getType.bind(this);
    }
    static getInstance() {
        if (!IndexedDBStateManager.instance) {
            IndexedDBStateManager.instance = new IndexedDBStateManager();
        }
        return IndexedDBStateManager.instance;
    }
    openDatabase(dbName, collections) {
        return __awaiter(this, void 0, void 0, function* () {
            let result = true;
            try {
                let db = yield (0,idb__WEBPACK_IMPORTED_MODULE_1__.openDB)(this.dbName);
                let currentVersion = db.version;
                // do we have any new collections?
                let collectionsToCreate = [];
                collections.forEach((collection) => {
                    loggerInit(`checking for collection ${collection.name} with key ${collection.keyField} with database version ${currentVersion}`);
                    if (!db.objectStoreNames.contains(collection.name)) {
                        loggerInit(`collection ${collection.name} not present in database version ${currentVersion}`);
                        collectionsToCreate.push(collection);
                    }
                });
                db.close();
                if (collectionsToCreate.length > 0) {
                    currentVersion++;
                }
                yield (0,idb__WEBPACK_IMPORTED_MODULE_1__.openDB)(dbName, currentVersion, {
                    upgrade(db, oldVersion, newVersion, transaction) {
                        collectionsToCreate.forEach((collection) => {
                            loggerInit(`creating collection for ${collection.name} with key ${collection.keyField} in database version ${currentVersion}`);
                            db.createObjectStore(collection.name, { keyPath: collection.keyField, autoIncrement: false });
                        });
                    },
                    blocked() {
                        // …
                    },
                    blocking() {
                        // …
                    },
                    terminated() {
                        // …
                    },
                });
            }
            catch (error) {
                result = false;
                logger(error);
                loggerInit(`Deleting database ${dbName}`);
                yield indexedDB.deleteDatabase(dbName);
                loggerInit(`Re-opening database ${dbName}`);
                return yield this.openDatabase(dbName, collections);
            }
            return result;
        });
    }
    initialise(dbName, collections) {
        return __awaiter(this, void 0, void 0, function* () {
            logger(`opening database for ${dbName} with collections`);
            logger(collections);
            this.dbName = dbName;
            this.collections = collections;
            this.collections.forEach((collection) => {
                this.addStateNameToConfigurations(collection.name);
            });
            const isOpen = yield this.openDatabase(dbName, collections);
            if (!isOpen) {
                logger('Configuration change required, delete the database');
            }
            this.initialised = true;
        });
    }
    _addNewNamedStateToStorage(state) {
    }
    _getState(name) {
        if (this.hasCompletedRun(name)) {
            logger(`Getting All ${name} - not done - previously retrieved`);
        }
        else {
            if (!this.isRunInProgress(name)) {
                this.setRunInProgress(name);
                logger(`getting state ${name}`);
                this.getWithCollectionKey(name, this.getKeyFieldForKey(name));
            }
        }
        let state = { name: name, value: [], hasBeenSet: false };
        return state;
    }
    _ensureStatePresent(name) {
    } // should be present with initialise
    _replaceNamedStateInStorage(state) {
        let fn = () => __awaiter(this, void 0, void 0, function* () {
            logger(`replacing item in storage ${state.name}`);
            logger(state.value);
            yield this.removeAllItemsFromCollectionKey(state.name, this.getKeyFieldForKey(state.name));
            yield this.saveWithCollectionKey(state.name, state.value, this.getKeyFieldForKey(state.name));
        });
        fn();
    }
    _addItemToState(name, stateObj, isPersisted = false) {
        if (isPersisted)
            return;
        this.addNewItemToCollection(name, stateObj, this.getKeyFieldForKey(name));
    }
    _removeItemFromState(name, stateObj, isPersisted) {
        if (isPersisted)
            return;
        this.removeItemFromCollection(name, stateObj, this.getKeyFieldForKey(name));
    }
    _updateItemInState(name, stateObj, isPersisted) {
        if (isPersisted)
            return;
        this.updateItemInCollection(name, stateObj, this.getKeyFieldForKey(name));
    }
    _saveState(name, stateObj) {
        let fn = () => __awaiter(this, void 0, void 0, function* () {
            logger(`saving state ${name}`);
            yield this.removeAllItemsFromCollectionKey(name, this.getKeyFieldForKey(name));
            yield this.saveWithCollectionKey(name, stateObj, this.getKeyFieldForKey(name));
        });
        fn();
    }
    saveWithCollectionKey(key, saveData, keyField = 'id') {
        return __awaiter(this, void 0, void 0, function* () {
            logger(`Saving array with key ${key}`);
            logger(saveData);
            let db = yield (0,idb__WEBPACK_IMPORTED_MODULE_1__.openDB)(this.dbName);
            // @ts-ignore
            let transaction = db.transaction([key], "readwrite");
            transaction.oncomplete = function (ev) {
                logger('Success');
                logger(ev);
            };
            transaction.onerror = function (ev) {
                logger('Error');
                logger(ev);
            };
            // @ts-ignore
            let objectStore = transaction.store;
            // @ts-ignore
            yield this.saveItemsToCollection(objectStore, saveData, keyField);
        });
    }
    /* add a new item to the local storage if not already there */
    addNewItemToCollection(key, item, keyField = 'id') {
        return __awaiter(this, void 0, void 0, function* () {
            if (item !== null) {
                logger(`Adding with key ${key}`);
                logger(item);
                let db = yield (0,idb__WEBPACK_IMPORTED_MODULE_1__.openDB)(this.dbName);
                // @ts-ignore
                let transaction = db.transaction([key], "readwrite").objectStore(key).add(item);
                transaction.oncomplete = function (ev) {
                    logger('Success');
                    logger(ev);
                };
                transaction.onerror = function (ev) {
                    logger('Error');
                    logger(ev);
                };
                this.callbackForAddItem(item, key);
            }
        });
    }
    removeItemFromCollection(key, item, keyField = 'id') {
        return __awaiter(this, void 0, void 0, function* () {
            if (item !== null) {
                logger(`Removing with key ${key} item ${item[keyField]}`);
                logger(item);
                let db = yield (0,idb__WEBPACK_IMPORTED_MODULE_1__.openDB)(this.dbName);
                // @ts-ignore
                let transaction = db.transaction([key], "readwrite").objectStore(key).delete(item[keyField]);
                transaction.oncomplete = function (ev) {
                    logger('Success');
                    logger(ev);
                };
                transaction.onerror = function (ev) {
                    logger('Error');
                    logger(ev);
                };
                yield transaction.done;
                this.callbackForRemoveItem(item, key);
            }
        });
    }
    updateItemInCollection(key, item, keyField = 'id') {
        return __awaiter(this, void 0, void 0, function* () {
            if (item) {
                logger(`Updating item in storage ${key} with keyField path of ${keyField}`);
                logger(item);
                let db = yield (0,idb__WEBPACK_IMPORTED_MODULE_1__.openDB)(this.dbName);
                // @ts-ignore
                let transaction = db.transaction([key], "readwrite").objectStore(key).put(item);
                transaction.oncomplete = function (ev) {
                    logger('Success');
                    logger(ev);
                };
                transaction.onerror = function (ev) {
                    logger('Error');
                    logger(ev);
                };
                // @ts-ignore
                yield transaction.done;
                this.callbackForUpdateItem(item, key);
            }
        });
    }
    setStateByName(name, stateObjectForName, informListeners) {
        this._replaceNamedStateInStorage({ name: name, value: stateObjectForName, hasBeenSet: true });
        if (informListeners)
            this.delegate.informChangeListenersForStateWithName(name, stateObjectForName, _interface_StateManager__WEBPACK_IMPORTED_MODULE_2__.StateEventType.StateChanged, null);
    }
    getWithCollectionKey(key, keyField = 'id') {
        return __awaiter(this, void 0, void 0, function* () {
            let savedResults = [];
            logger(`Loading with key ${key}`);
            let db = yield (0,idb__WEBPACK_IMPORTED_MODULE_1__.openDB)(this.dbName);
            yield this.checkForObjectStore(db, key, keyField);
            // @ts-ignore
            let transaction = db.transaction([key]);
            // @ts-ignore
            let objectStore = transaction.store;
            // @ts-ignore
            let cursor = yield objectStore.openCursor();
            while (cursor) {
                // @ts-ignore
                savedResults.push(cursor.value);
                // @ts-ignore
                cursor = yield cursor.continue();
            }
            logger(savedResults);
            this.callbackForGetItems(savedResults, key);
        });
    }
    _findItemsInState(name, filters) {
        return [];
    }
    getType() {
        return _interface_StateManager__WEBPACK_IMPORTED_MODULE_2__.StateManagerType.AsyncLocal;
    }
    _findItemInState(name, item) {
    }
    getKeyFieldForKey(key) {
        let result = '_id';
        const foundIndex = this.collections.findIndex((collection) => collection.name === key);
        if (foundIndex >= 0) {
            result = this.collections[foundIndex].keyField;
        }
        return result;
    }
    checkForObjectStore(db, key, keyField) {
        return __awaiter(this, void 0, void 0, function* () {
            logger(`Checking for collection ${key}`);
            if (!db.objectStoreNames.contains(key)) {
                // @ts-ignore
                logger(`Checking for collection ${key} - NOT found, creating`);
                yield db.createObjectStore(key, { keyPath: keyField, autoIncrement: false });
            }
        });
    }
    saveItemsToCollection(objectStore, saveData, keyField = 'id') {
        return __awaiter(this, void 0, void 0, function* () {
            logger(`Saving items to collection`);
            saveData.forEach((data) => {
                // @ts-ignore
                objectStore.add(data);
            });
        });
    }
    removeAllItemsFromCollectionKey(key, keyField = 'id') {
        return __awaiter(this, void 0, void 0, function* () {
            logger(`Clearing collection ${key}`);
            let db = yield (0,idb__WEBPACK_IMPORTED_MODULE_1__.openDB)(this.dbName);
            yield this.checkForObjectStore(db, key, keyField);
            // @ts-ignore
            let transaction = db.transaction([key], "readwrite");
            // @ts-ignore
            let objectStore = transaction.store;
            // @ts-ignore
            yield objectStore.clear();
        });
    }
    callbackForRemoveItem(data, associatedStateName) {
        return __awaiter(this, void 0, void 0, function* () {
            logger(`callback for remove item for state ${associatedStateName}  - not forwarded`);
            logger(data);
        });
    }
    callbackForUpdateItem(data, associatedStateName) {
        return __awaiter(this, void 0, void 0, function* () {
            logger(`callback for update item for state ${associatedStateName}  - not forwarded`);
            logger(data);
        });
    }
    callbackForGetItems(data, associatedStateName) {
        logger(`callback for get items for state ${associatedStateName} - FORWARDING`);
        logger(data);
        this.setCompletedRun(associatedStateName, data);
        this.clearRunInProgress(associatedStateName);
        this.delegate.informChangeListenersForStateWithName(associatedStateName, data, _interface_StateManager__WEBPACK_IMPORTED_MODULE_2__.StateEventType.StateChanged, null);
    }
    callbackForAddItem(data, associatedStateName) {
        return __awaiter(this, void 0, void 0, function* () {
            logger(`callback for add item for state ${associatedStateName}  - FORWARDING`);
            logger(data);
            this.delegate.informChangeListenersForStateWithName(associatedStateName, data, _interface_StateManager__WEBPACK_IMPORTED_MODULE_2__.StateEventType.ItemAdded, null);
        });
    }
}
//# sourceMappingURL=IndexedDBStateManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/state/implementation/MemoryBufferStateManager.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/state/implementation/MemoryBufferStateManager.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MemoryBufferStateManager": () => (/* binding */ MemoryBufferStateManager)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _AbstractStateManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbstractStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/AbstractStateManager.js");
/* harmony import */ var _interface_StateManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../interface/StateManager */ "./node_modules/ui-framework-jps/dist/framework/state/interface/StateManager.js");



const msManager = debug__WEBPACK_IMPORTED_MODULE_0___default()('state-manager-ms');
/** To Do - make state unchangeable outside of this class (i.e. deep copies) */
class MemoryBufferStateManager extends _AbstractStateManager__WEBPACK_IMPORTED_MODULE_1__.AbstractStateManager {
    constructor(defaultEq, equalFns = null) {
        super('memory', defaultEq, equalFns);
        this.applicationState = [];
        this.forceSaves = true;
    }
    fireStateChangedForAllStates() {
        if (this.isEmittingEvents()) {
            this.applicationState.forEach((state) => {
                this.delegate.informChangeListenersForStateWithName(state.name, state.value, _interface_StateManager__WEBPACK_IMPORTED_MODULE_2__.StateEventType.StateChanged, null);
            });
        }
    }
    _ensureStatePresent(name) {
        let foundIndex = this.applicationState.findIndex(element => element.name === name);
        if (foundIndex < 0) {
            let state = {
                name: name,
                value: [],
                hasBeenSet: false
            };
            this.applicationState.push(state);
        }
    }
    _addNewNamedStateToStorage(state) {
        msManager(`Adding new complete state ${name}`);
        msManager(state.value);
        this.applicationState.push(state);
    }
    _replaceNamedStateInStorage(state) {
        let foundIndex = this.applicationState.findIndex(element => element.name === state.name);
        if (foundIndex >= 0) {
            msManager(`replacing complete state ${name}`);
            msManager(state.value);
            this.applicationState.splice(foundIndex, 1, state);
        }
    }
    _getState(name) {
        this._ensureStatePresent(name);
        // @ts-ignore
        let state = this.applicationState.find(element => element.name === name);
        msManager(`getting complete state ${name}`);
        msManager(state.value);
        return state;
    }
    _saveState(name, stateObject) {
        let foundIndex = this.applicationState.findIndex(element => element.name === name);
        if (foundIndex >= 0) {
            let state = this.applicationState[foundIndex];
            msManager(`SAVING complete state ${name}`);
            msManager(state.value);
            state.value = stateObject;
        }
    }
    _addItemToState(name, stateObj, isPersisted = false) {
        if (!isPersisted)
            return; // dont add incomplete objects to the state
        let foundIndex = this.applicationState.findIndex(element => element.name === name);
        if (foundIndex >= 0) {
            let state = this.applicationState[foundIndex];
            msManager(`adding item to state ${name}`);
            msManager(stateObj);
            const valueIndex = state.value.findIndex((element) => this.getEqualityFnForName(name)(element, stateObj));
            if (valueIndex >= 0) {
                state.value.splice(valueIndex, 1, stateObj);
                msManager(`item was already in state, updating instead ${name}`);
            }
            else {
                state.value.push(stateObj);
            }
        }
    }
    _removeItemFromState(name, stateObj, isPersisted) {
        let foundIndex = this.applicationState.findIndex(element => element.name === name);
        if (foundIndex >= 0) {
            let state = this.applicationState[foundIndex];
            const valueIndex = state.value.findIndex((element) => this.getEqualityFnForName(name)(element, stateObj));
            if (valueIndex >= 0) {
                msManager(`removing item from state ${name}`);
                msManager(stateObj);
                state.value.splice(valueIndex, 1);
            }
        }
    }
    _updateItemInState(name, stateObj, isPersisted) {
        let foundIndex = this.applicationState.findIndex(element => element.name === name);
        if (foundIndex >= 0) {
            let state = this.applicationState[foundIndex];
            const valueIndex = state.value.findIndex((element) => this.getEqualityFnForName(name)(element, stateObj));
            if (valueIndex >= 0) {
                state.value.splice(valueIndex, 1, stateObj);
                msManager(`updating item in state ${name}`);
                msManager(stateObj);
            }
        }
        else {
            this._addItemToState(name, stateObj, true);
        }
    }
    getAvailableStateNames() {
        let result = [];
        this.applicationState.forEach((state) => {
            result.push(state.name);
        });
        return result;
    }
}
//# sourceMappingURL=MemoryBufferStateManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/state/implementation/RESTApiStateManager.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/state/implementation/RESTApiStateManager.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RESTApiStateManager": () => (/* binding */ RESTApiStateManager)
/* harmony export */ });
/* harmony import */ var _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interface/StateManager */ "./node_modules/ui-framework-jps/dist/framework/state/interface/StateManager.js");
/* harmony import */ var _network_Types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../network/Types */ "./node_modules/ui-framework-jps/dist/framework/network/Types.js");
/* harmony import */ var _network_DownloadManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../network/DownloadManager */ "./node_modules/ui-framework-jps/dist/framework/network/DownloadManager.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _network_CallbackRegistry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../network/CallbackRegistry */ "./node_modules/ui-framework-jps/dist/framework/network/CallbackRegistry.js");
/* harmony import */ var _AbstractAsynchronousStateManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AbstractAsynchronousStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/AbstractAsynchronousStateManager.js");






const logger = debug__WEBPACK_IMPORTED_MODULE_3___default()('state-manager-api');
class RESTApiStateManager extends _AbstractAsynchronousStateManager__WEBPACK_IMPORTED_MODULE_5__.AbstractAsynchronousStateManager {
    constructor(id) {
        super(id, 'restapi');
        this.configuration = [];
        this.callbackForAddItem = this.callbackForAddItem.bind(this);
        this.callbackForRemoveItem = this.callbackForRemoveItem.bind(this);
        this.callbackForUpdateItem = this.callbackForUpdateItem.bind(this);
        this.callbackForGetItems = this.callbackForGetItems.bind(this);
        this.callbackForFindItem = this.callbackForFindItem.bind(this);
        // function ids
        this.functionIdAddItem = RESTApiStateManager.FUNCTION_ID_ADD_ITEM + id;
        this.functionIdRemoveItem = RESTApiStateManager.FUNCTION_ID_REMOVE_ITEM + id;
        this.functionIdUpdateItem = RESTApiStateManager.FUNCTION_ID_UPDATE_ITEM + id;
        this.functionIdGetItems = RESTApiStateManager.FUNCTION_ID_GET_ITEMS + id;
        this.functionIdFindItem = RESTApiStateManager.FUNCTION_ID_FIND_ITEM + id;
        _network_CallbackRegistry__WEBPACK_IMPORTED_MODULE_4__.CallbackRegistry.getInstance().addRegisterCallback(this.functionIdAddItem, this.callbackForAddItem);
        _network_CallbackRegistry__WEBPACK_IMPORTED_MODULE_4__.CallbackRegistry.getInstance().addRegisterCallback(this.functionIdRemoveItem, this.callbackForRemoveItem);
        _network_CallbackRegistry__WEBPACK_IMPORTED_MODULE_4__.CallbackRegistry.getInstance().addRegisterCallback(this.functionIdUpdateItem, this.callbackForUpdateItem);
        _network_CallbackRegistry__WEBPACK_IMPORTED_MODULE_4__.CallbackRegistry.getInstance().addRegisterCallback(this.functionIdGetItems, this.callbackForGetItems);
        _network_CallbackRegistry__WEBPACK_IMPORTED_MODULE_4__.CallbackRegistry.getInstance().addRegisterCallback(this.functionIdFindItem, this.callbackForFindItem);
    }
    static getInstance() {
        if (!(RESTApiStateManager._instance)) {
            RESTApiStateManager._instance = new RESTApiStateManager("1");
        }
        return RESTApiStateManager._instance;
    }
    initialise(configs) {
        configs.forEach((config) => {
            this.addConfig(config);
        });
        this.initialised = true;
    }
    addConfig(config) {
        this.configuration.push(config);
        this.addStateNameToConfigurations(config.stateName);
        this.initialised = true;
    }
    addConfigByStateNameAndApi(stateName, api, idField = '_id') {
        let config = {
            stateName: stateName,
            serverURL: '',
            api: api,
            isActive: true,
            idField: idField,
            find: true,
            findAll: true,
            create: true,
            update: true,
            destroy: true
        };
    }
    _addNewNamedStateToStorage(state) {
    }
    _getState(name) {
        logger(`Getting All ${name}`);
        if (this.hasCompletedRun(name)) {
            logger(`Getting All ${name} - not done - previously retrieved`);
        }
        else {
            if (!this.isRunInProgress(name)) {
                this.setRunInProgress(name);
                let config = this.getConfigurationForStateName(name);
                if (config.isActive && config.findAll) {
                    const jsonRequest = {
                        url: config.serverURL + config.api,
                        type: _network_Types__WEBPACK_IMPORTED_MODULE_1__.RequestType.GET,
                        params: {},
                        callbackId: this.functionIdGetItems,
                        associatedStateName: name
                    };
                    if (this.contextDelegate) {
                        jsonRequest.context = this.contextDelegate.getContextForApi();
                    }
                    _network_DownloadManager__WEBPACK_IMPORTED_MODULE_2__.DownloadManager.getInstance().addApiRequest(jsonRequest, true);
                }
                else {
                    logger(`No configuration for state ${name}`);
                }
            }
        }
        let state = { name: name, value: [], hasBeenSet: false };
        return state;
    }
    _ensureStatePresent(name) {
    }
    _replaceNamedStateInStorage(state) {
    }
    _saveState(name, stateObj) {
    }
    _addItemToState(name, stateObj, isPersisted = false) {
        if (isPersisted)
            return; // dont add complete objects to the state - they are already processed
        logger(`Adding item to ${name}`);
        logger(stateObj);
        let config = this.getConfigurationForStateName(name);
        if (config.isActive && config.create) {
            const jsonRequest = {
                url: config.serverURL + config.api,
                type: _network_Types__WEBPACK_IMPORTED_MODULE_1__.RequestType.POST,
                params: stateObj,
                callbackId: this.functionIdAddItem,
                associatedStateName: name
            };
            if (this.contextDelegate) {
                jsonRequest.context = this.contextDelegate.getContextForApi();
            }
            _network_DownloadManager__WEBPACK_IMPORTED_MODULE_2__.DownloadManager.getInstance().addApiRequest(jsonRequest, true);
        }
        else {
            logger(`No configuration for state ${name}`);
        }
    }
    _removeItemFromState(name, stateObj, isPersisted) {
        if (isPersisted)
            return; // dont remove complete objects to the state - they are already processed
        logger(`Removing item from ${name}`);
        logger(stateObj);
        let config = this.getConfigurationForStateName(name);
        let identifier = stateObj.id;
        if (config.idField) {
            identifier = stateObj[config.idField];
        }
        if (config.isActive && config.destroy) {
            const jsonRequest = {
                url: config.serverURL + config.api,
                type: _network_Types__WEBPACK_IMPORTED_MODULE_1__.RequestType.DELETE,
                params: {
                    id: identifier
                },
                callbackId: this.functionIdRemoveItem,
                associatedStateName: name
            };
            if (this.contextDelegate) {
                jsonRequest.context = this.contextDelegate.getContextForApi();
            }
            _network_DownloadManager__WEBPACK_IMPORTED_MODULE_2__.DownloadManager.getInstance().addApiRequest(jsonRequest, true);
        }
        else {
            logger(`No configuration for state ${name}`);
        }
    }
    _updateItemInState(name, stateObj, isPersisted) {
        if (isPersisted)
            return; // dont update complete objects to the state - they are already processed
        logger(`Updating item in ${name}`);
        logger(stateObj);
        let config = this.getConfigurationForStateName(name);
        if (config.isActive && config.update) {
            const jsonRequest = {
                url: config.serverURL + config.api,
                type: _network_Types__WEBPACK_IMPORTED_MODULE_1__.RequestType.PUT,
                params: stateObj,
                callbackId: this.functionIdUpdateItem,
                associatedStateName: name
            };
            if (this.contextDelegate) {
                jsonRequest.context = this.contextDelegate.getContextForApi();
            }
            _network_DownloadManager__WEBPACK_IMPORTED_MODULE_2__.DownloadManager.getInstance().addApiRequest(jsonRequest, true);
        }
        else {
            logger(`No configuration for state ${name}`);
        }
    }
    _findItemsInState(name, filters) {
        // TO DO
        return [];
    }
    _findItemInState(name, item) {
        logger(`Finding item from ${name}`);
        logger(item);
        let config = this.getConfigurationForStateName(name);
        let identifier = item.id;
        if (config.idField) {
            identifier = item[config.idField];
        }
        if (config.isActive && config.find) {
            const jsonRequest = {
                url: config.serverURL + config.api,
                type: _network_Types__WEBPACK_IMPORTED_MODULE_1__.RequestType.GET,
                params: {
                    id: identifier
                },
                callbackId: this.functionIdFindItem,
                associatedStateName: name
            };
            _network_DownloadManager__WEBPACK_IMPORTED_MODULE_2__.DownloadManager.getInstance().addApiRequest(jsonRequest, true);
        }
        else {
            logger(`No configuration for state ${name}`);
        }
    }
    getConfigurationForStateName(name) {
        let config = {
            stateName: name,
            serverURL: '',
            api: '',
            isActive: false,
            find: false,
            findAll: false,
            create: false,
            update: false,
            destroy: false
        };
        let foundIndex = this.configuration.findIndex((config) => config.stateName === name);
        if (foundIndex >= 0) {
            config = this.configuration[foundIndex];
        }
        return config;
    }
    callbackForRemoveItem(data, status, associatedStateName) {
        logger(`callback for remove item for state ${associatedStateName} with status ${status} - not forwarded`);
        if (status >= 200 && status <= 299) { // do we have any data?
        }
        logger(data);
    }
    callbackForUpdateItem(data, status, associatedStateName) {
        logger(`callback for update item for state ${associatedStateName} with status ${status} - not forwarded`);
        if (status >= 200 && status <= 299) { // do we have any data?
        }
        logger(data);
    }
    callbackForGetItems(data, status, associatedStateName) {
        logger(`callback for get items for state ${associatedStateName} with status ${status} - FORWARDING`);
        logger(data);
        if (status >= 200 && status <= 299) { // do we have any data?
            this.setCompletedRun(associatedStateName, data);
            this.clearRunInProgress(associatedStateName);
            this.delegate.informChangeListenersForStateWithName(associatedStateName, data, _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.StateChanged, null);
        }
    }
    callbackForFindItem(data, status, associatedStateName) {
        logger(`callback for find item for state ${associatedStateName} with status ${status} - FORWARDING`);
        if (status >= 200 && status <= 299) { // do we have any data?
            logger(data);
            this.delegate.informChangeListenersForStateWithName(associatedStateName, data, _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.FindItem, null);
        }
    }
    callbackForAddItem(data, status, associatedStateName, wasOffline) {
        logger(`callback for add item for state ${associatedStateName} with status ${status} - FORWARDING`);
        if (status >= 200 && status <= 299) { // do we have any data?
            logger(data);
            if (!wasOffline) {
                this.delegate.informChangeListenersForStateWithName(associatedStateName, data, _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.ItemAdded, null);
            }
            else {
                logger('Item was added offline, update the current data');
                this.delegate.informChangeListenersForStateWithName(associatedStateName, data, _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.ItemUpdated, null);
            }
        }
        // did the call fail? (server loss)
        if (status === 500) {
            logger(data);
            logger(`Item adding - offline, but will be queued later`);
            this.delegate.informChangeListenersForStateWithName(associatedStateName, data, _interface_StateManager__WEBPACK_IMPORTED_MODULE_0__.StateEventType.ItemAdded, null);
        }
    }
}
RESTApiStateManager.FUNCTION_ID_ADD_ITEM = 'rest.api.state.manager.add.item';
RESTApiStateManager.FUNCTION_ID_REMOVE_ITEM = 'rest.api.state.manager.remove.item';
RESTApiStateManager.FUNCTION_ID_UPDATE_ITEM = 'rest.api.state.manager.update.item';
RESTApiStateManager.FUNCTION_ID_GET_ITEMS = 'rest.api.state.manager.get.items';
RESTApiStateManager.FUNCTION_ID_FIND_ITEM = 'rest.api.state.manager.find.item';
//# sourceMappingURL=RESTApiStateManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/state/interface/StateManager.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/state/interface/StateManager.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StateEventType": () => (/* binding */ StateEventType),
/* harmony export */   "StateManagerType": () => (/* binding */ StateManagerType)
/* harmony export */ });
var StateEventType;
(function (StateEventType) {
    StateEventType[StateEventType["ItemAdded"] = 0] = "ItemAdded";
    StateEventType[StateEventType["ItemUpdated"] = 1] = "ItemUpdated";
    StateEventType[StateEventType["ItemDeleted"] = 2] = "ItemDeleted";
    StateEventType[StateEventType["StateChanged"] = 3] = "StateChanged";
    StateEventType[StateEventType["FilterResults"] = 4] = "FilterResults";
    StateEventType[StateEventType["FindItem"] = 5] = "FindItem";
})(StateEventType || (StateEventType = {}));
var StateManagerType;
(function (StateManagerType) {
    StateManagerType[StateManagerType["Local"] = 0] = "Local";
    StateManagerType[StateManagerType["AsyncLocal"] = 1] = "AsyncLocal";
    StateManagerType[StateManagerType["AsyncRemote"] = 2] = "AsyncRemote";
})(StateManagerType || (StateManagerType = {}));
//# sourceMappingURL=StateManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EXTRA_ACTION_ATTRIBUTE_NAME": () => (/* binding */ EXTRA_ACTION_ATTRIBUTE_NAME),
/* harmony export */   "ElementLocation": () => (/* binding */ ElementLocation),
/* harmony export */   "ActionType": () => (/* binding */ ActionType),
/* harmony export */   "Modifier": () => (/* binding */ Modifier),
/* harmony export */   "KeyType": () => (/* binding */ KeyType),
/* harmony export */   "SidebarLocation": () => (/* binding */ SidebarLocation),
/* harmony export */   "RowPosition": () => (/* binding */ RowPosition),
/* harmony export */   "SCREEN_WIDTH_LARGE": () => (/* binding */ SCREEN_WIDTH_LARGE),
/* harmony export */   "SCREEN_WIDTH_MEDIUM": () => (/* binding */ SCREEN_WIDTH_MEDIUM),
/* harmony export */   "SCREEN_WIDTH_SMALL": () => (/* binding */ SCREEN_WIDTH_SMALL),
/* harmony export */   "MatchLogicType": () => (/* binding */ MatchLogicType),
/* harmony export */   "CollectionViewSorterDirection": () => (/* binding */ CollectionViewSorterDirection)
/* harmony export */ });
const EXTRA_ACTION_ATTRIBUTE_NAME = 'view-extra-action';
var ElementLocation;
(function (ElementLocation) {
    ElementLocation[ElementLocation["top"] = 0] = "top";
    ElementLocation[ElementLocation["bottom"] = 1] = "bottom";
    ElementLocation[ElementLocation["left"] = 2] = "left";
    ElementLocation[ElementLocation["right"] = 3] = "right";
})(ElementLocation || (ElementLocation = {}));
var ActionType;
(function (ActionType) {
    ActionType["DELETE"] = "delete";
    ActionType["EXTRA_ACTION"] = "extraAction";
    ActionType["CUSTOM_TYPE1"] = "custom Type 1";
    ActionType["CUSTOM_TYPE2"] = "custom Type 2";
    ActionType["CUSTOM_TYPE3"] = "custom Type 3";
    ActionType["CUSTOM_TYPE4"] = "custom Type 4";
    ActionType["CUSTOM_TYPE5"] = "custom Type 5";
    ActionType["CUSTOM_TYPE6"] = "custom Type 6";
    ActionType["CUSTOM_TYPE7"] = "custom Type 7";
})(ActionType || (ActionType = {}));
var Modifier;
(function (Modifier) {
    Modifier[Modifier["normal"] = 0] = "normal";
    Modifier[Modifier["active"] = 1] = "active";
    Modifier[Modifier["inactive"] = 2] = "inactive";
    Modifier[Modifier["warning"] = 3] = "warning";
})(Modifier || (Modifier = {}));
var KeyType;
(function (KeyType) {
    KeyType[KeyType["number"] = 0] = "number";
    KeyType[KeyType["string"] = 1] = "string";
    KeyType[KeyType["boolean"] = 2] = "boolean";
    KeyType[KeyType["collection"] = 3] = "collection";
})(KeyType || (KeyType = {}));
var SidebarLocation;
(function (SidebarLocation) {
    SidebarLocation[SidebarLocation["top"] = 0] = "top";
    SidebarLocation[SidebarLocation["right"] = 1] = "right";
    SidebarLocation[SidebarLocation["left"] = 2] = "left";
    SidebarLocation[SidebarLocation["bottom"] = 3] = "bottom";
})(SidebarLocation || (SidebarLocation = {}));
var RowPosition;
(function (RowPosition) {
    RowPosition[RowPosition["first"] = 0] = "first";
    RowPosition[RowPosition["last"] = 1] = "last";
})(RowPosition || (RowPosition = {}));
const SCREEN_WIDTH_LARGE = 992;
const SCREEN_WIDTH_MEDIUM = 769;
const SCREEN_WIDTH_SMALL = 415;
var MatchLogicType;
(function (MatchLogicType) {
    MatchLogicType[MatchLogicType["AND"] = 0] = "AND";
    MatchLogicType[MatchLogicType["OR"] = 1] = "OR";
})(MatchLogicType || (MatchLogicType = {}));
var CollectionViewSorterDirection;
(function (CollectionViewSorterDirection) {
    CollectionViewSorterDirection[CollectionViewSorterDirection["ascending"] = -1] = "ascending";
    CollectionViewSorterDirection[CollectionViewSorterDirection["descending"] = 1] = "descending";
})(CollectionViewSorterDirection || (CollectionViewSorterDirection = {}));
//# sourceMappingURL=ConfigurationTypes.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/alert/AlertListener.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/alert/AlertListener.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AlertType": () => (/* binding */ AlertType)
/* harmony export */ });
var AlertType;
(function (AlertType) {
    AlertType[AlertType["cancelled"] = 0] = "cancelled";
    AlertType[AlertType["confirmed"] = 1] = "confirmed";
})(AlertType || (AlertType = {}));
//# sourceMappingURL=AlertListener.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/alert/AlertManager.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/alert/AlertManager.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AlertManager": () => (/* binding */ AlertManager)
/* harmony export */ });
/* harmony import */ var _AlertListener__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AlertListener */ "./node_modules/ui-framework-jps/dist/framework/ui/alert/AlertListener.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _key_binding_manager_KeyBindingManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../key-binding-manager/KeyBindingManager */ "./node_modules/ui-framework-jps/dist/framework/ui/key-binding-manager/KeyBindingManager.js");
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");




const ALERT_MODAL_ID = 'alert';
const ALERT_TITLE = 'alert-title';
const ALERT_CONTENT = 'alert-content';
const ALERT_CANCEL = 'alert-cancel';
const ALERT_CONFRIM = 'alert-confirm';
const ALERT_CLOSE = 'alert-close';
const ALERT_hideClass = "d-none";
const ALERT_showClass = "d-block";
const logger = debug__WEBPACK_IMPORTED_MODULE_1___default()('alert');
class AlertManager {
    constructor() {
        this.alertDiv = document.getElementById(ALERT_MODAL_ID);
        this.alertTitle = document.getElementById(ALERT_TITLE);
        this.alertContent = document.getElementById(ALERT_CONTENT);
        this.cancelButton = document.getElementById(ALERT_CANCEL);
        this.confirmButton = document.getElementById(ALERT_CONFRIM);
        this.closeButton = document.getElementById(ALERT_CLOSE);
        this.startAlert = this.startAlert.bind(this);
        this.confirmHandler = this.confirmHandler.bind(this);
        this.cancelHandler = this.cancelHandler.bind(this);
        this.keyActionEvent = this.keyActionEvent.bind(this);
        this.hide = this.hide.bind(this);
        this.show = this.show.bind(this);
        const keyBindingConfig = {
            contextName: 'Alert',
            receiver: this,
            keyBindings: [
                {
                    controlKeyRequired: false,
                    metaKeyRequired: false,
                    shiftKeyRequired: false,
                    altKeyRequired: false,
                    keyCode: 'Enter',
                    actionName: _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.BasicKeyAction.ok
                },
                {
                    controlKeyRequired: false,
                    metaKeyRequired: false,
                    shiftKeyRequired: false,
                    altKeyRequired: false,
                    keyCode: 'Escape',
                    actionName: _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.BasicKeyAction.cancel
                }
            ]
        };
        _key_binding_manager_KeyBindingManager__WEBPACK_IMPORTED_MODULE_2__.KeyBindingManager.getInstance().addContextKeyBindings(keyBindingConfig);
        this.confirmButton.addEventListener('click', this.confirmHandler);
        this.cancelButton.addEventListener('click', this.cancelHandler);
        this.closeButton.addEventListener('click', this.cancelHandler);
    }
    keyActionEvent(event) {
        switch (event.actionName) {
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.BasicKeyAction.ok: {
                this.confirmHandler(null);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.BasicKeyAction.cancel: {
                this.cancelHandler(null);
                break;
            }
        }
    }
    hide() {
        this.alertDiv.classList.remove(ALERT_showClass);
        this.alertDiv.classList.add(ALERT_hideClass);
        _key_binding_manager_KeyBindingManager__WEBPACK_IMPORTED_MODULE_2__.KeyBindingManager.getInstance().deactivateContext('Alert');
    }
    show() {
        this.alertDiv.classList.remove(ALERT_hideClass);
        this.alertDiv.classList.add(ALERT_showClass);
        _key_binding_manager_KeyBindingManager__WEBPACK_IMPORTED_MODULE_2__.KeyBindingManager.getInstance().activateContext('Alert');
    }
    static getInstance() {
        if (!(AlertManager._instance)) {
            AlertManager._instance = new AlertManager();
        }
        return AlertManager._instance;
    }
    startAlert(listener, title, content, context) {
        this.alertTitle.innerHTML = title;
        this.alertContent.innerHTML = content;
        this.show();
        this.listener = listener;
        this.context = context;
    }
    confirmHandler(event) {
        logger(`Handling confirm event from alert`);
        this.listener.alertCompleted({ outcome: _AlertListener__WEBPACK_IMPORTED_MODULE_0__.AlertType.confirmed, context: this.context });
        this.hide();
    }
    cancelHandler(event) {
        logger(`Handling cancel event from alert`);
        this.listener.alertCompleted({ outcome: _AlertListener__WEBPACK_IMPORTED_MODULE_0__.AlertType.cancelled, context: this.context });
        this.hide();
    }
}
//# sourceMappingURL=AlertManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/chat/BlockedUserView.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/chat/BlockedUserView.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlockedUserView": () => (/* binding */ BlockedUserView)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _socket_NotificationController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../socket/NotificationController */ "./node_modules/ui-framework-jps/dist/framework/socket/NotificationController.js");
/* harmony import */ var _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../socket/ChatManager */ "./node_modules/ui-framework-jps/dist/framework/socket/ChatManager.js");
/* harmony import */ var _view_implementation_AbstractStatefulCollectionView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../view/implementation/AbstractStatefulCollectionView */ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractStatefulCollectionView.js");
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var _view_renderer_ListViewRenderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../view/renderer/ListViewRenderer */ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/ListViewRenderer.js");
/* harmony import */ var _ChatTypes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ChatTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatTypes.js");







const vLogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('user-search-sidebar');
class BlockedUserView extends _view_implementation_AbstractStatefulCollectionView__WEBPACK_IMPORTED_MODULE_3__.AbstractStatefulCollectionView {
    constructor(stateManager) {
        super(BlockedUserView.DOMConfig, stateManager, _ChatTypes__WEBPACK_IMPORTED_MODULE_6__.STATE_NAMES.users);
        // list renderer
        this.renderer = new _view_renderer_ListViewRenderer__WEBPACK_IMPORTED_MODULE_5__.ListViewRenderer(this, this);
        // handler binding
        this.handleLoggedInUsersUpdated = this.handleLoggedInUsersUpdated.bind(this);
        this.handleFavouriteUserLoggedIn = this.handleFavouriteUserLoggedIn.bind(this);
        this.handleFavouriteUserLoggedOut = this.handleFavouriteUserLoggedOut.bind(this);
        this.handleFavouriteUsersChanged = this.handleFavouriteUsersChanged.bind(this);
        this.handleBlockedUsersChanged = this.handleBlockedUsersChanged.bind(this);
        this.handleLoggedInUsersUpdated = this.handleLoggedInUsersUpdated.bind(this);
        _socket_NotificationController__WEBPACK_IMPORTED_MODULE_1__.NotificationController.getInstance().addUserListener(this);
    }
    static getInstance(stateManager) {
        if (!(BlockedUserView._instance)) {
            BlockedUserView._instance = new BlockedUserView(stateManager);
        }
        return BlockedUserView._instance;
    }
    onDocumentLoaded() {
        super.onDocumentLoaded();
        this.addEventListener(this);
    }
    canDeleteItem(view, selectedItem) {
        return true;
    }
    documentLoaded(view) {
    }
    itemDeleted(view, selectedItem) {
        // @ts-ignore
        vLogger(`Blocked user ${selectedItem.username} with id ${selectedItem.id} deleted - removing`);
        _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().removeUserFromBlockedList(selectedItem.username);
    }
    itemSelected(view, selectedItem) {
        throw new Error('Method not implemented.');
    }
    itemDragStarted(view, selectedItem) {
        throw new Error('Method not implemented.');
    }
    itemAction(view, actionName, selectedItem) {
        throw new Error('Method not implemented.');
    }
    hideRequested(view) {
        throw new Error('Method not implemented.');
    }
    showRequested(view) {
        throw new Error('Method not implemented.');
    }
    handleLoggedInUsersUpdated(usernames) {
    }
    handleFavouriteUserLoggedIn(username) {
    }
    handleFavouriteUserLoggedOut(username) {
    }
    handleFavouriteUsersChanged(usernames) {
    }
    handleBlockedUsersChanged(usernames) {
        vLogger(`Handle Blocked Users changed to ${usernames}`);
        this.updateViewForNamedCollection('', {});
    }
    renderDisplayForItemInNamedCollection(containerEl, name, item) {
        containerEl.innerHTML = item.username;
    }
    getSecondaryModifierForItemInNamedCollection(name, item) {
        return _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.Modifier.warning;
    }
    getIdForItemInNamedCollection(name, item) {
        return item._id;
    }
    updateViewForNamedCollection(name, newState) {
        var _a;
        // find the blocked users in the user list
        let blockedUsers = [];
        const users = (_a = this.stateManager) === null || _a === void 0 ? void 0 : _a.getStateByName(_ChatTypes__WEBPACK_IMPORTED_MODULE_6__.STATE_NAMES.users);
        if (users) {
            users.forEach((user) => {
                if (_socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().isUserInBlockedList(user.username)) {
                    blockedUsers.push(user);
                }
            });
        }
        super.updateViewForNamedCollection(name, blockedUsers);
    }
    itemDropped(view, droppedItem) {
        if (_socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().isUserInBlockedList(droppedItem.username)) {
            vLogger(`${droppedItem.username} already in blocked list, ignoring`);
            return;
        }
        // add the user to the Chat Manager and we should get an event about it
        _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().addUserToBlockedList(droppedItem.username);
    }
    itemDeselected(view, selectedItem) {
    }
    canSelectItem(view, selectedItem) {
        return false;
    }
}
BlockedUserView.DOMConfig = {
    viewConfig: {
        resultsContainerId: 'blockedUsers',
        dataSourceId: _ChatTypes__WEBPACK_IMPORTED_MODULE_6__.VIEW_NAME.blockedUsers,
        drop: {
            acceptFrom: [_ChatTypes__WEBPACK_IMPORTED_MODULE_6__.DRAGGABLE.fromUserSearch, _ChatTypes__WEBPACK_IMPORTED_MODULE_6__.DRAGGABLE.fromFavourites],
            acceptTypes: [_ChatTypes__WEBPACK_IMPORTED_MODULE_6__.DRAGGABLE.typeUser],
        }
    },
    resultsElement: {
        type: 'a',
        attributes: [{ name: 'href', value: '#' }],
        classes: 'list-group-item my-list-item truncate-notification list-group-item-action'
    },
    keyId: '_id',
    keyType: _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.KeyType.string,
    modifiers: {
        normal: 'list-group-item-primary',
        inactive: 'list-group-item-light',
        active: 'list-group-item-info',
        warning: 'list-group-item-danger'
    },
    icons: {
        normal: 'fas fa-comment',
        inactive: 'fas fa-comment',
        active: 'fas fa-heart',
        warning: 'fas fa-exclamation-circle'
    },
    detail: {
        containerClasses: 'd-flex w-100 justify-content-between',
        textElement: {
            type: 'span',
            classes: 'mb-1'
        },
        select: true,
        quickDelete: true,
        delete: {
            classes: 'btn bg-danger text-white btn-circle btn-sm',
            iconClasses: 'fas fa-trash-alt',
        },
    },
};
//# sourceMappingURL=BlockedUserView.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatLogDetailView.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatLogDetailView.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChatLogDetailView": () => (/* binding */ ChatLogDetailView)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _socket_NotificationController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../socket/NotificationController */ "./node_modules/ui-framework-jps/dist/framework/socket/NotificationController.js");
/* harmony import */ var _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../socket/ChatManager */ "./node_modules/ui-framework-jps/dist/framework/socket/ChatManager.js");
/* harmony import */ var _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/BrowserUtil */ "./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js");
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! moment */ "./node_modules/moment/moment.js");
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _socket_Types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../socket/Types */ "./node_modules/ui-framework-jps/dist/framework/socket/Types.js");
/* harmony import */ var _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../notification/NotificationManager */ "./node_modules/ui-framework-jps/dist/framework/notification/NotificationManager.js");
/* harmony import */ var _ChatTypes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ChatTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatTypes.js");
/* harmony import */ var _security_SecurityManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../security/SecurityManager */ "./node_modules/ui-framework-jps/dist/framework/security/SecurityManager.js");
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");










const csLoggerDetail = debug__WEBPACK_IMPORTED_MODULE_0___default()('chat-sidebar:detail');
class ChatLogDetailView {
    constructor(stateManager) {
        this.stateManager = stateManager;
        this.selectedChatLog = null;
        // handler binding
        this.handleAddMessage = this.handleAddMessage.bind(this);
        this.handleChatLogsUpdated = this.handleChatLogsUpdated.bind(this);
        this.handleChatLogUpdated = this.handleChatLogUpdated.bind(this);
        this.handleChatStarted = this.handleChatStarted.bind(this);
        this.handleUserDrop = this.handleUserDrop.bind(this);
        this.leaveChat = this.leaveChat.bind(this);
        this.eventUserSelected = this.eventUserSelected.bind(this);
        _socket_NotificationController__WEBPACK_IMPORTED_MODULE_1__.NotificationController.getInstance().addListener(this);
        this.stateManager.addChangeListenerForName(_ChatTypes__WEBPACK_IMPORTED_MODULE_7__.STATE_NAMES.users, this);
    }
    clearDisplay() {
    }
    isShowing() {
        return true;
    }
    collectionChanged(view) {
    }
    static getInstance(stateManager) {
        if (!(ChatLogDetailView._instance)) {
            ChatLogDetailView._instance = new ChatLogDetailView(stateManager);
        }
        return ChatLogDetailView._instance;
    }
    hasActionPermission(actionName, from, item) {
        return true;
    }
    getListenerName() {
        return 'Chat Log Details';
    }
    canSelectItem(view, selectedItem) {
        return true;
    }
    hasPermissionToDeleteItemInNamedCollection(name, item) {
        return true;
    }
    hasPermissionToUpdateItemInNamedCollection(name, item) {
        return true;
    }
    hasChanged() {
        return false;
    }
    setContainedBy(container) {
    }
    addEventListener(listener) {
    }
    getIdForItemInNamedCollection(name, item) {
        throw new Error('Method not implemented.');
    }
    getDisplayValueForItemInNamedCollection(name, item) {
        throw new Error('Method not implemented.');
    }
    compareItemsForEquality(item1, item2) {
        throw new Error('Method not implemented.');
    }
    getModifierForItemInNamedCollection(name, item) {
        throw new Error('Method not implemented.');
    }
    getSecondaryModifierForItemInNamedCollection(name, item) {
        throw new Error('Method not implemented.');
    }
    getBadgeValueForItemInNamedCollection(name, item) {
        throw new Error('Method not implemented.');
    }
    getBackgroundImageForItemInNamedCollection(name, item) {
        throw new Error('Method not implemented.');
    }
    updateViewForNamedCollection(name, newState) {
        throw new Error('Method not implemented.');
    }
    itemDeselected(view, selectedItem) {
        csLoggerDetail(`Chat Log with id ${selectedItem.roomName} deselected`);
        if (this.selectedChatLog && (selectedItem.roomName === this.selectedChatLog.roomName)) {
            this.selectedChatLog = null;
            this.checkCanComment();
            this.clearChatLog();
        }
    }
    itemSelected(view, selectedItem) {
        this.selectedChatLog = selectedItem;
        if (this.selectedChatLog) {
            csLoggerDetail(`Chat Log with id ${selectedItem.roomName} selected`);
            this.checkCanComment();
            this.renderChatLog(this.selectedChatLog);
        }
    }
    canDeleteItem(view, selectedItem) {
        return true;
    }
    itemDeleted(view, selectedItem) {
        csLoggerDetail(`Chat Log with ${selectedItem.roomName} deleting`);
        if (this.selectedChatLog && (this.selectedChatLog.roomName === selectedItem.roomName)) {
            this.checkCanComment();
            this.renderChatLog(this.selectedChatLog);
        }
    }
    hideRequested(view) {
        this.selectedChatLog = null;
        this.checkCanComment();
        this.clearChatLog();
    }
    handleUserDrop(event) {
        csLoggerDetail('drop event on current chat room');
        if (this.selectedChatLog) {
            // @ts-ignore
            const draggedObjectJSON = event.dataTransfer.getData(_CommonTypes__WEBPACK_IMPORTED_MODULE_9__.DRAGGABLE_KEY_ID);
            const draggedObject = JSON.parse(draggedObjectJSON);
            csLoggerDetail(draggedObject);
            if (draggedObject[_CommonTypes__WEBPACK_IMPORTED_MODULE_9__.DRAGGABLE_TYPE] === _ChatTypes__WEBPACK_IMPORTED_MODULE_7__.DRAGGABLE.typeUser) {
                //add the user to the current chat if not already there
                _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().sendInvite(draggedObject.username, this.selectedChatLog.roomName);
                _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_6__.NotificationManager.getInstance().show('Chat', `Invited ${draggedObject.username} to the chat.`, draggedObject.username);
            }
        }
    }
    handleChatLogUpdated(log) {
        csLoggerDetail(`Handling chat log updates`);
        this.checkCanComment();
        this.renderChatLog(log);
    }
    handleAddMessage(event) {
        event.preventDefault();
        event.stopPropagation();
        csLoggerDetail(`Handling message event`);
        if (this.selectedChatLog) {
            // @ts-ignore
            if (this.commentEl && this.commentEl.value.trim().length === 0)
                return;
            // @ts-ignore
            const messageContent = this.commentEl.value.trim();
            // @ts-ignore
            this.commentEl.value = '';
            const simpleAttachment = { identifier: '', type: '', displayText: '' };
            let sentMessage = _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().sendMessage(this.selectedChatLog.roomName, messageContent, _socket_Types__WEBPACK_IMPORTED_MODULE_5__.Priority.Normal, simpleAttachment, {});
            if (sentMessage) {
                // add the message to our display
                let messageEl = this.addChatMessage(sentMessage);
                // scroll to bottom
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_3__["default"].scrollSmoothTo(messageEl);
            }
        }
    }
    onDocumentLoaded() {
        // @ts-ignore
        this.chatLogDiv = document.getElementById(ChatLogDetailView.chatLogId);
        // @ts-ignore
        this.commentEl = document.getElementById(ChatLogDetailView.commentId);
        // @ts-ignore
        this.chatForm = document.getElementById(ChatLogDetailView.newFormId);
        // @ts-ignore
        this.sendMessageButton = document.getElementById(ChatLogDetailView.submitCommentId);
        // @ts-ignore
        this.leaveChatButton = document.getElementById(ChatLogDetailView.leaveChatId);
        // @ts-ignore
        this.chatRoomDiv = document.getElementById(ChatLogDetailView.chatLogRoomId);
        // @ts-ignore
        this.fastUserSearch = document.getElementById(ChatLogDetailView.chatFastSearchUserNames);
        this.chatRoomDiv.addEventListener('dragover', (event) => {
            csLoggerDetail('Dragged over');
            if (this.selectedChatLog)
                event.preventDefault();
        });
        this.chatRoomDiv.addEventListener('drop', this.handleUserDrop);
        this.chatForm.addEventListener('submit', this.handleAddMessage);
        this.leaveChatButton.addEventListener('click', this.leaveChat);
        this.checkCanComment();
        // fast user search
        // @ts-ignore
        const fastSearchEl = $(`#${ChatLogDetailView.chatFastSearchUserNames}`);
        // @ts-ignore
        fastSearchEl.on('autocompleteselect', this.eventUserSelected);
    }
    eventUserSelected(event, ui) {
        event.preventDefault();
        event.stopPropagation();
        csLoggerDetail(`User ${ui.item.label} with id ${ui.item.value} selected`);
        // @ts-ignore
        event.target.innerText = '';
        // add to the chat, if one selected
        if (this.selectedChatLog)
            _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().sendInvite(ui.item.label, this.selectedChatLog.roomName);
        _notification_NotificationManager__WEBPACK_IMPORTED_MODULE_6__.NotificationManager.getInstance().show('Chat', `Invited ${ui.item.label} to the chat.`, ui.item.label);
    }
    addChatMessage(message) {
        let chatMessageEl = document.createElement('div');
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_3__["default"].addClasses(chatMessageEl, "message");
        // are we dealing with an "join"/"exit" message?
        if (message.from.trim().length === 0) {
            let messageSenderEl = document.createElement('div');
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_3__["default"].addClasses(messageSenderEl, 'message-sender');
            messageSenderEl.innerText = message.message;
            chatMessageEl.appendChild(messageSenderEl);
        }
        else {
            if (message.from === _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().getCurrentUser()) {
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_3__["default"].addClasses(chatMessageEl, "my-message");
            }
            else {
                let messageSenderEl = document.createElement('div');
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_3__["default"].addClasses(messageSenderEl, 'message-sender');
                messageSenderEl.innerText = message.from + '   ' + moment__WEBPACK_IMPORTED_MODULE_4___default()(message.created, 'YYYYMMDDHHmmss').format('DD/MM/YYYY ');
                chatMessageEl.appendChild(messageSenderEl);
            }
            let contentEl = document.createElement('div');
            if (message.from === _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().getCurrentUser()) {
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_3__["default"].addClasses(contentEl, "my-message-content");
            }
            else {
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_3__["default"].addClasses(contentEl, 'message-content');
            }
            contentEl.innerText = message.message;
            chatMessageEl.appendChild(contentEl);
        }
        this.chatLogDiv.appendChild(chatMessageEl);
        return chatMessageEl;
    }
    reRenderChatMessages(chatLog) {
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_3__["default"].removeAllChildren(this.chatLogDiv);
        let messageEl = null;
        chatLog.messages.forEach((message) => {
            messageEl = this.addChatMessage(message);
        });
        // scroll to the last message (if any)
        if (messageEl)
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_3__["default"].scrollTo(messageEl);
    }
    renderChatLog(chatLog) {
        csLoggerDetail(`Chat Log ${chatLog.roomName} rendering`);
        if (this.selectedChatLog) {
            if (this.selectedChatLog.roomName === chatLog.roomName) {
                this.selectedChatLog = chatLog;
                _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().touchChatLog(chatLog.roomName);
                // render the chat conversation
                this.reRenderChatMessages(chatLog);
            }
        }
    }
    handleChatLogsUpdated() {
        if (this.selectedChatLog) {
            _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().touchChatLog(this.selectedChatLog.roomName);
            // render the chat conversation
            this.reRenderChatMessages(this.selectedChatLog);
        }
        this.checkCanComment();
    }
    handleChatStarted(log) {
        this.selectedChatLog = log;
        this.renderChatLog(log);
    }
    stateChanged(managerName, name, newValue) {
        if (name === _ChatTypes__WEBPACK_IMPORTED_MODULE_7__.STATE_NAMES.users) {
            // @ts-ignore
            const fastSearchEl = $(`#${ChatLogDetailView.ssFastSearchUserNames}`);
            // what is my username?
            let myUsername = _security_SecurityManager__WEBPACK_IMPORTED_MODULE_8__.SecurityManager.getInstance().getLoggedInUsername();
            // for each name, construct the patient details to display and the id referenced
            const fastSearchValues = [];
            newValue.forEach((item) => {
                const searchValue = {
                    label: item.username,
                    value: item._id,
                };
                // @ts-ignore
                if (myUsername !== item.username)
                    fastSearchValues.push(searchValue); // don't search for ourselves
            });
            fastSearchEl.autocomplete({ source: fastSearchValues });
            fastSearchEl.autocomplete('option', { disabled: false, minLength: 1 });
        }
    }
    stateChangedItemAdded(managerName, name, itemAdded) {
        this.stateChanged(managerName, name, this.stateManager.getStateByName(name));
    }
    stateChangedItemRemoved(managerName, name, itemRemoved) {
    }
    stateChangedItemUpdated(managerName, name, itemUpdated, itemNewValue) {
    }
    handleOfflineMessagesReceived(messages) {
    }
    handleInvitationDeclined(room, username) {
    }
    handleNewInviteReceived(invite) {
        return true;
    }
    itemDragStarted(view, selectedItem) {
    }
    itemAction(view, actionName, selectedItem) {
    }
    documentLoaded(view) {
    }
    showRequested(view) {
    }
    itemDropped(view, droppedItem) {
    }
    getName() {
        return _ChatTypes__WEBPACK_IMPORTED_MODULE_7__.VIEW_NAME.chatLog;
    }
    hide() {
        this.hideRequested(this);
    }
    getDataSourceKeyId() {
        return "";
    }
    getUIConfig() {
        // @ts-ignore
        return undefined;
    }
    render() {
    }
    show() {
    }
    getItemDescription(from, item) {
        return "";
    }
    getItemId(from, item) {
        return "";
    }
    filterResults(managerName, name, filterResults) {
    }
    leaveChat(event) {
        event.preventDefault();
        event.stopPropagation();
        if (this.selectedChatLog) {
            _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().leaveChat(this.selectedChatLog.roomName);
            this.selectedChatLog = null;
            this.clearChatLog();
            this.checkCanComment();
        }
    }
    checkCanComment() {
        if (this.selectedChatLog) {
            if (this.commentEl)
                this.commentEl.removeAttribute("readonly");
            if (this.commentEl)
                this.commentEl.removeAttribute("disabled");
            if (this.sendMessageButton)
                this.sendMessageButton.removeAttribute("disabled");
            if (this.leaveChatButton)
                this.leaveChatButton.removeAttribute("disabled");
            if (this.fastUserSearch)
                this.fastUserSearch.removeAttribute("disabled");
        }
        else {
            if (this.commentEl)
                this.commentEl.setAttribute("readonly", "true");
            if (this.commentEl)
                this.commentEl.setAttribute("disabled", "true");
            if (this.sendMessageButton)
                this.sendMessageButton.setAttribute("disabled", "true");
            if (this.leaveChatButton)
                this.leaveChatButton.setAttribute("disabled", "true");
            if (this.fastUserSearch)
                this.fastUserSearch.setAttribute("disabled", "true");
        }
    }
    clearChatLog() {
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_3__["default"].removeAllChildren(this.chatLogDiv);
    }
    foundResult(managerName, name, foundItem) {
    }
}
ChatLogDetailView.newFormId = "newMessage";
ChatLogDetailView.commentId = "message";
ChatLogDetailView.submitCommentId = "submitMessage";
ChatLogDetailView.chatLogId = 'chatLog';
ChatLogDetailView.chatLogRoomId = 'chatLogRoom';
ChatLogDetailView.leaveChatId = 'leaveChat';
ChatLogDetailView.chatFastSearchUserNames = 'chatFastSearchUserNames';
//# sourceMappingURL=ChatLogDetailView.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatLogsView.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatLogsView.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChatLogsView": () => (/* binding */ ChatLogsView)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _socket_NotificationController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../socket/NotificationController */ "./node_modules/ui-framework-jps/dist/framework/socket/NotificationController.js");
/* harmony import */ var _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../socket/ChatManager */ "./node_modules/ui-framework-jps/dist/framework/socket/ChatManager.js");
/* harmony import */ var _view_implementation_AbstractStatefulCollectionView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../view/implementation/AbstractStatefulCollectionView */ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractStatefulCollectionView.js");
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var _state_implementation_MemoryBufferStateManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../state/implementation/MemoryBufferStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/MemoryBufferStateManager.js");
/* harmony import */ var _util_EqualityFunctions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../util/EqualityFunctions */ "./node_modules/ui-framework-jps/dist/framework/util/EqualityFunctions.js");
/* harmony import */ var _view_renderer_ListViewRenderer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../view/renderer/ListViewRenderer */ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/ListViewRenderer.js");
/* harmony import */ var _ChatTypes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ChatTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatTypes.js");









const csLogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('chat-sidebar');
class ChatLogsView extends _view_implementation_AbstractStatefulCollectionView__WEBPACK_IMPORTED_MODULE_3__.AbstractStatefulCollectionView {
    constructor() {
        super(ChatLogsView.DOMConfig, new _state_implementation_MemoryBufferStateManager__WEBPACK_IMPORTED_MODULE_5__.MemoryBufferStateManager(_util_EqualityFunctions__WEBPACK_IMPORTED_MODULE_6__.isSameRoom), _ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.chatLogs);
        this.selectedChatLog = null;
        this.renderer = new _view_renderer_ListViewRenderer__WEBPACK_IMPORTED_MODULE_7__.ListViewRenderer(this, this);
        // handler binding
        this.handleChatLogsUpdated = this.handleChatLogsUpdated.bind(this);
        this.handleChatLogUpdated = this.handleChatLogUpdated.bind(this);
        this.handleChatStarted = this.handleChatStarted.bind(this);
        _socket_NotificationController__WEBPACK_IMPORTED_MODULE_1__.NotificationController.getInstance().addListener(this);
    }
    static getInstance() {
        if (!(ChatLogsView._instance)) {
            ChatLogsView._instance = new ChatLogsView();
        }
        return ChatLogsView._instance;
    }
    compareItemsForEquality(item1, item2) {
        return (0,_util_EqualityFunctions__WEBPACK_IMPORTED_MODULE_6__.isSameRoom)(item1, item2);
    }
    handleNewInviteReceived(invite) {
        return true;
    }
    handleChatLogUpdated(log) {
        csLogger(`Handling chat log updates`);
        this.updateStateManager();
    }
    onDocumentLoaded() {
        super.onDocumentLoaded();
        this.addEventCollectionListener(this);
        this.updateStateManager();
    }
    getIdForItemInNamedCollection(name, item) {
        return item.roomName;
    }
    renderDisplayForItemInNamedCollection(containerEl, name, item) {
        containerEl.innerHTML = item.users.join(',');
    }
    getModifierForItemInNamedCollection(name, item) {
        let result = _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.Modifier.inactive;
        if (this.selectedChatLog) {
            if (this.selectedChatLog.roomName === item.roomName) {
                result = _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.Modifier.active;
            }
        }
        return result;
    }
    getSecondaryModifierForItemInNamedCollection(name, item) {
        return this.getModifierForItemInNamedCollection(name, item);
    }
    selectChatRoom(roomName) {
        let room = _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().getChatLog(roomName);
        this.selectedChatLog = room;
        this.eventForwarder.itemSelected(this, this.selectedChatLog);
        this.updateStateManager();
    }
    handleChatLogsUpdated() {
        if (this.selectedChatLog) {
            _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().touchChatLog(this.selectedChatLog.roomName);
        }
        this.updateStateManager();
    }
    handleChatStarted(log) {
        this.selectedChatLog = log;
        this.eventForwarder.itemSelected(this, this.selectedChatLog);
        this.updateStateManager();
    }
    getBadgeValueForItemInNamedCollection(name, item) {
        return item.unreadMessages + item.unreadHighMessages + item.unreadUrgentMessages;
    }
    canDeleteItem(view, selectedItem) {
        return true;
    }
    itemDeleted(view, selectedItem) {
        csLogger(`Deleting chat ${selectedItem.roomName}`);
        _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().leaveChat(selectedItem.roomName);
        if (this.selectedChatLog && (this.selectedChatLog.roomName === selectedItem.roomName)) {
            this.eventForwarder.itemDeselected(this, this.selectedChatLog);
            this.selectedChatLog = null;
        }
        this.updateStateManager();
    }
    hideRequested(view) {
        if (this.selectedChatLog) {
            this.eventForwarder.itemDeselected(this, this.selectedChatLog);
            this.selectedChatLog = null;
        }
    }
    hide() {
        this.hideRequested(this);
    }
    documentLoaded(view) {
    }
    itemAction(view, actionName, selectedItem) {
    }
    itemDragStarted(view, selectedItem) {
    }
    itemDropped(view, droppedItem) {
    }
    itemSelected(view, selectedItem) {
        this.selectedChatLog = selectedItem;
        this.updateStateManager();
    }
    itemDeselected(view, selectedItem) {
        this.selectedChatLog = null;
        this.updateStateManager();
    }
    showRequested(view) {
    }
    handleOfflineMessagesReceived(messages) {
    }
    handleInvitationDeclined(room, username) {
    }
    canSelectItem(view, selectedItem) {
        return true;
    }
    updateStateManager() {
        csLogger(`Updating state with chat manager`);
        let newState = _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().getChatLogs();
        csLogger(newState);
        this.stateManager.setStateByName(_ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.chatLogs, newState, true);
    }
}
ChatLogsView.DOMConfig = {
    viewConfig: {
        resultsContainerId: 'chatLogs',
        dataSourceId: _ChatTypes__WEBPACK_IMPORTED_MODULE_8__.VIEW_NAME.chatLogs,
    },
    resultsElement: {
        type: 'a',
        attributes: [{ name: 'href', value: '#' }],
        classes: 'list-group-item my-list-item truncate-notification list-group-item-action'
    },
    keyId: 'roomName',
    keyType: _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.KeyType.string,
    modifiers: {
        normal: '',
        inactive: 'list-group-item-dark',
        active: 'list-group-item-primary',
        warning: ''
    },
    detail: {
        containerClasses: 'd-flex w-100 justify-content-between',
        textElement: {
            type: 'span',
            classes: 'mb-1'
        },
        select: true,
        delete: {
            classes: 'btn bg-danger text-white btn-circle btn-sm',
            iconClasses: 'text-black fas fa-sign-out-alt',
        },
        badge: {
            type: 'span',
            classes: 'badge badge-pill badge-primary mr-1',
        }
    },
};
//# sourceMappingURL=ChatLogsView.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatRoomsSidebar.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatRoomsSidebar.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChatRoomsSidebar": () => (/* binding */ ChatRoomsSidebar)
/* harmony export */ });
/* harmony import */ var _container_SidebarViewContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/SidebarViewContainer */ "./node_modules/ui-framework-jps/dist/framework/ui/container/SidebarViewContainer.js");
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var _ChatLogsView__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ChatLogsView */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatLogsView.js");
/* harmony import */ var _ChatLogDetailView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ChatLogDetailView */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatLogDetailView.js");




class ChatRoomsSidebar extends _container_SidebarViewContainer__WEBPACK_IMPORTED_MODULE_0__.SidebarViewContainer {
    constructor(stateManager) {
        super(ChatRoomsSidebar.SidebarPrefs);
        const chatView = _ChatLogsView__WEBPACK_IMPORTED_MODULE_2__.ChatLogsView.getInstance();
        this.addView(chatView, { containerId: ChatRoomsSidebar.SidebarContainers.chatLogs });
        const chatLogView = _ChatLogDetailView__WEBPACK_IMPORTED_MODULE_3__.ChatLogDetailView.getInstance(stateManager);
        this.addView(chatLogView, { containerId: ChatRoomsSidebar.SidebarContainers.chatLog });
        chatView.addEventListener(chatLogView);
    }
    static getInstance(stateManager) {
        if (!(ChatRoomsSidebar._instance)) {
            ChatRoomsSidebar._instance = new ChatRoomsSidebar(stateManager);
        }
        return ChatRoomsSidebar._instance;
    }
}
ChatRoomsSidebar.SidebarPrefs = {
    id: 'chatSideBar',
    expandedSize: '35%',
    location: _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.SidebarLocation.right
};
ChatRoomsSidebar.SidebarContainers = {
    chatLogs: 'chatLogs',
    chatLog: 'chatLogRoom'
};
//# sourceMappingURL=ChatRoomsSidebar.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatTypes.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatTypes.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "STATE_NAMES": () => (/* binding */ STATE_NAMES),
/* harmony export */   "DRAGGABLE": () => (/* binding */ DRAGGABLE),
/* harmony export */   "VIEW_NAME": () => (/* binding */ VIEW_NAME)
/* harmony export */ });
const STATE_NAMES = {
    users: 'user',
    chatLogs: 'chatLog',
    recentUserSearches: 'recentUserSearch'
};
const DRAGGABLE = {
    typeUser: 'user',
    fromUserSearch: 'userSearch',
    fromFavourites: 'favourites',
};
const VIEW_NAME = {
    blockedUsers: 'blockedUsers',
    chatLog: 'chatLog',
    chatLogs: 'chatLogs',
    favouriteUsers: 'favouriteUsers',
    userSearch: 'userSearch',
};
//# sourceMappingURL=ChatTypes.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/chat/FavouriteUserView.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/chat/FavouriteUserView.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FavouriteUserView": () => (/* binding */ FavouriteUserView)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _socket_NotificationController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../socket/NotificationController */ "./node_modules/ui-framework-jps/dist/framework/socket/NotificationController.js");
/* harmony import */ var _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../socket/ChatManager */ "./node_modules/ui-framework-jps/dist/framework/socket/ChatManager.js");
/* harmony import */ var _view_implementation_AbstractStatefulCollectionView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../view/implementation/AbstractStatefulCollectionView */ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractStatefulCollectionView.js");
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var _view_renderer_ListViewRenderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../view/renderer/ListViewRenderer */ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/ListViewRenderer.js");
/* harmony import */ var _ChatTypes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ChatTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatTypes.js");







const vLogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('user-search-sidebar');
const vLoggerDetail = debug__WEBPACK_IMPORTED_MODULE_0___default()('user-search-sidebar:detail');
class FavouriteUserView extends _view_implementation_AbstractStatefulCollectionView__WEBPACK_IMPORTED_MODULE_3__.AbstractStatefulCollectionView {
    constructor(stateManager) {
        super(FavouriteUserView.DOMConfig, stateManager, _ChatTypes__WEBPACK_IMPORTED_MODULE_6__.STATE_NAMES.users);
        this.renderer = new _view_renderer_ListViewRenderer__WEBPACK_IMPORTED_MODULE_5__.ListViewRenderer(this, this);
        // handler binding
        this.handleLoggedInUsersUpdated = this.handleLoggedInUsersUpdated.bind(this);
        this.handleFavouriteUserLoggedIn = this.handleFavouriteUserLoggedIn.bind(this);
        this.handleFavouriteUserLoggedOut = this.handleFavouriteUserLoggedOut.bind(this);
        this.handleFavouriteUsersChanged = this.handleFavouriteUsersChanged.bind(this);
        this.handleBlockedUsersChanged = this.handleBlockedUsersChanged.bind(this);
        this.handleLoggedInUsersUpdated = this.handleLoggedInUsersUpdated.bind(this);
        _socket_NotificationController__WEBPACK_IMPORTED_MODULE_1__.NotificationController.getInstance().addUserListener(this);
    }
    static getInstance(stateManager) {
        if (!(FavouriteUserView._instance)) {
            FavouriteUserView._instance = new FavouriteUserView(stateManager);
        }
        return FavouriteUserView._instance;
    }
    onDocumentLoaded() {
        super.onDocumentLoaded();
        this.addEventCollectionListener(this);
    }
    handleLoggedInUsersUpdated(usernames) {
        vLogger(`Received new list of users who are logged in `);
        this.updateViewForNamedCollection('', {});
    }
    handleFavouriteUserLoggedIn(username) {
        vLogger(`Handle Favourite User ${username} logged in`);
        this.updateViewForNamedCollection('', {});
    }
    handleFavouriteUserLoggedOut(username) {
        vLogger(`Handle Favourite User ${username} logged in`);
        this.updateViewForNamedCollection('', {});
    }
    handleFavouriteUsersChanged(usernames) {
        vLogger(`Handle Favourite Users changed to ${usernames}`);
        this.updateViewForNamedCollection('', {});
    }
    getIdForItemInNamedCollection(name, item) {
        return item._id;
    }
    renderDisplayForItemInNamedCollection(containerEl, name, item) {
        containerEl.innerHTML = item.username;
    }
    getModifierForItemInNamedCollection(name, item) {
        let result = _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.Modifier.normal;
        // if the user is currently logged out make the item inactive
        if (!_socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().isUserLoggedIn(item.username)) {
            result = _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.Modifier.inactive;
        }
        return result;
    }
    getSecondaryModifierForItemInNamedCollection(name, item) {
        let result = _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.Modifier.normal;
        vLoggerDetail(`Checking for item secondary modifiers ${item.username}`);
        // if the user is in the black list then show warning and a favourite user is highlighted
        if (_socket_NotificationController__WEBPACK_IMPORTED_MODULE_1__.NotificationController.getInstance().isFavouriteUser(item.username)) {
            vLoggerDetail(`is favourite`);
            result = _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.Modifier.active;
        }
        if (_socket_NotificationController__WEBPACK_IMPORTED_MODULE_1__.NotificationController.getInstance().isBlockedUser(item.username)) {
            vLoggerDetail(`is blocked`);
            result = _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.Modifier.warning;
        }
        return result;
    }
    updateViewForNamedCollection(name, newState) {
        var _a;
        // find the blocked users in the user list
        let favUsers = [];
        const users = (_a = this.stateManager) === null || _a === void 0 ? void 0 : _a.getStateByName(_ChatTypes__WEBPACK_IMPORTED_MODULE_6__.STATE_NAMES.users);
        if (users) {
            users.forEach((user) => {
                if (_socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().isUserInFavouriteList(user.username)) {
                    favUsers.push(user);
                }
            });
        }
        super.updateViewForNamedCollection(name, favUsers);
    }
    documentLoaded(view) {
    }
    handleBlockedUsersChanged(usernames) {
        this.updateViewForNamedCollection('', {});
    }
    hideRequested(view) {
    }
    itemAction(view, actionName, selectedItem) {
        // @ts-ignore
        if (actionName === this.collectionUIConfig.extraActions[0].name) {
            if (_socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().isUserInBlockedList(selectedItem.username)) {
                vLogger(`${selectedItem.username} already in fav list, ignoring`);
                return;
            }
            _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().addUserToBlockedList(selectedItem.username);
        }
    }
    canDeleteItem(view, selectedItem) {
        return true;
    }
    itemDeleted(view, selectedItem) {
        vLogger(`Favourite user ${selectedItem.username} with id ${selectedItem.id} deleted - removing`);
        _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().removeUserFromFavouriteList(selectedItem.username);
    }
    itemDragStarted(view, selectedItem) {
    }
    itemDeselected(view, selectedItem) {
    }
    itemDropped(view, droppedItem) {
        vLogger(`Handling item dropped ${droppedItem.username}`);
        if (_socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().isUserInFavouriteList(droppedItem.username)) {
            vLogger(`${droppedItem.username} already in fav list, ignoring`);
            return;
        }
        // add the user to the Chat Manager and we should get an event about it
        _socket_ChatManager__WEBPACK_IMPORTED_MODULE_2__.ChatManager.getInstance().addUserToFavouriteList(droppedItem.username);
    }
    itemSelected(view, selectedItem) {
        const roomName = _socket_NotificationController__WEBPACK_IMPORTED_MODULE_1__.NotificationController.getInstance().startChatWithUser(selectedItem.username);
    }
    showRequested(view) {
    }
    canSelectItem(view, selectedItem) {
        return true;
    }
}
FavouriteUserView.DOMConfig = {
    viewConfig: {
        resultsContainerId: 'favouriteUsers',
        drop: {
            acceptFrom: [_ChatTypes__WEBPACK_IMPORTED_MODULE_6__.DRAGGABLE.fromUserSearch],
            acceptTypes: [_ChatTypes__WEBPACK_IMPORTED_MODULE_6__.DRAGGABLE.typeUser],
        },
        dataSourceId: _ChatTypes__WEBPACK_IMPORTED_MODULE_6__.VIEW_NAME.favouriteUsers,
    },
    resultsElement: {
        type: 'a',
        attributes: [{ name: 'href', value: '#' }],
        classes: 'list-group-item my-list-item truncate-notification list-group-item-action'
    },
    keyId: '_id',
    keyType: _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_4__.KeyType.string,
    modifiers: {
        normal: 'list-group-item-primary',
        inactive: 'list-group-item-light',
        active: 'list-group-item-info',
        warning: 'list-group-item-danger'
    },
    icons: {
        normal: 'fas fa-comment',
        inactive: 'fas fa-comment',
        active: 'fas fa-heart',
        warning: 'fas fa-exclamation-circle'
    },
    detail: {
        containerClasses: 'd-flex w-100 justify-content-between',
        textElement: {
            type: 'span',
            classes: 'mb-1'
        },
        select: true,
        quickDelete: true,
        delete: {
            classes: 'btn bg-danger text-white btn-circle btn-sm',
            iconClasses: 'fas fa-trash-alt',
        },
        drag: {
            type: _ChatTypes__WEBPACK_IMPORTED_MODULE_6__.DRAGGABLE.typeUser,
            from: _ChatTypes__WEBPACK_IMPORTED_MODULE_6__.DRAGGABLE.fromFavourites
        },
    },
    extraActions: [
        {
            name: 'block',
            button: {
                classes: 'btn bg-warning text-white btn-circle btn-sm mr-1',
                iconClasses: 'fas fa-user-slash'
            },
            confirm: false
        }
    ]
};
//# sourceMappingURL=FavouriteUserView.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/chat/UserSearchSidebar.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/chat/UserSearchSidebar.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UserSearchSidebar": () => (/* binding */ UserSearchSidebar)
/* harmony export */ });
/* harmony import */ var _container_SidebarViewContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../container/SidebarViewContainer */ "./node_modules/ui-framework-jps/dist/framework/ui/container/SidebarViewContainer.js");
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var _UserSearchView__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./UserSearchView */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/UserSearchView.js");
/* harmony import */ var _FavouriteUserView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FavouriteUserView */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/FavouriteUserView.js");
/* harmony import */ var _BlockedUserView__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BlockedUserView */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/BlockedUserView.js");
/* harmony import */ var _ChatRoomsSidebar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ChatRoomsSidebar */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatRoomsSidebar.js");






class UserSearchSidebar extends _container_SidebarViewContainer__WEBPACK_IMPORTED_MODULE_0__.SidebarViewContainer {
    constructor(stateManager) {
        super(UserSearchSidebar.SidebarPrefs);
        const recentSearches = _UserSearchView__WEBPACK_IMPORTED_MODULE_2__.UserSearchView.getInstance(stateManager);
        this.addView(recentSearches, { containerId: UserSearchSidebar.SidebarContainers.recentSearches });
        const favouriteUsers = _FavouriteUserView__WEBPACK_IMPORTED_MODULE_3__.FavouriteUserView.getInstance(stateManager);
        this.addView(favouriteUsers, { containerId: UserSearchSidebar.SidebarContainers.favourites });
        const blockedUsers = _BlockedUserView__WEBPACK_IMPORTED_MODULE_4__.BlockedUserView.getInstance(stateManager);
        this.addView(blockedUsers, { containerId: UserSearchSidebar.SidebarContainers.blocked });
        this.logSB = _ChatRoomsSidebar__WEBPACK_IMPORTED_MODULE_5__.ChatRoomsSidebar.getInstance(stateManager);
    }
    static getInstance(stateManager) {
        if (!(UserSearchSidebar._instance)) {
            UserSearchSidebar._instance = new UserSearchSidebar(stateManager);
        }
        return UserSearchSidebar._instance;
    }
}
UserSearchSidebar.SidebarPrefs = {
    id: 'userSearchSideBar',
    expandedSize: '35%',
    location: _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.SidebarLocation.left
};
UserSearchSidebar.SidebarContainers = {
    recentSearches: 'userSearchZone',
    favourites: 'favouriteUsersDropZone',
    blocked: 'blockedUsersDropZone'
};
//# sourceMappingURL=UserSearchSidebar.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/chat/UserSearchView.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/chat/UserSearchView.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UserSearchView": () => (/* binding */ UserSearchView)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_EqualityFunctions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/EqualityFunctions */ "./node_modules/ui-framework-jps/dist/framework/util/EqualityFunctions.js");
/* harmony import */ var _socket_NotificationController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../socket/NotificationController */ "./node_modules/ui-framework-jps/dist/framework/socket/NotificationController.js");
/* harmony import */ var _state_implementation_BrowserStorageStateManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../state/implementation/BrowserStorageStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/BrowserStorageStateManager.js");
/* harmony import */ var _socket_ChatManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../socket/ChatManager */ "./node_modules/ui-framework-jps/dist/framework/socket/ChatManager.js");
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var _view_implementation_AbstractStatefulCollectionView__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../view/implementation/AbstractStatefulCollectionView */ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractStatefulCollectionView.js");
/* harmony import */ var _view_renderer_ListViewRenderer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../view/renderer/ListViewRenderer */ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/ListViewRenderer.js");
/* harmony import */ var _ChatTypes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ChatTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatTypes.js");
/* harmony import */ var _security_SecurityManager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../security/SecurityManager */ "./node_modules/ui-framework-jps/dist/framework/security/SecurityManager.js");
/* harmony import */ var _ChatRoomsSidebar__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ChatRoomsSidebar */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatRoomsSidebar.js");
/* harmony import */ var _ChatLogsView__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ChatLogsView */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatLogsView.js");












const vLogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('user-search');
const vLoggerDetail = debug__WEBPACK_IMPORTED_MODULE_0___default()('user-search-detail');
class UserSearchView extends _view_implementation_AbstractStatefulCollectionView__WEBPACK_IMPORTED_MODULE_6__.AbstractStatefulCollectionView {
    constructor(stateManager) {
        super(UserSearchView.DOMConfig, stateManager, _ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.users);
        this.loggedInUsers = [];
        this.renderer = new _view_renderer_ListViewRenderer__WEBPACK_IMPORTED_MODULE_7__.ListViewRenderer(this, this);
        // handler binding
        this.updateViewForNamedCollection = this.updateViewForNamedCollection.bind(this);
        this.eventUserSelected = this.eventUserSelected.bind(this);
        this.handleLoggedInUsersUpdated = this.handleLoggedInUsersUpdated.bind(this);
        this.handleFavouriteUserLoggedIn = this.handleFavouriteUserLoggedIn.bind(this);
        this.handleFavouriteUserLoggedOut = this.handleFavouriteUserLoggedOut.bind(this);
        this.handleFavouriteUsersChanged = this.handleFavouriteUsersChanged.bind(this);
        this.handleBlockedUsersChanged = this.handleBlockedUsersChanged.bind(this);
        this.handleLoggedInUsersUpdated = this.handleLoggedInUsersUpdated.bind(this);
        this.itemDeleted = this.itemDeleted.bind(this);
        // register state change listening
        this.localisedSM = new _state_implementation_BrowserStorageStateManager__WEBPACK_IMPORTED_MODULE_3__.BrowserStorageStateManager(true, false, _util_EqualityFunctions__WEBPACK_IMPORTED_MODULE_1__.isSameMongo);
        this.localisedSM.addChangeListenerForName(_ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.recentUserSearches, this);
        _socket_NotificationController__WEBPACK_IMPORTED_MODULE_2__.NotificationController.getInstance().addUserListener(this);
        vLogger(this.localisedSM.getStateByName(_ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.recentUserSearches));
    }
    static getInstance(stateManager) {
        if (!(UserSearchView._instance)) {
            UserSearchView._instance = new UserSearchView(stateManager);
        }
        return UserSearchView._instance;
    }
    handleLoggedInUsersUpdated(usernames) {
        vLogger(`Received new list of users who are logged in `);
        vLogger(usernames);
        this.loggedInUsers = usernames;
        this.updateViewForNamedCollection(_ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.recentUserSearches, {});
    }
    handleFavouriteUserLoggedIn(username) {
        vLogger(`Handle Favourite User ${username} logged in`);
        this.updateViewForNamedCollection(_ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.recentUserSearches, {});
    }
    handleFavouriteUserLoggedOut(username) {
        vLogger(`Handle Favourite User ${username} logged in`);
        this.updateViewForNamedCollection(_ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.recentUserSearches, {});
    }
    handleFavouriteUsersChanged(usernames) {
        vLogger(`Handle Favourite Users changed to ${usernames}`);
        this.updateViewForNamedCollection(_ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.recentUserSearches, {});
    }
    handleBlockedUsersChanged(usernames) {
        vLogger(`Handle Blocked Users changed to ${usernames}`);
        this.updateViewForNamedCollection(_ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.recentUserSearches, {});
    }
    onDocumentLoaded() {
        super.onDocumentLoaded();
        // @ts-ignore
        const fastSearchEl = $(`#${UserSearchView.fastSearchInputId}`);
        // @ts-ignore
        fastSearchEl.on('autocompleteselect', this.eventUserSelected);
    }
    getIdForItemInNamedCollection(name, item) {
        return item._id;
    }
    renderDisplayForItemInNamedCollection(containerEl, name, item) {
        containerEl.innerHTML = item.username;
    }
    getModifierForItemInNamedCollection(name, item) {
        let result = _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_5__.Modifier.normal;
        vLoggerDetail(`Checking for item modifiers`);
        vLoggerDetail(item);
        // if the user is currently logged out make the item inactive
        if (!_socket_ChatManager__WEBPACK_IMPORTED_MODULE_4__.ChatManager.getInstance().isUserLoggedIn(item.username)) {
            result = _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_5__.Modifier.inactive;
        }
        return result;
    }
    getSecondaryModifierForItemInNamedCollection(name, item) {
        let result = _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_5__.Modifier.normal;
        vLoggerDetail(`Checking for item secondary modifiers ${item.username}`);
        // if the user is in the black list then show warning and a favourite user is highlighted
        if (_socket_NotificationController__WEBPACK_IMPORTED_MODULE_2__.NotificationController.getInstance().isFavouriteUser(item.username)) {
            vLoggerDetail(`is favourite`);
            result = _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_5__.Modifier.active;
        }
        if (_socket_NotificationController__WEBPACK_IMPORTED_MODULE_2__.NotificationController.getInstance().isBlockedUser(item.username)) {
            vLoggerDetail(`is blocked`);
            result = _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_5__.Modifier.warning;
        }
        return result;
    }
    eventUserSelected(event, ui) {
        event.preventDefault();
        event.stopPropagation();
        vLogger(`User ${ui.item.label} with id ${ui.item.value} selected`);
        // @ts-ignore
        event.target.innerText = '';
        // add the selected user to the recent user searches
        if (this.localisedSM.isItemInState(_ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.recentUserSearches, { _id: ui.item.value }))
            return;
        const recentUserSearches = this.localisedSM.getStateByName(_ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.recentUserSearches);
        vLogger(`saved searches too long? ${_ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.recentUserSearches}`);
        if (recentUserSearches.length >= UserSearchView.dataLimit) {
            vLogger('saved searches too long - removing first');
            // remove the first item from recent searches
            const item = recentUserSearches.shift();
            this.localisedSM.removeItemFromState(_ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.recentUserSearches, item, true);
        }
        // save the searches
        this.localisedSM.addNewItemToState(_ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.recentUserSearches, {
            _id: ui.item.value,
            username: ui.item.label
        }, true);
    }
    updateViewForNamedCollection(name, newState) {
        if (name === _ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.recentUserSearches) {
            vLogger(`Updating for recent searches`);
            newState = this.localisedSM.getStateByName(_ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.recentUserSearches);
            vLogger(newState);
            super.updateViewForNamedCollection(name, newState);
        }
        if (name === _ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.users) {
            // load the search names into the search field
            // what is my username?
            let myUsername = _security_SecurityManager__WEBPACK_IMPORTED_MODULE_9__.SecurityManager.getInstance().getLoggedInUsername();
            // @ts-ignore
            const fastSearchEl = $(`#${UserSearchView.fastSearchInputId}`);
            // for each name, construct the patient details to display and the id referenced
            const fastSearchValues = [];
            newState.forEach((item) => {
                const searchValue = {
                    label: item.username,
                    value: item._id,
                };
                if (myUsername !== item.username)
                    fastSearchValues.push(searchValue); // don't search for ourselves
            });
            fastSearchEl.autocomplete({ source: fastSearchValues });
            fastSearchEl.autocomplete('option', { disabled: false, minLength: 1 });
        }
    }
    itemAction(view, actionName, selectedItem) {
        // @ts-ignore
        if (actionName === this.collectionUIConfig.extraActions[0].name) {
            if (_socket_ChatManager__WEBPACK_IMPORTED_MODULE_4__.ChatManager.getInstance().isUserInFavouriteList(selectedItem.username)) {
                vLogger(`${selectedItem.username} already in fav list, ignoring`);
                return;
            }
            _socket_ChatManager__WEBPACK_IMPORTED_MODULE_4__.ChatManager.getInstance().addUserToFavouriteList(selectedItem.username);
        }
        // @ts-ignore
        if (actionName === this.collectionUIConfig.extraActions[1].name) {
            if (_socket_ChatManager__WEBPACK_IMPORTED_MODULE_4__.ChatManager.getInstance().isUserInBlockedList(selectedItem.username)) {
                vLogger(`${selectedItem.username} already in blocked list, ignoring`);
                return;
            }
            _socket_ChatManager__WEBPACK_IMPORTED_MODULE_4__.ChatManager.getInstance().addUserToBlockedList(selectedItem.username);
        }
    }
    compareItemsForEquality(item1, item2) {
        return (0,_util_EqualityFunctions__WEBPACK_IMPORTED_MODULE_1__.isSameMongo)(item1, item2);
    }
    itemDeleted(view, selectedItem) {
        vLoggerDetail(selectedItem);
        vLogger(`Recent search user ${selectedItem.username} with id ${selectedItem.id} deleted - removing`);
        this.localisedSM.removeItemFromState(_ChatTypes__WEBPACK_IMPORTED_MODULE_8__.STATE_NAMES.recentUserSearches, selectedItem, true);
    }
    itemSelected(view, selectedItem) {
        const roomName = _socket_NotificationController__WEBPACK_IMPORTED_MODULE_2__.NotificationController.getInstance().startChatWithUser(selectedItem.username);
        _ChatRoomsSidebar__WEBPACK_IMPORTED_MODULE_10__.ChatRoomsSidebar.getInstance(this.stateManager).show();
        if (roomName)
            _ChatLogsView__WEBPACK_IMPORTED_MODULE_11__.ChatLogsView.getInstance().selectChatRoom(roomName);
    }
}
UserSearchView.fastSearchInputId = 'fastSearchUserNames';
UserSearchView.dataLimit = 10;
UserSearchView.DOMConfig = {
    viewConfig: {
        resultsContainerId: 'recentUserSearches',
        dataSourceId: _ChatTypes__WEBPACK_IMPORTED_MODULE_8__.VIEW_NAME.userSearch,
    },
    resultsElement: {
        type: 'a',
        attributes: [{ name: 'href', value: '#' }],
        classes: 'list-group-item my-list-item truncate-notification list-group-item-action'
    },
    keyId: '_id',
    keyType: _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_5__.KeyType.string,
    modifiers: {
        normal: 'list-group-item-primary',
        inactive: 'list-group-item-light',
        active: 'list-group-item-info',
        warning: 'list-group-item-danger'
    },
    icons: {
        normal: 'fas fa-comment',
        inactive: 'fas fa-comment',
        active: 'fas fa-heart',
        warning: 'fas fa-exclamation-circle'
    },
    detail: {
        containerClasses: 'd-flex w-100 justify-content-between',
        textElement: {
            type: 'span',
            classes: 'mb-1'
        },
        select: true,
        quickDelete: true,
        delete: {
            classes: 'btn bg-danger text-white btn-circle btn-sm',
            iconClasses: 'fas fa-trash-alt',
        },
        drag: {
            type: _ChatTypes__WEBPACK_IMPORTED_MODULE_8__.DRAGGABLE.typeUser,
            from: _ChatTypes__WEBPACK_IMPORTED_MODULE_8__.DRAGGABLE.fromUserSearch
        },
    },
    extraActions: [
        {
            name: 'favourite',
            button: {
                classes: 'btn bg-info text-white btn-circle btn-sm mr-1',
                iconClasses: 'fas fa-user-plus'
            },
            confirm: false
        },
        {
            name: 'block',
            button: {
                classes: 'btn bg-warning text-white btn-circle btn-sm mr-1',
                iconClasses: 'fas fa-user-slash'
            },
            confirm: false
        }
    ]
};
//# sourceMappingURL=UserSearchView.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/config/CollectionUIConfigController.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/config/CollectionUIConfigController.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CollectionUIConfigController": () => (/* binding */ CollectionUIConfigController)
/* harmony export */ });
/* harmony import */ var _model_ObjectDefinitionRegistry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/ObjectDefinitionRegistry */ "./node_modules/ui-framework-jps/dist/framework/model/ObjectDefinitionRegistry.js");

class CollectionUIConfigController {
    constructor() {
        this.stateManager = null;
        _model_ObjectDefinitionRegistry__WEBPACK_IMPORTED_MODULE_0__.ObjectDefinitionRegistry.getInstance().addDefinition(CollectionUIConfigController.STATE_NAME_UI_CONFIG, 'UI Config', true, false, false, "_id");
    }
    static getInstance() {
        if (!(CollectionUIConfigController._instance)) {
            CollectionUIConfigController._instance = new CollectionUIConfigController();
        }
        return CollectionUIConfigController._instance;
    }
    addUIConfigToRESTStateManager(applicationSM, restSM) {
        restSM.addConfig({
            stateName: CollectionUIConfigController.STATE_NAME_UI_CONFIG,
            serverURL: '',
            api: CollectionUIConfigController.API_UI_CONFIG,
            isActive: true,
            find: false,
            findAll: true,
            create: true,
            update: true,
            destroy: true
        });
        this.stateManager = applicationSM;
    }
    getUIConfig(viewId) {
        let result = null;
        if (this.stateManager) {
            result = this.stateManager.findItemInState(CollectionUIConfigController.STATE_NAME_UI_CONFIG, { _id: viewId });
        }
        return result;
    }
}
CollectionUIConfigController.STATE_NAME_UI_CONFIG = 'ui-config';
CollectionUIConfigController.API_UI_CONFIG = '/api/ui-config';
//# sourceMappingURL=CollectionUIConfigController.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/container/SidebarViewContainer.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/container/SidebarViewContainer.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SidebarViewContainer": () => (/* binding */ SidebarViewContainer)
/* harmony export */ });
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_1__);


const sbvcLogger = debug__WEBPACK_IMPORTED_MODULE_1___default()('sidebar-container');
class SidebarViewContainer {
    constructor(prefs) {
        this.bIsShowing = false;
        this.listeners = [];
        this.prefs = prefs;
        this.views = [];
        // event handlers
        this.hide = this.hide.bind(this);
        this.show = this.show.bind(this);
    }
    addVisibilityListener(listener) {
        this.listeners.push(listener);
    }
    addListener(listener) {
        throw new Error("Method not implemented.");
    }
    isShowing() {
        return this.bIsShowing;
    }
    addView(view, config) {
        sbvcLogger(`Adding view to container, with containing div of ${config.containerId}`);
        const viewContainer = document.getElementById(config.containerId);
        if (viewContainer) {
            sbvcLogger(`Adding view to container, with containing div of ${config.containerId} - FOUND`);
            view.setContainedBy(viewContainer);
        }
        this.views.push(view);
        view.addEventListener(this);
    }
    onDocumentLoaded() {
        // hide the side bar panel
        this.hide();
        this.listeners.forEach((listener) => listener.nowHidden(this));
        // add the event listener for the close button
        const sidePanelEl = document.getElementById(this.prefs.id);
        if (sidePanelEl === null)
            return;
        const closeButtonEl = sidePanelEl.querySelector('.close');
        if (closeButtonEl) {
            closeButtonEl.addEventListener('click', this.hide);
        }
        this.views.forEach((view) => {
            view.onDocumentLoaded();
        });
    }
    hide() {
        this.showHide('0%');
        this.views.forEach((view) => {
            view.hide();
        });
        this.bIsShowing = false;
        this.listeners.forEach((listener) => listener.nowHidden(this));
    }
    show() {
        let size = this.prefs.expandedSize;
        if (window.outerWidth < 769) {
            size = '50%';
        }
        if (window.outerWidth < 415) {
            size = '100%';
        }
        this.showHide(size);
        this.views.forEach((view) => {
            view.show();
        });
        this.bIsShowing = true;
        this.listeners.forEach((listener) => listener.nowShowing(this));
    }
    documentLoaded(view) {
    }
    itemAction(view, actionName, selectedItem) {
    }
    canDeleteItem(view, selectedItem) {
        return true;
    }
    itemDeleted(view, selectedItem) {
    }
    itemDragStarted(view, selectedItem) {
    }
    itemSelected(view, selectedItem) {
    }
    itemDeselected(view, selectedItem) {
    }
    itemDropped(view, droppedItem) {
    }
    showRequested(view) {
        this.show();
    }
    /*
      Contained views can request show and hide of the sidebar container
     */
    hideRequested(view) {
        this.hide();
    }
    canSelectItem(view, selectedItem) {
        return true;
    }
    collectionChanged(view) {
    }
    showHide(newStyleValue) {
        const sidePanelEl = document.getElementById(this.prefs.id);
        if (sidePanelEl === null)
            return;
        switch (this.prefs.location) {
            case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SidebarLocation.left: {
                sidePanelEl.style.width = newStyleValue;
                break;
            }
            case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SidebarLocation.right: {
                sidePanelEl.style.width = newStyleValue;
                break;
            }
            case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SidebarLocation.bottom: {
                sidePanelEl.style.height = newStyleValue;
                break;
            }
            case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.SidebarLocation.top: {
                sidePanelEl.style.height = newStyleValue;
                break;
            }
        }
    }
}
//# sourceMappingURL=SidebarViewContainer.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/container/TabularViewContainer.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/container/TabularViewContainer.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TabularViewContainer": () => (/* binding */ TabularViewContainer)
/* harmony export */ });
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../util/BrowserUtil */ "./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js");



const logger = debug__WEBPACK_IMPORTED_MODULE_1___default()('tabular-view-container');
class TabularViewContainer {
    constructor(config) {
        this.viewListeners = [];
        this.currentTabId = '';
        this.isVisible = false;
        this.config = config;
        this.views = [];
        this.tabs = [];
        this.listeners = [];
        this.tabElements = [];
        this.tabViewElements = [];
        this.handleTabClicked = this.handleTabClicked.bind(this);
    }
    addListener(listener) {
        this.listeners.push(listener);
    }
    addVisibilityListener(listener) {
        this.viewListeners.push(listener);
    }
    addViewToTab(tabId, view) {
        logger(`Adding view to tabular view, with containing tab of ${tabId}`);
        const foundIndex = this.config.tabs.findIndex((tab) => tab.id === tabId);
        if (foundIndex >= 0) {
            this.views.push({ tabId: tabId, view: view });
        }
    }
    onDocumentLoaded() {
        logger(`On document loaded`);
        const containedByEl = document.getElementById(this.config.containedById);
        if (containedByEl === null)
            return;
        logger(`Found contained by ${this.config.containedById} constructing elements`);
        // construct the tab view container and sub containers
        let tabViewContainerEl = document.createElement(this.config.tabularViewContainer.type);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(tabViewContainerEl, this.config.tabularViewContainer.attributes);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(tabViewContainerEl, this.config.tabularViewContainer.classes);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(tabViewContainerEl, [{ name: 'id', value: this.config.containerId }]);
        // construct the titlebar container
        let titleBarContainerEl = document.createElement(this.config.titleBarContainer.type);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(titleBarContainerEl, this.config.titleBarContainer.attributes);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(titleBarContainerEl, this.config.titleBarContainer.classes);
        tabViewContainerEl.append(titleBarContainerEl);
        // construct the item description container
        this.descriptionElement = document.createElement(this.config.itemDescriptionContainer.type);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(this.descriptionElement, this.config.itemDescriptionContainer.attributes);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(this.descriptionElement, this.config.itemDescriptionContainer.classes);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(this.descriptionElement, [{
                name: 'id',
                value: `${this.config.containerId}.description`
            }]);
        titleBarContainerEl.append(this.descriptionElement);
        // extra actions?
        if (this.config.titleBarActions) {
            let buttonContainerEl = titleBarContainerEl;
            if (this.config.titleBarActionsContainer) {
                let titleBarActionsContainerEl = document.createElement(this.config.titleBarActionsContainer.type);
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(titleBarActionsContainerEl, this.config.titleBarActionsContainer.attributes);
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(titleBarActionsContainerEl, this.config.titleBarActionsContainer.classes);
                titleBarContainerEl.append(titleBarActionsContainerEl);
                buttonContainerEl = titleBarActionsContainerEl;
            }
            this.config.titleBarActions.forEach((extraAction) => {
                let action = document.createElement('button');
                action.setAttribute('type', 'button');
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(action, extraAction.button.classes);
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(action, extraAction.button.attributes);
                if (extraAction.button.text) {
                    action.innerHTML = extraAction.button.text;
                }
                if (extraAction.button.iconClasses) {
                    let iconEl = document.createElement('i');
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, extraAction.button.iconClasses);
                    iconEl.setAttribute(_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.EXTRA_ACTION_ATTRIBUTE_NAME, extraAction.name);
                    action.appendChild(iconEl);
                }
                action.setAttribute(_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.EXTRA_ACTION_ATTRIBUTE_NAME, extraAction.name);
                action.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    this.listeners.forEach((listener) => listener.titleBarAction(this, extraAction.name));
                });
                buttonContainerEl.appendChild(action);
            });
        }
        // construct the tabs
        let tabBarContainerEl = document.createElement(this.config.tabBarContainer.type);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(tabBarContainerEl, this.config.tabBarContainer.attributes);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(tabBarContainerEl, this.config.tabBarContainer.classes);
        tabViewContainerEl.append(tabBarContainerEl);
        let tabBarEl = document.createElement(this.config.tabBarElement.type);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(tabBarEl, this.config.tabBarElement.attributes);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(tabBarEl, this.config.tabBarElement.classes);
        tabBarContainerEl.appendChild(tabBarEl);
        // create each item and add event handlers
        this.config.tabs.forEach((tab) => {
            logger(`Constructing tab ${tab.id} `);
            let tabEl = document.createElement(tab.element.type);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(tabEl, tab.element.attributes);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(tabEl, tab.element.classes);
            tabBarEl.appendChild(tabEl);
            if (tab.subElement) {
                let subTabEl = document.createElement(tab.subElement.type);
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(subTabEl, tab.subElement.attributes);
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(subTabEl, tab.subElement.classes);
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(subTabEl, [{ name: 'id', value: `${this.config.containerId}.tab.${tab.id}` }]);
                tabEl.appendChild(subTabEl);
                if (tab.subElement.innerHTML)
                    subTabEl.innerHTML = tab.subElement.innerHTML;
                subTabEl.addEventListener('click', this.handleTabClicked);
                if (tab.isDefaultActive) {
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(subTabEl, [{ name: 'active', value: 'true' }]);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(subTabEl, 'active');
                }
                else {
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].removeAttributes(subTabEl, ['active']);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].removeClasses(subTabEl, 'active');
                }
                this.tabElements.push(subTabEl);
                this.tabs.push({ tabId: tab.id, tabElement: subTabEl });
            }
            else {
                if (tab.element.innerHTML)
                    tabEl.innerHTML = tab.element.innerHTML;
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(tabEl, [{ name: 'id', value: `${this.config.containerId}.tab.${tab.id}` }]);
                tabEl.addEventListener('click', this.handleTabClicked);
                if (tab.isDefaultActive) {
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(tabEl, [{ name: 'active', value: 'true' }]);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(tabEl, 'active');
                }
                else {
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].removeAttributes(tabEl, ['active']);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].removeClasses(tabEl, 'active');
                }
                this.tabElements.push(tabEl);
                this.tabs.push({ tabId: tab.id, tabElement: tabEl });
            }
        });
        containedByEl.appendChild(tabViewContainerEl);
        // create the view containers and let the views know what contains them
        this.config.tabs.forEach((tab) => {
            logger(`Constructing tab ${tab.id} view`);
            // find the view and let it know about the containing element
            const foundIndex = this.views.findIndex((tabView) => tabView.tabId === tab.id);
            let view = null;
            if (foundIndex >= 0) {
                view = this.views[foundIndex].view;
            }
            let tabViewEl = document.createElement(this.config.tabViewContainer.type);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(tabViewEl, this.config.tabViewContainer.attributes);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(tabViewEl, this.config.tabViewContainer.classes);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(tabViewEl, [{ name: 'id', value: `${this.config.containerId}.view.${tab.id}` }]);
            tabViewContainerEl.appendChild(tabViewEl);
            if (view) {
                view.setContainedBy(tabViewEl);
                view.onDocumentLoaded();
            }
            if (tab.isDefaultActive) {
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].removeClasses(tabViewEl, 'd-none');
                if (view)
                    view.show();
                this.currentTabId = tab.id;
            }
            else {
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(tabViewEl, 'd-none');
                if (view)
                    view.hide();
            }
            this.tabViewElements.push(tabViewEl);
        });
    }
    handleTabClicked(event) {
        logger(`handling tab clicked`);
        event.stopPropagation();
        event.preventDefault();
        if (event.target) {
            const targetEl = (event.target);
            const targetId = targetEl.getAttribute('id');
            const targetActive = targetEl.getAttribute('active');
            logger(`Tab ${targetId} with active status ${targetActive}`);
            if (targetId) {
                const idComponents = targetId.split('.');
                const tabId = idComponents[idComponents.length - 1];
                logger(`tab id ${tabId} has been clicked`);
                if (targetActive) {
                    logger(`tab ${targetId} is already active - doing nothing`);
                }
                else {
                    logger(`tab ${targetId} is not active - setting active and letting the views know`);
                    this.selectTab(tabId);
                }
                // let the listeners know
                this.listeners.forEach((listener) => listener.tabChanged(this, tabId));
            }
        }
    }
    setDescription(description) {
        if (this.descriptionElement) {
            this.descriptionElement.innerHTML = description;
        }
    }
    selectTab(tabId) {
        this.currentTabId = tabId;
        this.tabElements.forEach((tabElement, index) => {
            const tabViewElement = this.tabViewElements[index];
            let tabElementId = tabElement.getAttribute('id');
            if (tabElementId) {
                const idComponents = tabElementId.split('.');
                const tabIdForTabElement = idComponents[idComponents.length - 1];
                const foundIndex = this.views.findIndex((tabView) => tabView.tabId === tabIdForTabElement);
                let view = null;
                if (foundIndex >= 0) {
                    view = this.views[foundIndex].view;
                }
                if (tabElementId) {
                    if (tabIdForTabElement === tabId) {
                        // mark the tab as active and let the view know
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(tabElement, [{ name: 'active', value: 'true' }]);
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].removeClasses(tabViewElement, 'd-none');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(tabElement, 'active');
                        if (view)
                            view.show();
                    }
                    else {
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].removeAttributes(tabElement, ['active']);
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(tabViewElement, 'd-none');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].removeClasses(tabElement, 'active');
                        if (view)
                            view.hide();
                    }
                }
            }
        });
    }
    show() {
        logger('TVC show');
        this.isVisible = true;
        this.selectTab(this.currentTabId);
        this.viewListeners.forEach((listener) => listener.nowShowing(this));
    }
    hide() {
        logger('TVC hide');
        this.isVisible = false;
        this.views.forEach((view) => {
            view.view.hide();
        });
        this.viewListeners.forEach((listener) => listener.nowHidden(this));
    }
    isShowing() {
        return false;
    }
}
//# sourceMappingURL=TabularViewContainer.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/context/ContextualInformationHelper.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/context/ContextualInformationHelper.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TogglePlacement": () => (/* binding */ TogglePlacement),
/* harmony export */   "ContextualInformationHelper": () => (/* binding */ ContextualInformationHelper)
/* harmony export */ });
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/BrowserUtil */ "./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _view_implementation_AbstractCollectionView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../view/implementation/AbstractCollectionView */ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractCollectionView.js");
/* harmony import */ var _helper_CollectionViewProcessor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helper/CollectionViewProcessor */ "./node_modules/ui-framework-jps/dist/framework/ui/helper/CollectionViewProcessor.js");





const logger = debug__WEBPACK_IMPORTED_MODULE_2___default()('context-helper');
var TogglePlacement;
(function (TogglePlacement) {
    TogglePlacement[TogglePlacement["top"] = 0] = "top";
    TogglePlacement[TogglePlacement["bottom"] = 1] = "bottom";
    TogglePlacement[TogglePlacement["right"] = 2] = "right";
    TogglePlacement[TogglePlacement["left"] = 3] = "left";
})(TogglePlacement || (TogglePlacement = {}));
const defaultIdentifier = function (name, item) {
    return '';
};
class ContextualInformationHelper {
    constructor() {
        this.registry = [];
        this.menuDivEl = null;
        this.menuContentEl = null;
        this.handleContextMenu = this.handleContextMenu.bind(this);
        this.hideContextMenu = this.hideContextMenu.bind(this);
    }
    static getInstance() {
        if (!(ContextualInformationHelper._instance)) {
            ContextualInformationHelper._instance = new ContextualInformationHelper();
        }
        return ContextualInformationHelper._instance;
    }
    onDocumentLoaded() {
        // @ts-ignore
        document.addEventListener('click', this.hideContextMenu);
        this.menuDivEl = document.getElementById('contextmenu');
        this.menuContentEl = document.getElementById('contextMenuItems');
    }
    addContextFromView(view, internalType, displayName) {
        let context = this.ensureInRegistry(view.getName());
        context.view = view;
        context.defaultType.internalType = internalType;
        context.defaultType.displayName = displayName;
        context.defaultType.identifier = view.getItemId;
        context.defaultType.description = view.getItemDescription;
        return context;
    }
    addContextToElement(source, type, item, element, addTooltip = false, placement = TogglePlacement.bottom) {
        const context = this.ensureInRegistry(source);
        element.setAttribute(ContextualInformationHelper.SOURCE, context.source);
        element.setAttribute(ContextualInformationHelper.TYPE, context.defaultType.internalType);
        element.setAttribute(ContextualInformationHelper.DISPLAYNAME, context.defaultType.displayName);
        element.setAttribute(ContextualInformationHelper.IDENTIFIER, context.defaultType.identifier(type, item));
        element.setAttribute(ContextualInformationHelper.DESCRIPTION, context.defaultType.description(type, item));
        if (addTooltip && !_util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].isMobileDevice()) {
            element.setAttribute(ContextualInformationHelper.BOOTSTRAP_TOGGLE, ContextualInformationHelper.BOOTSTRAP_TOOLTIP_VALUE);
            element.setAttribute(ContextualInformationHelper.BOOTSTRAP_TOGGLE_HTML, ContextualInformationHelper.BOOTSTRAP_TOGGLE_HTML_VALUE);
            switch (placement) {
                case TogglePlacement.bottom: {
                    element.setAttribute(ContextualInformationHelper.BOOTSTRAP_PLACEMENT, ContextualInformationHelper.BOOTSTRAP_PLACEMENT_BOTTOM);
                    break;
                }
                case TogglePlacement.top: {
                    element.setAttribute(ContextualInformationHelper.BOOTSTRAP_PLACEMENT, ContextualInformationHelper.BOOTSTRAP_PLACEMENT_TOP);
                    break;
                }
                case TogglePlacement.left: {
                    element.setAttribute(ContextualInformationHelper.BOOTSTRAP_PLACEMENT, ContextualInformationHelper.BOOTSTRAP_PLACEMENT_LEFT);
                    break;
                }
                case TogglePlacement.right: {
                    element.setAttribute(ContextualInformationHelper.BOOTSTRAP_PLACEMENT, ContextualInformationHelper.BOOTSTRAP_PLACEMENT_RIGHT);
                    break;
                }
            }
            // @ts-ignore
            $('[data-toggle="tooltip"]').tooltip({ html: true });
        }
    }
    findContextFromEvent(event) {
        let result = null;
        if (event.target) {
            let target = event.target;
            // @ts-ignore
            result = this.findContextFromElement(event.target);
        }
        return result;
    }
    addActionToContext(context, actionName, displayName, handler, icon, permissionCheck) {
        let action = {
            actionName: actionName,
            displayName: displayName,
            handler: handler,
            hasPermission: permissionCheck,
            elementDefinition: {
                type: 'a',
                attributes: [{ name: 'href', value: '#' }],
                classes: 'list-group-item list-group-item-action bg-dark text-white',
            },
            iconClasses: icon
        };
        this.addContextActionToContext(context, action);
    }
    handleContextMenu(event) {
        logger('Right click');
        logger(event.target);
        // are we over a context sensitive item?
        // find a context if possible
        // @ts-ignore
        const context = this.findContextFromElement(event.target);
        logger(context);
        if (context && this.buildContextMenu(context)) {
            event.preventDefault();
            event.stopPropagation();
            this.showContextMenu(event);
            return false;
        }
        // otherwise let the default behaviour happen
        return true;
    }
    ensureInRegistry(source) {
        let result;
        let foundIndex = this.registry.findIndex((context) => context.source === source);
        if (foundIndex < 0) {
            result = {
                source: source,
                defaultType: {
                    internalType: '',
                    displayName: '',
                    identifier: defaultIdentifier,
                    description: defaultIdentifier,
                    actions: []
                }
            };
            this.registry.push(result);
        }
        else {
            result = this.registry[foundIndex];
        }
        return result;
    }
    findContextFromElement(element) {
        // do we have context information in this element?
        let result = null;
        const source = element.getAttribute(ContextualInformationHelper.SOURCE);
        if (source) {
            const type = element.getAttribute(ContextualInformationHelper.TYPE);
            const name = element.getAttribute(ContextualInformationHelper.DISPLAYNAME);
            const id = element.getAttribute(ContextualInformationHelper.IDENTIFIER);
            const desc = element.getAttribute(ContextualInformationHelper.DESCRIPTION);
            // @ts-ignore
            result = { source: source, internalType: type, displayName: name, identifier: id, description: desc };
        }
        else {
            const parent = element.parentElement;
            if (parent) {
                result = this.findContextFromElement(parent);
            }
        }
        return result;
    }
    findAllContextsFromElement(element, contexts) {
        // do we have context information in this element?
        const source = element.getAttribute(ContextualInformationHelper.SOURCE);
        if (source) {
            const type = element.getAttribute(ContextualInformationHelper.TYPE);
            const name = element.getAttribute(ContextualInformationHelper.DISPLAYNAME);
            const id = element.getAttribute(ContextualInformationHelper.IDENTIFIER);
            const desc = element.getAttribute(ContextualInformationHelper.DESCRIPTION);
            // @ts-ignore
            if (type && name && id && desc) {
                let result = {
                    source: source,
                    internalType: type,
                    displayName: name,
                    identifier: id,
                    description: desc
                };
                contexts.push(result);
            }
        }
        const parent = element.parentElement;
        if (parent) {
            this.findAllContextsFromElement(parent, contexts);
        }
    }
    addContextActionToContext(context, action) {
        logger(`Adding action to context ${context.source}`);
        logger(action);
        context.defaultType.actions.push(action);
    }
    buildContextMenu(context) {
        logger(`building context menu`);
        let result = false;
        // find the context for these details
        const contextDef = this.ensureInRegistry(context.source);
        let selectedItem = null;
        if (contextDef && contextDef.view && (contextDef.view instanceof _view_implementation_AbstractCollectionView__WEBPACK_IMPORTED_MODULE_3__.AbstractCollectionView)) {
            logger(`collection view context - finding item with identifier ${context.identifier}`);
            let collectionView = (contextDef.view);
            let compareWith = {};
            // @ts-ignore
            compareWith[collectionView.getCollectionUIConfig().keyId] = context.identifier;
            selectedItem = collectionView.getItemInNamedCollection(context.internalType, compareWith);
        }
        logger(`found item for context menu`);
        logger(selectedItem);
        if (contextDef.defaultType.actions.length > 0) {
            if (this.menuContentEl && this.menuContentEl) {
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].removeAllChildren(this.menuContentEl);
                contextDef.defaultType.actions.forEach((action) => {
                    logger('Adding action');
                    logger(action);
                    if ((selectedItem && action.hasPermission && action.hasPermission(action.actionName, contextDef.defaultType.internalType, selectedItem)) ||
                        !(action.hasPermission)) {
                        let itemEl = document.createElement(action.elementDefinition.type);
                        if (itemEl && this.menuContentEl) {
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(itemEl, action.elementDefinition.attributes);
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(itemEl, action.elementDefinition.classes);
                            itemEl.setAttribute(ContextualInformationHelper.SOURCE, context.source);
                            itemEl.setAttribute(ContextualInformationHelper.TYPE, context.internalType);
                            itemEl.setAttribute(ContextualInformationHelper.DISPLAYNAME, context.displayName);
                            itemEl.setAttribute(ContextualInformationHelper.IDENTIFIER, context.identifier);
                            itemEl.setAttribute(ContextualInformationHelper.DESCRIPTION, context.description);
                            itemEl.setAttribute(_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.EXTRA_ACTION_ATTRIBUTE_NAME, action.actionName);
                            itemEl.addEventListener('click', (event) => {
                                this.hideContextMenu(event);
                                action.handler(event);
                            });
                            itemEl.innerHTML = `${action.displayName}`;
                            if (action.iconClasses) {
                                itemEl.innerHTML += `&nbsp;&nbsp;<i class="${action.iconClasses}"></i>`;
                            }
                            this.menuContentEl.appendChild(itemEl);
                            logger('new menu element is ');
                            logger(this.menuContentEl);
                            result = true;
                        }
                    }
                });
            }
        }
        else {
            logger(`building context menu - no actions for ${context.source}`);
        }
        return result;
    }
    hideContextMenu(event) {
        if (this.menuDivEl) {
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(this.menuDivEl, 'd-none');
        }
    }
    showContextMenu(event) {
        if (this.menuDivEl) {
            logger(`Showing context menu at ${event.pageX},${event.pageY}`);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].removeClasses(this.menuDivEl, 'd-none');
            this.menuDivEl.style.left = event.pageX + 'px';
            this.menuDivEl.style.top = event.pageY + 'px';
        }
    }
    insertDisplayElementForCollectionItem(view, renderer, containerEl, collectionName, item, prepend = false) {
        // make sure we are not inserting the same element twice
        const resultDataKeyId = view.getIdForItemInNamedCollection(collectionName, item);
        const uiConfig = view.getCollectionUIConfig();
        const querySelector = `${uiConfig.resultsElement.type}[${ContextualInformationHelper.IDENTIFIER}="${resultDataKeyId}"]`;
        let childEl = containerEl.querySelector(querySelector);
        if (!childEl) {
            let shouldDisplayTheNewItem = true;
            // is there a filter in place?
            if (view.hasFilter()) {
                const currentFilter = view.getCurrentFilter();
                if (currentFilter) {
                    if (!_helper_CollectionViewProcessor__WEBPACK_IMPORTED_MODULE_4__.CollectionViewProcessor.doesItemMatchFilterConfig(collectionName, item, currentFilter)) {
                        shouldDisplayTheNewItem = false;
                    }
                }
            }
            if (shouldDisplayTheNewItem) {
                logger(`view ${view.getName()}: inserting result`);
                childEl = renderer.createDisplayElementForCollectionItem(collectionName, item);
                if (prepend) {
                    const firstChildEl = containerEl.firstChild;
                    if (firstChildEl) {
                        containerEl.insertBefore(childEl, firstChildEl);
                    }
                    else {
                        containerEl.appendChild(childEl);
                    }
                }
                else {
                    containerEl.appendChild(childEl);
                }
                this.addContextToElement(view.getName(), collectionName, item, childEl, true);
                childEl.addEventListener('contextmenu', ContextualInformationHelper.getInstance().handleContextMenu);
            }
        }
        return childEl;
    }
    removeDisplayElementForCollectionItem(view, renderer, containerEl, collectionName, item) {
        const resultDataKeyId = view.getIdForItemInNamedCollection(collectionName, item);
        const uiConfig = view.getCollectionUIConfig();
        const querySelector = `${uiConfig.resultsElement.type}[${ContextualInformationHelper.IDENTIFIER}="${resultDataKeyId}"]`;
        logger(`view ${view.getName()}: removing result with query selector "${querySelector}"`);
        const childEl = containerEl.querySelector(querySelector);
        if (childEl) {
            containerEl.removeChild(childEl);
        }
    }
    updateDisplayElementForCollectionItem(view, renderer, containerEl, collectionName, item) {
        const resultDataKeyId = view.getIdForItemInNamedCollection(collectionName, item);
        const uiConfig = view.getCollectionUIConfig();
        const querySelector = `${uiConfig.resultsElement.type}[${ContextualInformationHelper.IDENTIFIER}="${resultDataKeyId}"]`;
        logger(`view ${view.getName()}: updating result with query selector "${querySelector}"`);
        const oldChildEl = containerEl.querySelector(querySelector);
        if (oldChildEl) {
            const newChildEl = renderer.createDisplayElementForCollectionItem(collectionName, item);
            containerEl.insertBefore(newChildEl, oldChildEl);
            containerEl.removeChild(oldChildEl);
            this.addContextToElement(view.getName(), collectionName, item, newChildEl, true);
            newChildEl.addEventListener('contextmenu', ContextualInformationHelper.getInstance().handleContextMenu);
        }
        else {
            this.insertDisplayElementForCollectionItem(view, renderer, containerEl, collectionName, item, true);
        }
    }
}
ContextualInformationHelper.SOURCE = 'context-source';
ContextualInformationHelper.TYPE = 'context-type';
ContextualInformationHelper.DISPLAYNAME = 'context-display-name';
ContextualInformationHelper.IDENTIFIER = 'context-id';
ContextualInformationHelper.DESCRIPTION = 'title';
ContextualInformationHelper.BOOTSTRAP_TOGGLE = 'data-toggle';
ContextualInformationHelper.BOOTSTRAP_PLACEMENT = 'data-placement';
ContextualInformationHelper.BOOTSTRAP_TOOLTIP_VALUE = 'tooltip';
ContextualInformationHelper.BOOTSTRAP_POPOVER_VALUE = 'popover';
ContextualInformationHelper.BOOTSTRAP_TOGGLE_HTML = 'data-html';
ContextualInformationHelper.BOOTSTRAP_TOGGLE_HTML_VALUE = 'true';
ContextualInformationHelper.BOOTSTRAP_PLACEMENT_TOP = 'top';
ContextualInformationHelper.BOOTSTRAP_PLACEMENT_BOTTOM = 'bottom';
ContextualInformationHelper.BOOTSTRAP_PLACEMENT_RIGHT = 'right';
ContextualInformationHelper.BOOTSTRAP_PLACEMENT_LEFT = 'left';
//# sourceMappingURL=ContextualInformationHelper.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/factory/FieldInputElementFactory.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/factory/FieldInputElementFactory.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FieldInputElementFactory": () => (/* binding */ FieldInputElementFactory)
/* harmony export */ });
/* harmony import */ var _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/BrowserUtil */ "./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js");
/* harmony import */ var _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/DataObjectTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectTypeDefs.js");
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");
/* harmony import */ var _ItemViewElementFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ItemViewElementFactory */ "./node_modules/ui-framework-jps/dist/framework/ui/factory/ItemViewElementFactory.js");


//import {Form} from "../Form";


class DefaultFieldOptionsListener {
    constructor(formId, parentElement, fieldUIConfig) {
        this.formId = formId;
        this.parentElement = parentElement;
        this.fieldUIConfig = fieldUIConfig;
    }
    optionsChanged(newOptions) {
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].removeAllChildren(this.parentElement);
        let subEls = FieldInputElementFactory.createSubElements(this.formId, this.parentElement, this.fieldUIConfig, newOptions);
    }
}
class FieldInputElementFactory {
    constructor() {
    }
    static getInstance() {
        if (!(FieldInputElementFactory._instance)) {
            FieldInputElementFactory._instance = new FieldInputElementFactory();
        }
        return FieldInputElementFactory._instance;
    }
    static getElementIdForFieldId(view, fieldId) {
        return `${view.getId()}.field.${fieldId}`;
    }
    static initialiseFieldElementAndEventHandlers(fieldElement, formId, fieldConfig, listeners, subElements = null) {
        fieldElement.setAttribute('id', `${formId}.field.${fieldConfig.field.id}`);
        fieldElement.setAttribute(_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.DATA_ID_ATTRIBUTE, fieldConfig.field.id);
        fieldElement.setAttribute('name', fieldConfig.field.id);
        if (fieldConfig.elementAttributes)
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(fieldElement, fieldConfig.elementAttributes);
        if (fieldConfig.elementClasses)
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(fieldElement, fieldConfig.elementClasses);
        // readonly field?
        if (fieldConfig.field.displayOnly) {
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(fieldElement, [{ name: 'disabled', value: 'true' }, {
                    name: 'readonly',
                    value: 'true'
                }]);
        }
        /*
        setup event handlers
        */
        // if (fieldConfig.validator) { // is the value in the field valid
        //     const eventHandler = new ValidationEventHandler(formId, fieldConfig, listeners, subElements);
        //     if (subElements) { // event for the subelements
        //         subElements.forEach((subElement) => {
        //             subElement.addEventListener('blur', eventHandler);
        //         });
        //
        //     } else {
        //         fieldElement.addEventListener('blur', eventHandler);
        //     }
        //
        // }
        // if (fieldConfig.editor) { // render the value when the field gains focus
        //     fieldElement.addEventListener('focus', new EditingEventListener(formId, fieldConfig, listeners));
        // } // care for endless loops here, renderer needs to return null if no changes
        // date picker for date fields
        if (fieldConfig.field.type === _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.date) {
            $(fieldElement).datepicker();
            $(fieldElement).datepicker("option", "dateFormat", 'dd/mm/yy');
        }
    }
    static createFieldComponentsAndContainer(fieldElement, formId, containerEl, fieldConfig, listeners, form, formConfig, itemListeners) {
        // if the field has a validator, then we need a div for error messages
        let errorMessageDivEl = null;
        if (fieldConfig.validator && fieldConfig.validator.messageDisplay) {
            errorMessageDivEl = document.createElement('div');
            errorMessageDivEl.setAttribute('id', `${formId}.field.${fieldConfig.field.id}.error`);
            errorMessageDivEl.setAttribute('style', 'display: none'); // default to not visible
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(errorMessageDivEl, fieldConfig.validator.messageDisplay.classes);
            let messageEl = document.createElement(fieldConfig.validator.messageDisplay.type);
            if (messageEl) {
                messageEl.setAttribute('id', `${formId}.field.${fieldConfig.field.id}.error.message`);
                if (fieldConfig.validator.messageDisplay.attributes)
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(messageEl, fieldConfig.validator.messageDisplay.attributes);
                errorMessageDivEl.appendChild(messageEl);
            }
        }
        // ok, so is the field contained?
        if (fieldConfig.containedBy) {
            // we need to create a container for the field and option label and description text
            let containedByEl = document.createElement(fieldConfig.containedBy.type);
            if (containedByEl) {
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(containedByEl, fieldConfig.containedBy.classes);
                containedByEl.setAttribute('id', `${formId}.field.${fieldConfig.field.id}.container`);
                if (fieldConfig.containedBy.attributes)
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(containerEl, fieldConfig.containedBy.attributes);
                // do we have a label also?
                if (fieldConfig.label) {
                    let labelEl = document.createElement('label');
                    labelEl.setAttribute('for', `${formId}.field.${fieldConfig.field.id}`);
                    labelEl.innerHTML = fieldConfig.field.displayName;
                    if (fieldConfig.label.attributes)
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(labelEl, fieldConfig.label.attributes);
                    if (fieldConfig.label.classes)
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(labelEl, fieldConfig.label.classes);
                    containedByEl.appendChild(labelEl);
                }
                if (fieldConfig.describedBy) {
                    let descEl = document.createElement(fieldConfig.describedBy.elementType);
                    if (descEl) {
                        // link the field and the description
                        descEl.setAttribute('id', `${formId}.field.${fieldConfig.field.id}.desc`);
                        if (fieldConfig.field.description)
                            descEl.innerHTML = fieldConfig.field.description;
                        fieldElement.setAttribute('aria-describedby', `${formId}.field.${fieldConfig.field.id}.desc`);
                        if (fieldConfig.describedBy.elementClasses)
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(descEl, fieldConfig.describedBy.elementClasses);
                        containedByEl.appendChild(fieldElement);
                        containedByEl.appendChild(descEl);
                        if (errorMessageDivEl)
                            containedByEl.appendChild(errorMessageDivEl);
                    }
                    else { // description failure, add the field
                        containedByEl.appendChild(fieldElement);
                        if (errorMessageDivEl)
                            containedByEl.appendChild(errorMessageDivEl);
                    }
                }
                else { // no description, add field to container
                    containedByEl.appendChild(fieldElement);
                    if (errorMessageDivEl)
                        containedByEl.appendChild(errorMessageDivEl);
                }
                containerEl.appendChild(containedByEl);
                // does the field have extra actions?
                if (form) {
                    if (formConfig) {
                        if (itemListeners) {
                            if (fieldConfig.extraActions) {
                                fieldConfig.extraActions.forEach((extraAction) => {
                                    const buttonEl = _ItemViewElementFactory__WEBPACK_IMPORTED_MODULE_3__.ItemViewElementFactory.getInstance().createButton(form, formConfig, itemListeners, extraAction.button, _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.FIELD_ACTION, fieldConfig.field.id, extraAction.name);
                                    containedByEl.appendChild(buttonEl);
                                });
                            }
                        }
                    }
                }
            }
            else { // errors should keep making something!
                containerEl.appendChild(fieldElement);
                if (errorMessageDivEl)
                    containerEl.appendChild(errorMessageDivEl);
            }
        }
        else {
            containerEl.appendChild(fieldElement);
            if (errorMessageDivEl)
                containerEl.appendChild(errorMessageDivEl);
        }
    }
    static createSubElements(formId, parentEl, fieldConfig, valueOptions) {
        let results = [];
        valueOptions.forEach((valueOption, index) => {
            if (fieldConfig.subElement) {
                let containerEl = parentEl;
                // is there a container?
                if (fieldConfig.subElement.container) {
                    containerEl = document.createElement(fieldConfig.subElement.container.type);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(containerEl, fieldConfig.subElement.container.classes);
                    if (fieldConfig.subElement.container.attributes)
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(containerEl, fieldConfig.subElement.container.attributes);
                    parentEl.appendChild(containerEl);
                }
                let valueEl = document.createElement(fieldConfig.subElement.element.type);
                valueEl.setAttribute('value', valueOption.value);
                valueEl.setAttribute('id', `${formId}.field.${fieldConfig.field.id}.${index}`);
                valueEl.setAttribute('name', `${formId}.field.${fieldConfig.field.id}`);
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(valueEl, fieldConfig.subElement.element.classes);
                if (fieldConfig.subElement.element.attributes)
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(valueEl, fieldConfig.subElement.element.attributes);
                containerEl.appendChild(valueEl);
                if (fieldConfig.subElement.label) {
                    let labelEl = document.createElement('label');
                    if (fieldConfig.subElement.label.classes)
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(labelEl, fieldConfig.subElement.label.classes);
                    if (fieldConfig.subElement.label.attributes)
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(labelEl, fieldConfig.subElement.label.attributes);
                    labelEl.innerHTML = valueOption.name;
                    containerEl.appendChild(labelEl);
                }
                else {
                    if (fieldConfig.elementType === _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.radioGroup) {
                        containerEl.innerHTML += valueOption.name;
                    }
                    else if (fieldConfig.elementType === _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.select) {
                        valueEl.innerText = valueOption.name;
                    }
                }
                results.push(valueEl);
            }
        });
        return results;
    }
    createInputFormFieldComponentElement(formId, containerEl, fieldConfig, listeners, form, formConfig, itemListeners) {
        let fieldElement = document.createElement('input');
        switch (fieldConfig.elementType) {
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.checkbox: {
                fieldElement.setAttribute('type', 'checkbox');
                fieldElement.setAttribute('value', fieldConfig.field.id);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.email: {
                fieldElement.setAttribute('type', 'email');
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.hidden: {
                fieldElement.setAttribute('type', 'hidden');
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.number: {
                fieldElement.setAttribute('type', 'number');
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.password: {
                fieldElement.setAttribute('type', 'password');
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.text: {
                fieldElement.setAttribute('type', 'text');
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.linkedList:
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.linked:
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.composite:
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.list: {
                fieldElement.setAttribute('type', 'hidden');
                break;
            }
        }
        FieldInputElementFactory.initialiseFieldElementAndEventHandlers(fieldElement, formId, fieldConfig, listeners);
        FieldInputElementFactory.createFieldComponentsAndContainer(fieldElement, formId, containerEl, fieldConfig, listeners, form, formConfig, itemListeners);
        return fieldElement;
    }
    createTAFormFieldComponentElement(formId, containerEl, fieldConfig, listeners, form, formConfig, itemListeners) {
        let fieldElement = document.createElement('textarea');
        if (fieldConfig.textarea) {
            fieldElement.setAttribute('rows', `${fieldConfig.textarea.rows}`);
            fieldElement.setAttribute('cols', `${fieldConfig.textarea.cols}`);
        }
        FieldInputElementFactory.initialiseFieldElementAndEventHandlers(fieldElement, formId, fieldConfig, listeners);
        FieldInputElementFactory.createFieldComponentsAndContainer(fieldElement, formId, containerEl, fieldConfig, listeners, form, formConfig, itemListeners);
        return fieldElement;
    }
    createSelectFormFieldComponentElement(formId, containerEl, fieldConfig, listeners, form, formConfig, itemListeners) {
        let fieldElement = document.createElement('select');
        // create the options from the data source
        if (fieldConfig.datasource) {
            FieldInputElementFactory.createSubElements(formId, fieldElement, fieldConfig, fieldConfig.datasource.getOptions());
            // listen for data source changes
            fieldConfig.datasource.addListener(new DefaultFieldOptionsListener(formId, fieldElement, fieldConfig));
        }
        FieldInputElementFactory.initialiseFieldElementAndEventHandlers(fieldElement, formId, fieldConfig, listeners);
        FieldInputElementFactory.createFieldComponentsAndContainer(fieldElement, formId, containerEl, fieldConfig, listeners, form, formConfig, itemListeners);
        return fieldElement;
    }
    createRadioGroupFormFieldComponentElement(formId, containerEl, fieldConfig, listeners, form, formConfig, itemListeners) {
        // create a div for each option in the source
        // create the div for the radio group
        let radioGroupElement = document.createElement('div');
        if (fieldConfig.elementAttributes)
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(radioGroupElement, fieldConfig.elementAttributes);
        if (fieldConfig.elementClasses)
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(radioGroupElement, fieldConfig.elementClasses);
        let subElements = [];
        // create the options from the data source
        if (fieldConfig.datasource) {
            // we should get the radio buttons back
            subElements = FieldInputElementFactory.createSubElements(formId, radioGroupElement, fieldConfig, fieldConfig.datasource.getOptions());
            // listen for data source changes
            fieldConfig.datasource.addListener(new DefaultFieldOptionsListener(formId, radioGroupElement, fieldConfig));
            // setup the subelements for the validator, formatter, and renderer
            if (fieldConfig.validator)
                fieldConfig.validator.validator.setSubElements(subElements);
            if (fieldConfig.renderer)
                fieldConfig.renderer.setSubElements(subElements);
            if (fieldConfig.formatter)
                fieldConfig.formatter.setSubElements(subElements);
        }
        FieldInputElementFactory.initialiseFieldElementAndEventHandlers(radioGroupElement, formId, fieldConfig, listeners, subElements);
        FieldInputElementFactory.createFieldComponentsAndContainer(radioGroupElement, formId, containerEl, fieldConfig, listeners, form, formConfig, itemListeners);
        return {
            container: radioGroupElement,
            radioButtons: subElements
        };
    }
    createCompositeFormFieldComponentElement(form, formConfig, itemListeners, containerEl, fieldConfig, listeners) {
        const formId = form.getId();
        const displayElement = document.createElement('input');
        displayElement.setAttribute('type', 'text');
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(displayElement, [{ name: 'disabled', value: 'true' }, {
                name: 'readonly',
                value: 'true'
            }]);
        if (fieldConfig.elementAttributes)
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(displayElement, fieldConfig.elementAttributes);
        if (fieldConfig.elementClasses)
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(displayElement, fieldConfig.elementClasses);
        let buttonElements = [];
        // create the options from the data source
        if (fieldConfig.extraActions) {
            fieldConfig.extraActions.forEach((extraAction) => {
                const buttonEl = _ItemViewElementFactory__WEBPACK_IMPORTED_MODULE_3__.ItemViewElementFactory.getInstance().createButton(form, formConfig, itemListeners, extraAction.button, _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.COMPOSITE_EDIT, fieldConfig.field.id);
                buttonElements.push(buttonEl);
            });
        }
        FieldInputElementFactory.initialiseFieldElementAndEventHandlers(displayElement, formId, fieldConfig, listeners);
        FieldInputElementFactory.createFieldComponentsAndContainer(displayElement, formId, containerEl, fieldConfig, listeners, form, formConfig, itemListeners);
        return {
            displayElement: displayElement,
            actionButtons: buttonElements
        };
    }
    createCompositeArrayFormFieldComponentElement(form, formConfig, itemListeners, containerEl, fieldConfig, listeners) {
        const formId = form.getId();
        const displayElement = document.createElement('ul');
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(displayElement, [{ name: 'disabled', value: 'true' }, {
                name: 'readonly',
                value: 'true'
            }]);
        if (fieldConfig.elementAttributes)
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(displayElement, fieldConfig.elementAttributes);
        if (fieldConfig.elementClasses)
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(displayElement, fieldConfig.elementClasses);
        let buttonElements = [];
        // create the options from the data source
        if (fieldConfig.extraActions) {
            fieldConfig.extraActions.forEach((extraAction) => {
                const buttonEl = _ItemViewElementFactory__WEBPACK_IMPORTED_MODULE_3__.ItemViewElementFactory.getInstance().createButton(form, formConfig, itemListeners, extraAction.button, _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.COMPOSITE_ARRAY_EDIT, fieldConfig.field.id);
                buttonElements.push(buttonEl);
            });
        }
        FieldInputElementFactory.initialiseFieldElementAndEventHandlers(displayElement, formId, fieldConfig, listeners);
        FieldInputElementFactory.createFieldComponentsAndContainer(displayElement, formId, containerEl, fieldConfig, listeners);
        return {
            displayElement: displayElement,
            actionButtons: buttonElements
        };
    }
    createLinkedFormFieldComponentElement(form, formConfig, itemListeners, containerEl, fieldConfig, listeners) {
        const formId = form.getId();
        const displayElement = document.createElement('input');
        displayElement.setAttribute('type', 'text');
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(displayElement, [{ name: 'disabled', value: 'true' }, {
                name: 'readonly',
                value: 'true'
            }]);
        if (fieldConfig.elementAttributes)
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(displayElement, fieldConfig.elementAttributes);
        if (fieldConfig.elementClasses)
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(displayElement, fieldConfig.elementClasses);
        let buttonElements = [];
        // create the options from the data source
        if (fieldConfig.extraActions) {
            fieldConfig.extraActions.forEach((extraAction) => {
                const buttonEl = _ItemViewElementFactory__WEBPACK_IMPORTED_MODULE_3__.ItemViewElementFactory.getInstance().createButton(form, formConfig, itemListeners, extraAction.button, _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.LINKED_EDIT, fieldConfig.field.id);
                buttonElements.push(buttonEl);
            });
        }
        FieldInputElementFactory.initialiseFieldElementAndEventHandlers(displayElement, formId, fieldConfig, listeners);
        FieldInputElementFactory.createFieldComponentsAndContainer(displayElement, formId, containerEl, fieldConfig, listeners);
        return {
            displayElement: displayElement,
            actionButtons: buttonElements
        };
    }
    createLinkedArrayFormFieldComponentElement(form, formConfig, itemListeners, containerEl, fieldConfig, listeners) {
        const formId = form.getId();
        const displayElement = document.createElement('ul');
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(displayElement, [{ name: 'disabled', value: 'true' }, {
                name: 'readonly',
                value: 'true'
            }]);
        if (fieldConfig.elementAttributes)
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(displayElement, fieldConfig.elementAttributes);
        if (fieldConfig.elementClasses)
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(displayElement, fieldConfig.elementClasses);
        let buttonElements = [];
        // create the options from the data source
        if (fieldConfig.extraActions) {
            fieldConfig.extraActions.forEach((extraAction) => {
                const buttonEl = _ItemViewElementFactory__WEBPACK_IMPORTED_MODULE_3__.ItemViewElementFactory.getInstance().createButton(form, formConfig, itemListeners, extraAction.button, _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.LINKED_ARRAY_EDIT, fieldConfig.field.id);
                buttonElements.push(buttonEl);
            });
        }
        FieldInputElementFactory.initialiseFieldElementAndEventHandlers(displayElement, formId, fieldConfig, listeners);
        FieldInputElementFactory.createFieldComponentsAndContainer(displayElement, formId, containerEl, fieldConfig, listeners);
        return {
            displayElement: displayElement,
            actionButtons: buttonElements
        };
    }
}
//# sourceMappingURL=FieldInputElementFactory.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/factory/ItemViewElementFactory.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/factory/ItemViewElementFactory.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ItemViewElementFactory": () => (/* binding */ ItemViewElementFactory)
/* harmony export */ });
/* harmony import */ var _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/BrowserUtil */ "./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js");
/* harmony import */ var _FieldInputElementFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FieldInputElementFactory */ "./node_modules/ui-framework-jps/dist/framework/ui/factory/FieldInputElementFactory.js");
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");




class ItemViewElementFactory {
    constructor() {
    }
    static getInstance() {
        if (!(ItemViewElementFactory._instance)) {
            ItemViewElementFactory._instance = new ItemViewElementFactory();
        }
        return ItemViewElementFactory._instance;
    }
    createFormElements(form, listeners, formConfig, fieldListeners) {
        const formId = form.getId();
        let formEl = document.createElement('form');
        formEl.setAttribute('id', formId);
        formEl.setAttribute('name', formConfig.displayName);
        if (formConfig.classes)
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(formEl, formConfig.classes);
        // create each of the fields and collect them
        let formInputElements = [];
        let formTAElements = [];
        let formRBGElements = [];
        let formSelectElements = [];
        let formCompositeElements = [];
        let formCompositeArrayElements = [];
        let formLinkedElements = [];
        let formLinkedArrayElements = [];
        let unsavedMessage = undefined;
        if (formConfig.unsavedChanges) {
            unsavedMessage = document.createElement(formConfig.unsavedChanges.type);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(unsavedMessage, formConfig.unsavedChanges.classes);
            if (formConfig.unsavedChanges.attributes)
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(unsavedMessage, formConfig.unsavedChanges.attributes);
            formEl.appendChild(unsavedMessage);
        }
        let buttons = {
            deleteButton: undefined,
            cancelButton: undefined,
            saveButton: undefined
        };
        if (formConfig.buttonPosition === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_3__.ElementLocation.top) {
            buttons = this.createButtons(formConfig, formEl, form, listeners);
        }
        formConfig.fieldGroups.forEach((group) => {
            // if the group has a container make that, otherwise the form is the container
            let containerEl = formEl;
            if (group.containedBy) {
                // @ts-ignore
                containerEl = document.createElement(group.containedBy.type);
                if (containerEl) {
                    if (group.containedBy.attributes)
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(containerEl, group.containedBy.attributes);
                    if (group.containedBy.classes)
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(containerEl, group.containedBy.classes);
                    formEl.appendChild(containerEl);
                }
            }
            group.fields.forEach((field) => {
                switch (field.elementType) {
                    case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.textarea): {
                        const fieldEl = _FieldInputElementFactory__WEBPACK_IMPORTED_MODULE_1__.FieldInputElementFactory.getInstance().createTAFormFieldComponentElement(formId, containerEl, field, fieldListeners, form, formConfig, listeners);
                        formTAElements.push(fieldEl);
                        break;
                    }
                    case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.select): {
                        const fieldEl = _FieldInputElementFactory__WEBPACK_IMPORTED_MODULE_1__.FieldInputElementFactory.getInstance().createSelectFormFieldComponentElement(formId, containerEl, field, fieldListeners, form, formConfig, listeners);
                        formSelectElements.push(fieldEl);
                        break;
                    }
                    case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.radioGroup): {
                        const fieldEl = _FieldInputElementFactory__WEBPACK_IMPORTED_MODULE_1__.FieldInputElementFactory.getInstance().createRadioGroupFormFieldComponentElement(formId, containerEl, field, fieldListeners, form, formConfig, listeners);
                        formRBGElements.push(fieldEl);
                        break;
                    }
                    case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.composite):
                    case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.list):
                    case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.linked):
                    case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.linkedList):
                    default: {
                        const fieldEl = _FieldInputElementFactory__WEBPACK_IMPORTED_MODULE_1__.FieldInputElementFactory.getInstance().createInputFormFieldComponentElement(formId, containerEl, field, fieldListeners, form, formConfig, listeners);
                        formInputElements.push(fieldEl);
                    }
                }
            });
            if (group.subGroups) {
                group.subGroups.forEach((subGroup) => {
                    let subContainerEl = containerEl;
                    if (subGroup.containedBy) {
                        // @ts-ignore
                        subContainerEl = document.createElement(subGroup.containedBy.type);
                        if (subContainerEl) {
                            if (subGroup.containedBy.attributes)
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(subContainerEl, subGroup.containedBy.attributes);
                            if (subGroup.containedBy.classes)
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(subContainerEl, subGroup.containedBy.classes);
                            containerEl.appendChild(subContainerEl);
                        }
                    }
                    subGroup.fields.forEach((field) => {
                        switch (field.elementType) {
                            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.textarea): {
                                const fieldEl = _FieldInputElementFactory__WEBPACK_IMPORTED_MODULE_1__.FieldInputElementFactory.getInstance().createTAFormFieldComponentElement(formId, subContainerEl, field, fieldListeners, form, formConfig, listeners);
                                formTAElements.push(fieldEl);
                                break;
                            }
                            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.select): {
                                const fieldEl = _FieldInputElementFactory__WEBPACK_IMPORTED_MODULE_1__.FieldInputElementFactory.getInstance().createSelectFormFieldComponentElement(formId, subContainerEl, field, fieldListeners, form, formConfig, listeners);
                                formSelectElements.push(fieldEl);
                                break;
                            }
                            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.radioGroup): {
                                const fieldEl = _FieldInputElementFactory__WEBPACK_IMPORTED_MODULE_1__.FieldInputElementFactory.getInstance().createRadioGroupFormFieldComponentElement(formId, subContainerEl, field, fieldListeners, form, formConfig, listeners);
                                formRBGElements.push(fieldEl);
                                break;
                            }
                            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.composite):
                            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.list):
                            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.linked):
                            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.linkedList):
                            default: {
                                const fieldEl = _FieldInputElementFactory__WEBPACK_IMPORTED_MODULE_1__.FieldInputElementFactory.getInstance().createInputFormFieldComponentElement(formId, subContainerEl, field, fieldListeners, form, formConfig, listeners);
                                formInputElements.push(fieldEl);
                            }
                        }
                    });
                });
            }
        });
        if (formConfig.buttonPosition !== _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_3__.ElementLocation.top) {
            buttons = this.createButtons(formConfig, formEl, form, listeners);
        }
        let result = {
            top: formEl,
            unsavedMessage: unsavedMessage,
            fields: formInputElements,
            selectFields: formSelectElements,
            radioButtonGroups: formRBGElements,
            compositeFields: formCompositeElements,
            compositeArrayFields: formCompositeArrayElements,
            linkedFields: formLinkedElements,
            linkedArrayFields: formLinkedArrayElements,
            textFields: formTAElements,
            buttons: buttons
        };
        return result;
    }
    createButtons(formConfig, formEl, form, listeners) {
        let buttons = {
            deleteButton: undefined,
            cancelButton: undefined,
            saveButton: undefined
        };
        /* setup the buttons */
        let buttonContainer = formEl;
        if (formConfig.buttonsContainedBy) {
            buttonContainer = document.createElement(formConfig.buttonsContainedBy.type);
            if (buttonContainer) {
                if (formConfig.buttonsContainedBy.attributes)
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(buttonContainer, formConfig.buttonsContainedBy.attributes);
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(buttonContainer, formConfig.buttonsContainedBy.classes);
                formEl.appendChild(buttonContainer);
            }
            else {
                buttonContainer = formEl; // couldn't create the button container, use the form
            }
        }
        if (formConfig.deleteButton) {
            buttons.deleteButton = this.createButton(form, formConfig, listeners, formConfig.deleteButton, _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.DELETING);
            buttonContainer.appendChild(buttons.deleteButton);
        }
        if (formConfig.cancelButton) {
            buttons.cancelButton = this.createButton(form, formConfig, listeners, formConfig.cancelButton, _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.CANCELLING);
            buttonContainer.appendChild(buttons.cancelButton);
        }
        if (formConfig.saveButton) {
            buttons.saveButton = this.createButton(form, formConfig, listeners, formConfig.saveButton, _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.SAVING);
            buttonContainer.appendChild(buttons.saveButton);
        }
        return buttons;
    }
    createTableRowElements(itemId, view, listeners, config, fieldListeners) {
        let rowEl = document.createElement('tr');
        // create each of the fields and collect them
        let rowInputElements = [];
        let rowSelectElements = [];
        let rowTAElements = [];
        let rowRBGElements = [];
        let rowCompositeElements = [];
        config.fieldGroups.forEach((group) => {
            // if the group has a container make that, otherwise the form is the container
            let containerEl = rowEl;
            group.fields.forEach((field) => {
                switch (field.elementType) {
                    case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.UIFieldType.select): {
                        const fieldEl = _FieldInputElementFactory__WEBPACK_IMPORTED_MODULE_1__.FieldInputElementFactory.getInstance().createSelectFormFieldComponentElement(itemId, containerEl, field, fieldListeners);
                        rowSelectElements.push(fieldEl);
                        break;
                    }
                    default: {
                        const fieldEl = _FieldInputElementFactory__WEBPACK_IMPORTED_MODULE_1__.FieldInputElementFactory.getInstance().createInputFormFieldComponentElement(itemId, containerEl, field, fieldListeners);
                        rowInputElements.push(fieldEl);
                    }
                }
            });
        });
        let result = {
            top: rowEl,
            fields: rowInputElements,
            selectFields: rowSelectElements,
            textFields: rowTAElements,
            radioButtonGroups: rowRBGElements,
            compositeFields: rowCompositeElements
        };
        return result;
    }
    createButton(form, formConfig, listeners, buttonDef, eventType, fieldId, actionName) {
        const formId = form.getId();
        let buttonEl = document.createElement('button');
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(buttonEl, buttonDef.classes);
        buttonEl.setAttribute('id', `${formId}.${eventType}`);
        if (buttonDef.text) {
            buttonEl.innerText = buttonDef.text;
        }
        if (buttonDef.iconClasses) {
            let iconEl = document.createElement('i');
            if (iconEl) {
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(iconEl, buttonDef.iconClasses);
                buttonEl.appendChild(iconEl);
            }
        }
        /* setup the event handler for the button */
        buttonEl.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            let itemEvent = {
                target: form,
                identifier: formConfig.id,
                fieldId: fieldId,
                eventType: eventType,
                actionName: actionName,
                currentDataObj: form.getCurrentDataObj()
            };
            if (eventType === _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.FIELD_ACTION) {
                listeners.forEach((listener) => listener.fieldAction(formConfig.displayName, itemEvent));
            }
            else {
                listeners.forEach((listener) => listener.itemViewEvent(formConfig.displayName, itemEvent));
            }
        });
        return buttonEl;
    }
}
//# sourceMappingURL=ItemViewElementFactory.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/field/AbstractField.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/field/AbstractField.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractField": () => (/* binding */ AbstractField)
/* harmony export */ });
/* harmony import */ var _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/DataObjectTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectTypeDefs.js");
/* harmony import */ var _event_handlers_ValidationEventHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event-handlers/ValidationEventHandler */ "./node_modules/ui-framework-jps/dist/framework/ui/field/event-handlers/ValidationEventHandler.js");
/* harmony import */ var _event_handlers_RenderingEventListener__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event-handlers/RenderingEventListener */ "./node_modules/ui-framework-jps/dist/framework/ui/field/event-handlers/RenderingEventListener.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _event_handlers_EditingEventListener__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./event-handlers/EditingEventListener */ "./node_modules/ui-framework-jps/dist/framework/ui/field/event-handlers/EditingEventListener.js");
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");






const logger = debug__WEBPACK_IMPORTED_MODULE_3___default()('abstract-field');
class AbstractField {
    constructor(view, config, fieldDef, element, subElements = null) {
        this.config = null;
        this.subElements = [];
        this.listeners = [];
        this.hidden = false;
        this.view = view;
        this.formId = view.getId();
        this.config = config;
        this.definition = fieldDef;
        this.element = element;
        if (subElements)
            this.subElements = subElements;
        this.validationHandler = new _event_handlers_ValidationEventHandler__WEBPACK_IMPORTED_MODULE_1__.ValidationEventHandler(view, config, [this], subElements);
        this.renderingHandler = new _event_handlers_RenderingEventListener__WEBPACK_IMPORTED_MODULE_2__.RenderingEventListener(view, this, config, [this], subElements);
        const editingHandler = new _event_handlers_EditingEventListener__WEBPACK_IMPORTED_MODULE_4__.EditingEventListener(view, this, config, [this]);
        if (config.editor) { // render the value when the field gains focus
            this.element.addEventListener('focus', editingHandler.handleEditEvent);
            this.element.addEventListener('blur', editingHandler.handleEditCompletedEvent);
            this.element.addEventListener('click', editingHandler.handleEditEvent);
        }
        if (config.validator) { // is the value in the field valid
            const eventHandler = new _event_handlers_ValidationEventHandler__WEBPACK_IMPORTED_MODULE_1__.ValidationEventHandler(this.view, config, this.listeners, subElements);
            if (subElements && subElements.length > 0) { // event for the subelements
                subElements.forEach((subElement) => {
                    subElement.addEventListener('blur', eventHandler);
                });
            }
            else {
                this.element.addEventListener('blur', eventHandler);
            }
        }
        // listen for our own change events
        this.handleChangeEvent = this.handleChangeEvent.bind(this);
        if (this.subElements && (this.subElements.length > 0)) {
            logger(`Adding change listeners to subelements of ${config.field.id}`);
            this.subElements.forEach((subElement) => {
                subElement.addEventListener('change', this.handleChangeEvent);
            });
        }
        else {
            this.element.addEventListener('change', this.handleChangeEvent);
        }
        this.bEmitEvents = true;
    }
    isHidden() {
        return this.hidden;
    }
    addFieldListener(listener) {
        logger(`${this.getName()} - adding listener ${listener.getName()}`);
        // don't duplicate listeners
        let index = this.listeners.findIndex((listenerInList) => listenerInList.getName() === listener.getName());
        if (index < 0) {
            this.listeners.push(listener);
        }
        else {
            logger(`${this.getName()} - duplicate listener ${listener.getName()} ignored`);
        }
    }
    getFieldDefinition() {
        return this.definition;
    }
    setInvalid(message) {
        this.validationHandler.setValidationStatusAndMessage(this.element, false, '', message, false);
        // @ts-ignore
        this.listeners.forEach((listener) => listener.failedValidation(this.formId, this.definition, this.getValue(), message));
    }
    initialise() {
    }
    getValue() {
        let result = null;
        if (this.config && this.element) {
            // derived values are calculated from the data object overall
            if (this.definition.derivedValue) {
                result = this.definition.derivedValue.getValue(this.view.getCurrentDataObj(), this.definition, this.view.getViewMode() === _CommonTypes__WEBPACK_IMPORTED_MODULE_5__.ViewMode.create);
            }
            else {
                switch (this.config.elementType) {
                    case (_CommonTypes__WEBPACK_IMPORTED_MODULE_5__.UIFieldType.radioGroup): {
                        logger(`${this.definition.id} - getting value - rbg`);
                        if (this.subElements && (this.subElements.length > 0)) {
                            this.subElements.forEach((subElement) => {
                                if (subElement.checked) {
                                    logger(`${this.definition.id} - getting value - rbg - checked ${subElement.value}`);
                                    result = subElement.value;
                                    subElement.checked = true;
                                }
                            });
                        }
                        break;
                    }
                    case (_CommonTypes__WEBPACK_IMPORTED_MODULE_5__.UIFieldType.checkbox): {
                        // @ts-ignore
                        result = '' + this.element.checked;
                        break;
                    }
                    default: {
                        // @ts-ignore
                        result = this.element.value;
                        break;
                    }
                }
            }
        }
        logger(`${this.definition.id} - getting value - ${result}`);
        return result;
    }
    getFormattedValue() {
        let result = null;
        if (this.config && this.element) {
            // @ts-ignore
            result = this.element.value;
            if (this.config.elementType === _CommonTypes__WEBPACK_IMPORTED_MODULE_5__.UIFieldType.checkbox) { // @ts-ignore
                result = '' + this.element.checked;
            }
            if (this.config.formatter) {
                result = this.config.formatter.formatValue(this.definition, result);
            }
        }
        return result;
    }
    isValid() {
        let result = true;
        if (this.config && this.element) {
            if (this.config.validator) {
                if (this.config.validator.validator) {
                    const validator = this.config.validator.validator;
                    const response = validator.isValidValue(this.definition, this.getValue());
                    result = response.isValid;
                }
            }
        }
        return result;
    }
    getId() {
        return this.definition.id;
    }
    setValue(newValue) {
        if (this.element && this.config) {
            // derived fields have no "setter"
            if (this.definition.derivedValue) {
                newValue = this.definition.derivedValue.setValue(this.view.getCurrentDataObj(), this.definition, this.view.getViewMode() === _CommonTypes__WEBPACK_IMPORTED_MODULE_5__.ViewMode.create, newValue);
            }
            // @ts-ignore
            switch (this.config.elementType) {
                case (_CommonTypes__WEBPACK_IMPORTED_MODULE_5__.UIFieldType.radioGroup): {
                    newValue = '' + newValue;
                    if (this.subElements && (this.subElements.length > 0)) {
                        this.subElements.forEach((subElement) => {
                            if (subElement.value === newValue) {
                                subElement.checked = true;
                            }
                        });
                    }
                    break;
                }
                case (_CommonTypes__WEBPACK_IMPORTED_MODULE_5__.UIFieldType.checkbox): {
                    newValue = '' + newValue;
                    // @ts-ignore
                    this.element.checked = (newValue.toLowerCase() === 'true');
                    break;
                }
                case (_CommonTypes__WEBPACK_IMPORTED_MODULE_5__.UIFieldType.select): {
                    newValue = '' + newValue;
                    logger(`${this.definition.id} - setting value - ${newValue}`);
                    const selectEl = this.element;
                    let selectedIndex = -1;
                    for (let index = 0; index < selectEl.options.length; index++) {
                        // @ts-ignore
                        const option = selectEl.options.item(index);
                        logger(`${this.definition.id} - option value - ${option.value}`);
                        if (option.value === newValue) {
                            logger(`${this.definition.id} - option value - ${option.value} - SELECTED`);
                            option.selected = true;
                            selectedIndex = index;
                        }
                    }
                    logger(`${this.definition.id} - selected index ${selectedIndex}`);
                    selectEl.selectedIndex = selectedIndex;
                    break;
                }
                default: {
                    logger(`${this.definition.id} - setting value - ${newValue}`);
                    newValue = '' + newValue;
                    // @ts-ignore
                    this.element.value = newValue;
                    break;
                }
            }
        }
    }
    reset() {
        if (this.element) {
            switch (this.definition.type) {
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.boolean): {
                    // @ts-ignore
                    this.element.checked = false;
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.integer): {
                    // @ts-ignore
                    this.element.value = '0';
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.float): {
                    // @ts-ignore
                    this.element.value = '0.0';
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.limitedChoice): {
                    if (this.subElements && (this.subElements.length > 0)) {
                        this.subElements.forEach((subElement) => {
                            subElement.checked = false;
                        });
                    }
                    break;
                }
                default: {
                    // @ts-ignore
                    this.element.value = '';
                    break;
                }
            }
        }
        this.show();
    }
    clearValue() {
        this.reset();
    }
    validate() {
        if (this.element) {
            this.validationHandler.processValidation(this.element);
        }
    }
    render(currentValue) {
        var _a;
        let result = currentValue;
        if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.renderer) {
            let value = this.config.renderer.renderValue(this, this.definition, currentValue);
            if (value)
                result = value;
        }
        return result;
    }
    failedValidation(view, field, currentValue, message) {
    }
    valueChanged(view, field, fieldDef, newValue) {
    }
    getName() {
        return this.definition.displayName;
    }
    hide() {
        /*
          if we have an enclosing container (per the config) then we can hide
          otherwise we become readonly and disabled
         */
        if (this.config) {
            if (this.config.containedBy) {
                const parentEl = this.element.parentElement;
                if (parentEl) {
                    parentEl.setAttribute('style', 'display:none');
                }
            }
            else {
                this.setReadOnly();
            }
        }
        this.hidden = true;
    }
    setValid() {
        this.validationHandler.setValidationStatusAndMessage(this.element, true, '');
    }
    show() {
        /*
          if we have an enclosing container (per the config) then we can hide
          otherwise we become readonly and disabled
         */
        if (this.config) {
            if (this.config.containedBy) {
                const parentEl = this.element.parentElement;
                if (parentEl) {
                    parentEl.removeAttribute('style');
                }
            }
            else {
                this.clearReadOnly();
            }
        }
        this.hidden = true;
    }
    clearReadOnly() {
        if (this.definition.displayOnly)
            return;
        this.element.removeAttribute('readonly');
        this.element.removeAttribute('disabled');
        // do the same for subelements
        if (this.subElements && (this.subElements.length > 0)) {
            this.subElements.forEach((subElement) => {
                subElement.removeAttribute('readonly');
                subElement.removeAttribute('disabled');
            });
        }
    }
    setReadOnly() {
        this.element.setAttribute('readonly', 'true');
        this.element.setAttribute('disabled', 'true');
        // do the same for subelements
        if (this.subElements && (this.subElements.length > 0)) {
            this.subElements.forEach((subElement) => {
                subElement.setAttribute('readonly', 'true');
                subElement.setAttribute('disabled', 'true');
            });
        }
    }
    getElement() {
        return this.element;
    }
    emitEvents() {
        this.bEmitEvents = true;
    }
    suppressEvents() {
        this.bEmitEvents = false;
    }
    handleChangeEvent(event) {
        logger(`Handling change event`);
        if (this.config && this.bEmitEvents) {
            let value = this.getValue();
            logger(`Handling change event - informing listeners`);
            this.listeners.forEach((listener) => listener.valueChanged(this.view, this, this.definition, value));
        }
    }
}
//# sourceMappingURL=AbstractField.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/field/ColourInputField.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/field/ColourInputField.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColourInputField": () => (/* binding */ ColourInputField)
/* harmony export */ });
/* harmony import */ var _AbstractField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractField */ "./node_modules/ui-framework-jps/dist/framework/ui/field/AbstractField.js");
/* harmony import */ var _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/BrowserUtil */ "./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _util_MiscFunctions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../util/MiscFunctions */ "./node_modules/ui-framework-jps/dist/framework/util/MiscFunctions.js");




const logger = debug__WEBPACK_IMPORTED_MODULE_2___default()('colour-input-field');
class ColourInputField extends _AbstractField__WEBPACK_IMPORTED_MODULE_0__.AbstractField {
    constructor(view, config, fieldDef, element) {
        super(view, config, fieldDef, element);
        this.setValue = this.setValue.bind(this);
    }
    setValue(newValue) {
        logger(`Setting background style to colour ${newValue}`);
        super.setValue(newValue);
        // special case of colour types
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].removeAttributes(this.element, ["style"]);
        let styleOptions = [{ name: "style", value: `background-color:${newValue};colour:black` }];
        if ((0,_util_MiscFunctions__WEBPACK_IMPORTED_MODULE_3__.isHexValueDark)(newValue)) {
            styleOptions = [{ name: "style", value: `background-color:${newValue};color:white` }];
        }
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(this.element, styleOptions);
    }
}
//# sourceMappingURL=ColourInputField.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/field/InputField.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/field/InputField.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InputField": () => (/* binding */ InputField)
/* harmony export */ });
/* harmony import */ var _AbstractField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractField */ "./node_modules/ui-framework-jps/dist/framework/ui/field/AbstractField.js");

class InputField extends _AbstractField__WEBPACK_IMPORTED_MODULE_0__.AbstractField {
    constructor(view, config, fieldDef, element) {
        super(view, config, fieldDef, element);
    }
}
//# sourceMappingURL=InputField.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/field/RadioButtonGroupField.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/field/RadioButtonGroupField.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RadioButtonGroupField": () => (/* binding */ RadioButtonGroupField)
/* harmony export */ });
/* harmony import */ var _AbstractField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractField */ "./node_modules/ui-framework-jps/dist/framework/ui/field/AbstractField.js");

class RadioButtonGroupField extends _AbstractField__WEBPACK_IMPORTED_MODULE_0__.AbstractField {
    constructor(view, config, fieldDef, element, subElements) {
        super(view, config, fieldDef, element, subElements);
    }
}
//# sourceMappingURL=RadioButtonGroupField.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/field/SelectField.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/field/SelectField.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectField": () => (/* binding */ SelectField)
/* harmony export */ });
/* harmony import */ var _AbstractField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractField */ "./node_modules/ui-framework-jps/dist/framework/ui/field/AbstractField.js");

class SelectField extends _AbstractField__WEBPACK_IMPORTED_MODULE_0__.AbstractField {
    constructor(view, config, fieldDef, element) {
        super(view, config, fieldDef, element);
    }
}
//# sourceMappingURL=SelectField.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/field/TextAreaField.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/field/TextAreaField.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextAreaField": () => (/* binding */ TextAreaField)
/* harmony export */ });
/* harmony import */ var _AbstractField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractField */ "./node_modules/ui-framework-jps/dist/framework/ui/field/AbstractField.js");

class TextAreaField extends _AbstractField__WEBPACK_IMPORTED_MODULE_0__.AbstractField {
    constructor(view, config, fieldDef, element) {
        super(view, config, fieldDef, element);
    }
}
//# sourceMappingURL=TextAreaField.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/field/event-handlers/EditingEventListener.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/field/event-handlers/EditingEventListener.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EditingEventListener": () => (/* binding */ EditingEventListener)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);

const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('editing-event-listener');
class EditingEventListener {
    constructor(view, field, fieldConfig, listeners) {
        this.view = view;
        this.formId = view.getId();
        this.field = field;
        this.fieldConfig = fieldConfig;
        this.listeners = listeners;
        this.handleEditEvent = this.handleEditEvent.bind(this);
        this.handleEditCompletedEvent = this.handleEditCompletedEvent.bind(this);
    }
    handleEditEvent(event) {
        event.preventDefault();
        event.stopPropagation();
        // @ts-ignore
        const fieldElement = event.target;
        if (this.fieldConfig.editor) {
            const fieldDef = this.fieldConfig.field;
            logger(fieldDef);
            const value = fieldElement.value;
            logger(value);
            const newValue = this.fieldConfig.editor.editValue(this.field, fieldDef, value);
            if (newValue && (newValue !== value)) {
                fieldElement.value = newValue;
                this.listeners.forEach((listener) => listener.valueChanged(this.view, this.field, fieldDef, newValue));
            }
        }
    }
    handleEditCompletedEvent(event) {
        event.preventDefault();
        event.stopPropagation();
        if (this.fieldConfig.editor) {
            const fieldDef = this.fieldConfig.field;
            this.fieldConfig.editor.editCompleted(this.field, fieldDef);
        }
    }
}
//# sourceMappingURL=EditingEventListener.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/field/event-handlers/RenderingEventListener.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/field/event-handlers/RenderingEventListener.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RenderingEventListener": () => (/* binding */ RenderingEventListener)
/* harmony export */ });
class RenderingEventListener {
    constructor(view, field, fieldConfig, listeners, subElements = null) {
        this.view = view;
        this.formId = view.getId();
        this.field = field;
        this.fieldConfig = fieldConfig;
        this.listeners = listeners;
        this.subElements = subElements;
        this.handleEvent = this.handleEvent.bind(this);
    }
    processRendering(fieldElement) {
        let newValue = '';
        if (this.fieldConfig.renderer) {
            const fieldDef = this.fieldConfig.field;
            const value = fieldElement.value;
            if (this.subElements)
                this.fieldConfig.renderer.setSubElements(this.subElements);
            newValue = this.fieldConfig.renderer.renderValue(this.field, fieldDef, value);
            if (newValue) {
                fieldElement.value = newValue;
                this.listeners.forEach((listener) => listener.valueChanged(this.view, this.field, fieldDef, newValue));
            }
        }
        if (newValue) {
            return newValue;
        }
        else {
            return '';
        }
    }
    handleEvent(event) {
        event.preventDefault();
        event.stopPropagation();
        // @ts-ignore
        const fieldElement = event.target;
        this.processRendering(fieldElement);
    }
}
//# sourceMappingURL=RenderingEventListener.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/field/event-handlers/ValidationEventHandler.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/field/event-handlers/ValidationEventHandler.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ValidationEventHandler": () => (/* binding */ ValidationEventHandler)
/* harmony export */ });
/* harmony import */ var _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../model/DataObjectTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectTypeDefs.js");
/* harmony import */ var _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/BrowserUtil */ "./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");




const logger = debug__WEBPACK_IMPORTED_MODULE_2___default()('validation-event-handler');
class ValidationEventHandler {
    constructor(view, fieldConfig, listeners, subElements = null) {
        this.view = view;
        this.formId = view.getId();
        this.fieldConfig = fieldConfig;
        this.listeners = listeners;
        this.subElements = subElements;
        this.handleEvent = this.handleEvent.bind(this);
    }
    setValidationStatusAndMessage(fieldElement, isValid, value, message = undefined, resetOnFailure = false) {
        logger(`Handling validation for field ${this.fieldConfig.field.id}: ${isValid} with message ${message}`);
        logger(this.fieldConfig);
        if (this.fieldConfig.validator && fieldElement) {
            logger(`Handling validation for field ${this.fieldConfig.field.id}: ${isValid} with message ${message} - have validator and element`);
            const field = this.fieldConfig.field;
            let validationElementTarget = fieldElement; // we are providing user feedback on the field element, unless...
            if (this.subElements) { // sub elements change the validation target
                this.fieldConfig.validator.validator.setSubElements(this.subElements);
                if (this.fieldConfig.subElement) { // should be targeting the parent element
                    let parentEl = fieldElement.parentElement;
                    if (parentEl) {
                        validationElementTarget = parentEl;
                        if (this.fieldConfig.subElement.container) { // another layer up required
                            parentEl = parentEl.parentElement;
                            if (parentEl) {
                                validationElementTarget = parentEl;
                            }
                        }
                    }
                }
            }
            // let divId = `${this.view.getDataObjectDefinition().id}.field.${this.fieldConfig.field.id}.error`
            let divId = `${this.formId}.field.${this.fieldConfig.field.id}.error`;
            logger(`Handling validation for field ${this.fieldConfig.field.id}: ${isValid} with message ${message} - div is ${divId}`);
            const errorMessageDiv = document.getElementById(divId);
            const errorMessageEl = document.getElementById(`${divId}.message`);
            // clear any previous message
            errorMessageDiv === null || errorMessageDiv === void 0 ? void 0 : errorMessageDiv.setAttribute('style', 'display:none');
            if (errorMessageEl)
                errorMessageEl.innerHTML = '';
            if (this.fieldConfig.validator.invalidClasses)
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].removeClasses(validationElementTarget, this.fieldConfig.validator.invalidClasses);
            if (this.fieldConfig.validator.validClasses)
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(validationElementTarget, this.fieldConfig.validator.validClasses);
            if (!isValid) {
                if (this.fieldConfig.validator.invalidClasses)
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(validationElementTarget, this.fieldConfig.validator.invalidClasses);
                if (this.fieldConfig.validator.validClasses)
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].removeClasses(validationElementTarget, this.fieldConfig.validator.validClasses);
                if (!message) {
                    message = `${field.displayName} does not have a valid value.`;
                }
                // show the error message
                errorMessageDiv === null || errorMessageDiv === void 0 ? void 0 : errorMessageDiv.setAttribute('style', 'display:block');
                if (errorMessageEl)
                    errorMessageEl.innerHTML = message;
                if (resetOnFailure) {
                    switch (field.type) {
                        case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.boolean): {
                            // @ts-ignore
                            fieldElement.checked = false;
                            break;
                        }
                        case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.integer): {
                            // @ts-ignore
                            fieldElement.value = '0';
                            break;
                        }
                        case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.float): {
                            // @ts-ignore
                            fieldElement.value = '0.0';
                            break;
                        }
                        default: {
                            // @ts-ignore
                            fieldElement.value = '';
                            break;
                        }
                    }
                }
                // @ts-ignore
                this.listeners.forEach((listener) => listener.failedValidation(this.formId, field, value, message));
            }
        }
    }
    processValidation(fieldElement) {
        if (this.fieldConfig.validator && fieldElement) {
            const field = this.fieldConfig.field;
            // @ts-ignore
            let value = fieldElement.value;
            // checkboxes store values differently
            if (this.fieldConfig.elementType === _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.UIFieldType.checkbox) { // @ts-ignore
                value = '' + fieldElement.checked;
            }
            if (this.subElements) {
                value = '';
                this.subElements.forEach((subElement) => {
                    if (subElement.checked) {
                        value = subElement.value;
                    }
                });
            }
            const validationResp = this.fieldConfig.validator.validator.isValidValue(field, value);
            this.setValidationStatusAndMessage(fieldElement, validationResp.isValid, value, validationResp.message, validationResp.resetOnFailure);
        }
    }
    handleEvent(event) {
        event.preventDefault();
        event.stopPropagation();
        // @ts-ignore
        const fieldElement = event.target;
        this.processValidation(fieldElement);
    }
}
//# sourceMappingURL=ValidationEventHandler.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/file-upload/FileUploadListener.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/file-upload/FileUploadListener.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FileUploadType": () => (/* binding */ FileUploadType)
/* harmony export */ });
var FileUploadType;
(function (FileUploadType) {
    FileUploadType[FileUploadType["cancelled"] = 0] = "cancelled";
    FileUploadType[FileUploadType["uploaded"] = 1] = "uploaded";
})(FileUploadType || (FileUploadType = {}));
//# sourceMappingURL=FileUploadListener.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/file-upload/FileUploadManager.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/file-upload/FileUploadManager.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FileUploadManager": () => (/* binding */ FileUploadManager)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _FileUploadListener__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FileUploadListener */ "./node_modules/ui-framework-jps/dist/framework/ui/file-upload/FileUploadListener.js");
/* harmony import */ var _network_ApiUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../network/ApiUtil */ "./node_modules/ui-framework-jps/dist/framework/network/ApiUtil.js");
/* harmony import */ var _security_SecurityManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../security/SecurityManager */ "./node_modules/ui-framework-jps/dist/framework/security/SecurityManager.js");
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");
/* harmony import */ var _key_binding_manager_KeyBindingManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../key-binding-manager/KeyBindingManager */ "./node_modules/ui-framework-jps/dist/framework/ui/key-binding-manager/KeyBindingManager.js");






const DEFAULT_FILE_UPLOAD_MODAL_ID = 'file-upload';
const DEFAULT_FILE_UPLOAD_FORM_ID = 'file-upload-form';
const DEFAULT_FILE_UPLOAD_TITLE = 'file-upload-title';
const DEFAULT_FILE_UPLOAD_CLOSE = 'file-upload-close';
const DEFAULT_FILE_UPLOAD_CANCEL = 'file-upload-cancel';
const DEFAULT_FILE_UPLOAD_UPLOAD = 'file-upload-upload';
const FILE_UPLOAD_hideClass = "d-none";
const FILE_UPLOAD_showClass = "d-block";
const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('file-upload');
class FileUploadManager {
    constructor(config) {
        this.fileUploadDiv = document.getElementById(config.modalDivId);
        this.fileUploadTitle = document.getElementById(config.titleId);
        this.cancelButton = document.getElementById(config.cancelButtonId);
        this.closeButton = document.getElementById(config.closeButtonId);
        this.uploadButton = document.getElementById(config.uploadButtonId);
        this.fileUploadForm = document.getElementById(config.formId);
        this.startUpload = this.startUpload.bind(this);
        this.confirmHandler = this.confirmHandler.bind(this);
        this.cancelHandler = this.cancelHandler.bind(this);
        this.keyActionEvent = this.keyActionEvent.bind(this);
        this.fileUploadForm.addEventListener('submit', this.confirmHandler);
        this.cancelButton.addEventListener('click', this.cancelHandler);
        this.closeButton.addEventListener('click', this.cancelHandler);
        const keyBindingConfig = {
            contextName: 'File Upload',
            receiver: this,
            keyBindings: [
                {
                    controlKeyRequired: false,
                    metaKeyRequired: false,
                    shiftKeyRequired: false,
                    altKeyRequired: false,
                    keyCode: 'Enter',
                    actionName: _CommonTypes__WEBPACK_IMPORTED_MODULE_4__.BasicKeyAction.ok
                },
                {
                    controlKeyRequired: false,
                    metaKeyRequired: false,
                    shiftKeyRequired: false,
                    altKeyRequired: false,
                    keyCode: 'Escape',
                    actionName: _CommonTypes__WEBPACK_IMPORTED_MODULE_4__.BasicKeyAction.cancel
                }
            ]
        };
        _key_binding_manager_KeyBindingManager__WEBPACK_IMPORTED_MODULE_5__.KeyBindingManager.getInstance().addContextKeyBindings(keyBindingConfig);
    }
    keyActionEvent(event) {
        switch (event.actionName) {
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_4__.BasicKeyAction.ok: {
                this.confirmHandler(null);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_4__.BasicKeyAction.cancel: {
                this.cancelHandler(null);
                break;
            }
        }
    }
    static getInstance() {
        if (!(FileUploadManager._instance)) {
            FileUploadManager._instance = new FileUploadManager({
                modalDivId: DEFAULT_FILE_UPLOAD_MODAL_ID,
                titleId: DEFAULT_FILE_UPLOAD_TITLE,
                cancelButtonId: DEFAULT_FILE_UPLOAD_CANCEL,
                uploadButtonId: DEFAULT_FILE_UPLOAD_UPLOAD,
                formId: DEFAULT_FILE_UPLOAD_FORM_ID,
                closeButtonId: DEFAULT_FILE_UPLOAD_CLOSE
            });
        }
        return FileUploadManager._instance;
    }
    hide() {
        this.fileUploadDiv.classList.add(FILE_UPLOAD_hideClass);
        this.fileUploadDiv.classList.remove(FILE_UPLOAD_showClass);
        _key_binding_manager_KeyBindingManager__WEBPACK_IMPORTED_MODULE_5__.KeyBindingManager.getInstance().deactivateContext('File Upload');
    }
    show() {
        this.fileUploadDiv.classList.remove(FILE_UPLOAD_hideClass);
        this.fileUploadDiv.classList.add(FILE_UPLOAD_showClass);
        _key_binding_manager_KeyBindingManager__WEBPACK_IMPORTED_MODULE_5__.KeyBindingManager.getInstance().activateContext('File Upload');
    }
    startUpload(config) {
        this.fileUploadTitle.innerHTML = config.title;
        this.config = config;
        this.show();
    }
    cancelHandler(event) {
        logger(`Handling cancel event from file upload`);
        this.hide();
        this.config.listener.fileUploadCompleted({ outcome: _FileUploadListener__WEBPACK_IMPORTED_MODULE_1__.FileUploadType.cancelled, result: this.config.context });
    }
    confirmHandler(event) {
        if (event)
            event.preventDefault();
        logger(`Handling submit event from file upload`);
        const callbackHandler = (data, status, context) => {
            this.config.listener.fileUploadCompleted({ outcome: _FileUploadListener__WEBPACK_IMPORTED_MODULE_1__.FileUploadType.uploaded, result: data, context: context });
        };
        // @ts-ignore
        let body = new FormData(event.target);
        this.config.additionalParametersFromContent.forEach((name) => {
            const contextValue = this.config.context[name];
            if (contextValue) {
                body.append(name, contextValue);
            }
        });
        let request = {
            url: this.config.url,
            body: body,
            callback: callbackHandler,
            context: this.config.context
        };
        if (_security_SecurityManager__WEBPACK_IMPORTED_MODULE_3__.SecurityManager.getInstance().callsRequireToken()) {
            request.jwt = _security_SecurityManager__WEBPACK_IMPORTED_MODULE_3__.SecurityManager.getInstance().getToken();
        }
        _network_ApiUtil__WEBPACK_IMPORTED_MODULE_2__.ApiUtil.getInstance().simplePOSTFormData(request);
        this.hide();
    }
}
//# sourceMappingURL=FileUploadManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/form/BasicFormImplementation.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/form/BasicFormImplementation.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BasicFormImplementation": () => (/* binding */ BasicFormImplementation)
/* harmony export */ });
/* harmony import */ var _view_item_DefaultItemView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../view/item/DefaultItemView */ "./node_modules/ui-framework-jps/dist/framework/ui/view/item/DefaultItemView.js");

class BasicFormImplementation extends _view_item_DefaultItemView__WEBPACK_IMPORTED_MODULE_0__.DefaultItemView {
    constructor(containerId, dataObjDef, configHelper, permissionChecker, hasExternalControl = false) {
        super(containerId, dataObjDef, configHelper, permissionChecker, hasExternalControl);
    }
}
//# sourceMappingURL=BasicFormImplementation.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/helper/BootstrapFormConfigHelper.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/helper/BootstrapFormConfigHelper.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BootstrapFormConfigHelper": () => (/* binding */ BootstrapFormConfigHelper)
/* harmony export */ });
/* harmony import */ var _model_BasicFieldOperations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/BasicFieldOperations */ "./node_modules/ui-framework-jps/dist/framework/model/BasicFieldOperations.js");
/* harmony import */ var _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/DataObjectTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectTypeDefs.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _RBGFieldOperations__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RBGFieldOperations */ "./node_modules/ui-framework-jps/dist/framework/ui/helper/RBGFieldOperations.js");
/* harmony import */ var _model_BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../model/BasicObjectDefinitionFactory */ "./node_modules/ui-framework-jps/dist/framework/model/BasicObjectDefinitionFactory.js");
/* harmony import */ var _ColourEditor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ColourEditor */ "./node_modules/ui-framework-jps/dist/framework/ui/helper/ColourEditor.js");
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");







const logger = debug__WEBPACK_IMPORTED_MODULE_2___default()('bootstrap-form-config-helper');
class BootstrapFormConfigHelper {
    constructor() {
    }
    static getInstance() {
        if (!(BootstrapFormConfigHelper._instance)) {
            BootstrapFormConfigHelper._instance = new BootstrapFormConfigHelper();
        }
        return BootstrapFormConfigHelper._instance;
    }
    generateConfig(dataObjDef, runtimeConfig) {
        let fieldOperations = new _model_BasicFieldOperations__WEBPACK_IMPORTED_MODULE_0__.BasicFieldOperations();
        let rbgFieldOperation = new _RBGFieldOperations__WEBPACK_IMPORTED_MODULE_3__.RBGFieldOperations();
        // create a form with a single group and button container with Bootstrap styles
        let fieldGroup = {
            containedBy: {
                type: 'div',
                classes: 'col-sm-12',
            },
            fields: []
        };
        let shouldAutoScroll = true;
        if (!runtimeConfig.autoscrollOnNewContent) {
            shouldAutoScroll = false;
        }
        const formConfig = {
            id: dataObjDef.id,
            displayName: dataObjDef.displayName,
            fieldGroups: [fieldGroup],
            unsavedChanges: {
                type: 'div',
                classes: 'invalid-feedback text-right col-md-12 col-lg-9 offset-lg-3',
                attributes: [{ name: 'style', value: 'display:block' }],
                innerHTML: `Pending changes to ${dataObjDef.displayName}`,
            },
            buttonPosition: runtimeConfig.buttonLocation,
            autoscrollOnNewContent: shouldAutoScroll,
        };
        // create the Field UI config for each field
        let fieldUIConfigs = [];
        dataObjDef.fields.forEach((fieldDef, index) => {
            let fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.text;
            switch (fieldDef.type) {
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.time):
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.text):
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.date):
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.shortTime):
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.colour):
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.duration): {
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.datetime): {
                    // is this the created or modified date
                    if (runtimeConfig.hideModifierFields) {
                        if (fieldDef.id === _model_BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_4__.FIELD_CreatedOn) {
                            fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.hidden;
                        }
                        if (fieldDef.id === _model_BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_4__.FIELD_ModifiedOn) {
                            fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.hidden;
                        }
                    }
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.userId): {
                    if (runtimeConfig.hideModifierFields) {
                        fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.hidden;
                    }
                    else {
                        fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.text;
                    }
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.uuid):
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.id): {
                    fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.hidden;
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.integer):
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.float): {
                    fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.number;
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.email): {
                    fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.email;
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.password): {
                    fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.password;
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.boolean): {
                    fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.checkbox;
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.largeText): {
                    fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.textarea;
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.choice): {
                    fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.select;
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.limitedChoice): {
                    fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.radioGroup;
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.compositeObjectArray): {
                    fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.list;
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.compositeObject): {
                    fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.composite;
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.linkedObject): {
                    fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.linked;
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.linkedObjectArray): {
                    fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.linkedList;
                    break;
                }
            }
            // see if the field was supplied with a display order
            const displayOrder = runtimeConfig.fieldDisplayOrders.find((value) => value.fieldId === fieldDef.id);
            let displayOrderValue = index;
            if (displayOrder) {
                displayOrderValue = displayOrder.displayOrder;
            }
            // construct the field ui config
            let fieldUIConfig = {
                field: fieldDef,
                displayOrder: displayOrderValue,
                elementType: fieldType,
                elementClasses: 'form-control col-sm-9',
                renderer: fieldOperations,
                formatter: fieldOperations,
                getValue: _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.defaultGetValue
            };
            if ((fieldDef.type !== _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.id) && (fieldDef.type !== _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.uuid) && (fieldType !== _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.hidden) && (fieldType !== _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.list) && (fieldType !== _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.composite) && (fieldType !== _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.linked) && (fieldType !== _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.UIFieldType.linkedList)) { // no labels, descriptions, container for id,uuid
                fieldUIConfig.containedBy = {
                    type: 'div',
                    classes: 'form-group row'
                };
                fieldUIConfig.label = {
                    label: fieldDef.displayName,
                    classes: 'col-md-12 col-lg-3 col-form-label'
                };
                if (fieldDef.description) { // descriptions if the field has one
                    fieldUIConfig.describedBy = {
                        message: fieldDef.description,
                        elementType: 'small',
                        elementClasses: 'text-muted col-md-12 col-lg-9 offset-lg-3 mt-1'
                    };
                }
                if (!fieldDef.displayOnly) { // no validator for readonly items
                    fieldUIConfig.validator = {
                        validator: fieldOperations,
                        messageDisplay: {
                            type: 'div',
                            classes: 'invalid-feedback col-md-12 col-lg-9 offset-lg-3'
                        },
                        validClasses: 'is-valid',
                        invalidClasses: 'is-invalid',
                    };
                }
            }
            // text areas
            if (fieldDef.type === _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.largeText) {
                fieldUIConfig.textarea = {
                    rows: 5,
                    cols: 20
                };
            }
            // select
            if (fieldDef.type === _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.choice) { // subelements are options, with no classes, no labels, and no other container
                fieldUIConfig.subElement = {
                    element: { type: 'option', classes: '' },
                };
                fieldUIConfig.datasource = fieldDef.dataSource;
            }
            // composite object (single)
            // if (fieldDef.type === FieldType.compositeObject) { // subelements are options, with no classes, no labels, and no other container
            //     fieldUIConfig.extraActions = [
            //         {
            //             name:'Edit',
            //             button: {
            //                 classes:'btn bg-primary',
            //                 iconClasses:'fas fa-edit'
            //             },
            //             confirm:false
            //         }
            //     ]
            //     fieldUIConfig.validator = undefined;
            // }
            // // composite object (array)
            // if (fieldDef.type === FieldType.compositeObjectArray) { // subelements are options, with no classes, no labels, and no other container
            //     fieldUIConfig.subElement = {
            //         element: {
            //             type: 'li',
            //             classes: 'list-group-item'
            //         },
            //         container: {
            //             type: 'div',
            //             classes: 'form-check form-check-inline'
            //         },
            //     };
            //     fieldUIConfig.extraActions = [
            //         {
            //             name:'Edit',
            //             button: {
            //                 classes:'btn bg-primary',
            //                 iconClasses:'fas fa-edit'
            //             },
            //             confirm:false
            //         }
            //     ]
            //     fieldUIConfig.renderer = undefined;
            //     fieldUIConfig.validator = undefined;
            //     fieldUIConfig.formatter = undefined;
            // }
            // // composite object (single)
            // if (fieldDef.type === FieldType.linkedObject) { // subelements are options, with no classes, no labels, and no other container
            //     fieldUIConfig.extraActions = [
            //         {
            //             name:'Edit',
            //             button: {
            //                 classes:'btn bg-primary',
            //                 iconClasses:'fas fa-edit'
            //             },
            //             confirm:false
            //         }
            //     ]
            //     fieldUIConfig.renderer = undefined;
            //     fieldUIConfig.validator = undefined;
            //     fieldUIConfig.formatter = undefined;
            // }
            // // composite object (array)
            // if (fieldDef.type === FieldType.linkedObjectArray) { // subelements are options, with no classes, no labels, and no other container
            //     fieldUIConfig.subElement = {
            //         element: {
            //             type: 'li',
            //             classes: 'list-group-item'
            //         },
            //         container: {
            //             type: 'div',
            //             classes: 'form-check form-check-inline'
            //         },
            //     };
            //     fieldUIConfig.extraActions = [
            //         {
            //             name:'Edit',
            //             button: {
            //                 classes:'btn bg-primary',
            //                 iconClasses:'fas fa-edit'
            //             },
            //             confirm:false
            //         }
            //     ]
            //     fieldUIConfig.renderer = undefined;
            //     fieldUIConfig.validator = undefined;
            //     fieldUIConfig.formatter = undefined;
            // }
            // radio button group
            if (fieldDef.type === _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.limitedChoice) {
                fieldUIConfig.subElement = {
                    element: {
                        type: 'input',
                        classes: 'form-check-input',
                        attributes: [{ name: 'type', value: 'radio' }]
                    },
                    container: {
                        type: 'div',
                        classes: 'form-check form-check-inline'
                    },
                    label: {
                        label: 'label',
                        classes: 'form-check-label',
                    },
                };
                fieldUIConfig.renderer = rbgFieldOperation;
                if (fieldUIConfig.validator)
                    fieldUIConfig.validator.validator = rbgFieldOperation;
                fieldUIConfig.formatter = rbgFieldOperation;
                fieldUIConfig.datasource = fieldDef.dataSource;
            }
            if (fieldDef.type === _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.colour) {
                fieldUIConfig.editor = new _ColourEditor__WEBPACK_IMPORTED_MODULE_5__.ColourEditor(BootstrapFormConfigHelper.COLOUR_PICKER_CONTAINER);
            }
            // see if the field was supplied with a field runtime
            if (runtimeConfig.fieldRuntimeConfigs) {
                const fieldRuntime = runtimeConfig.fieldRuntimeConfigs.find((runtimeField) => runtimeField.fieldId === fieldUIConfig.field.id);
                if (fieldRuntime) {
                    if (fieldRuntime.containedBy && fieldUIConfig.containedBy) {
                        fieldUIConfig.containedBy = fieldRuntime.containedBy;
                    }
                    if (fieldRuntime.validator) {
                        if (fieldUIConfig.validator)
                            fieldUIConfig.validator.validator = fieldRuntime.validator;
                    }
                    if (fieldRuntime.label) {
                        if (fieldRuntime.label.labelPosition === _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.FieldLabelPosition.noLabel) {
                            fieldUIConfig.label = undefined;
                            if (fieldUIConfig.containedBy) {
                                fieldUIConfig.containedBy.classes = 'form-group row';
                            }
                            else {
                                fieldUIConfig.elementClasses = 'form-control';
                            }
                        }
                        if (fieldRuntime.label.labelPosition === _CommonTypes__WEBPACK_IMPORTED_MODULE_6__.FieldLabelPosition.aboveField) {
                            if (fieldUIConfig.containedBy) {
                                fieldUIConfig.containedBy.classes = 'form-group row';
                            }
                        }
                        if (fieldRuntime.label.label) {
                            if (fieldUIConfig.label)
                                fieldUIConfig.label.label = fieldRuntime.label.label;
                        }
                    }
                    if (fieldRuntime.editor) {
                        fieldUIConfig.editor = fieldRuntime.editor;
                    }
                    if (fieldRuntime.renderer) {
                        fieldUIConfig.renderer = fieldRuntime.renderer;
                    }
                    if (fieldRuntime.extraActions) {
                        fieldUIConfig.extraActions = fieldRuntime.extraActions;
                    }
                    if (fieldRuntime.elementClasses) {
                        fieldUIConfig.elementClasses = fieldRuntime.elementClasses;
                    }
                    // change dimensions and layout if needed
                    if (fieldRuntime.fieldDimensions) {
                        fieldUIConfig.containedBy = {
                            type: 'div',
                            classes: `col-sm-12 col-md-${fieldRuntime.fieldDimensions.columnSpan}`
                        };
                        if (fieldRuntime.fieldDimensions.spacingClasses) {
                            fieldUIConfig.containedBy.classes += ' ' + fieldRuntime.fieldDimensions.spacingClasses;
                        }
                        if (fieldUIConfig.label) {
                            fieldUIConfig.label.classes = 'col-12 col-form-label';
                        }
                    }
                }
            }
            fieldUIConfigs.push(fieldUIConfig);
        });
        if (!runtimeConfig.hasExternalControl) {
            formConfig.buttonsContainedBy = {
                type: 'div',
                classes: 'd-flex w-100 justify-space-between mb-2',
            };
            formConfig.cancelButton = {
                text: '',
                classes: 'btn-info rounded p-1 mr-2 mt-2 w-100',
                iconClasses: 'fas fa-ban'
            };
            formConfig.saveButton = {
                text: '',
                classes: 'btn-primary rounded p-1 mt-2 w-100',
                iconClasses: 'fas fa-save'
            };
            formConfig.activeSave = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>&nbsp;';
        }
        // sort the fields into display order
        // if runtime config has groups, use those instead
        if (runtimeConfig.fieldGroups) {
            formConfig.fieldGroups = [];
            runtimeConfig.fieldGroups.forEach((runtimeGroup) => {
                let fieldGroup = {
                    containedBy: runtimeGroup.containedBy,
                    fields: []
                };
                if (runtimeGroup.subGroups) {
                    fieldGroup.subGroups = [];
                    runtimeGroup.subGroups.forEach((subRuntimeGroup) => {
                        let fieldSubgroup = {
                            containedBy: subRuntimeGroup.containedBy,
                            fields: []
                        };
                        subRuntimeGroup.fields.forEach((subRuntimeFieldId) => {
                            const foundIndex = fieldUIConfigs.findIndex((fieldUIConfig) => fieldUIConfig.field.id === subRuntimeFieldId);
                            if (foundIndex >= 0) {
                                fieldSubgroup.fields.push(fieldUIConfigs[foundIndex]);
                            }
                        });
                        // @ts-ignore
                        fieldGroup.subGroups.push(fieldSubgroup);
                    });
                }
                runtimeGroup.fields.forEach((runtimeFieldId) => {
                    const foundIndex = fieldUIConfigs.findIndex((fieldUIConfig) => fieldUIConfig.field.id === runtimeFieldId);
                    if (foundIndex >= 0) {
                        fieldGroup.fields.push(fieldUIConfigs[foundIndex]);
                    }
                });
                formConfig.fieldGroups.push(fieldGroup);
            });
            // now find the fields that weren't in the runtime field groups and put them in another default field group
            const defaultFieldGroup = {
                containedBy: {
                    type: 'div',
                    classes: 'col-sm-12',
                },
                fields: []
            };
            fieldUIConfigs.forEach((fieldUIConfig) => {
                if (!this.isFieldInCurrentFieldGroups(formConfig, fieldUIConfig)) {
                    defaultFieldGroup.fields.push(fieldUIConfig);
                }
            });
            if (defaultFieldGroup.fields.length > 0)
                formConfig.fieldGroups.unshift(defaultFieldGroup);
        }
        else {
            formConfig.fieldGroups[0].fields = fieldUIConfigs;
        }
        formConfig.fieldGroups.forEach((group) => {
            group.fields.sort((a, b) => {
                return (a.displayOrder - b.displayOrder);
            });
        });
        if (runtimeConfig.deleteButton && !runtimeConfig.hasExternalControl) {
            formConfig.deleteButton = {
                text: '',
                classes: 'btn-warning rounded p-1 mr-2 mt-2 w-100',
                iconClasses: 'fas fa-trash-alt'
            };
        }
        logger(formConfig);
        return formConfig;
    }
    getElementIdForDataFieldId(fieldId) {
        return undefined;
    }
    isFieldInCurrentFieldGroups(formConfig, field) {
        let result = false;
        formConfig.fieldGroups.forEach((fieldGroup) => {
            const foundIndex = fieldGroup.fields.findIndex((fieldInGroup) => fieldInGroup.field.id === field.field.id);
            if (foundIndex >= 0) {
                result = true;
            }
        });
        return result;
    }
}
BootstrapFormConfigHelper.COLOUR_PICKER_CONTAINER = 'framework-colour-picker-container';
BootstrapFormConfigHelper.SLIDE_BAR_CONTAINER = 'framework-slider-container';
//# sourceMappingURL=BootstrapFormConfigHelper.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/helper/BootstrapTableConfigHelper.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/helper/BootstrapTableConfigHelper.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BootstrapTableConfigHelper": () => (/* binding */ BootstrapTableConfigHelper)
/* harmony export */ });
/* harmony import */ var _model_BasicFieldOperations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/BasicFieldOperations */ "./node_modules/ui-framework-jps/dist/framework/model/BasicFieldOperations.js");
/* harmony import */ var _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/DataObjectTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectTypeDefs.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _model_BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../model/BasicObjectDefinitionFactory */ "./node_modules/ui-framework-jps/dist/framework/model/BasicObjectDefinitionFactory.js");
/* harmony import */ var _LimitedChoiceTextRenderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./LimitedChoiceTextRenderer */ "./node_modules/ui-framework-jps/dist/framework/ui/helper/LimitedChoiceTextRenderer.js");
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");






const logger = debug__WEBPACK_IMPORTED_MODULE_2___default()('bootstrap-tabular-config-helper');
class BootstrapTableConfigHelper {
    constructor() {
    }
    static getInstance() {
        if (!(BootstrapTableConfigHelper._instance)) {
            BootstrapTableConfigHelper._instance = new BootstrapTableConfigHelper();
        }
        return BootstrapTableConfigHelper._instance;
    }
    generateTableConfig(dataObjDef, runtimeConfig) {
        let fieldOperations = new _model_BasicFieldOperations__WEBPACK_IMPORTED_MODULE_0__.BasicFieldOperations();
        let choiceRenderer = new _LimitedChoiceTextRenderer__WEBPACK_IMPORTED_MODULE_4__.LimitedChoiceTextRenderer();
        // create the Field UI config for each field
        let fieldUIConfigs = [];
        let columnHeaderConfigs = [];
        dataObjDef.fields.forEach((fieldDef, index) => {
            let fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_5__.UIFieldType.text;
            switch (fieldDef.type) {
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.datetime): {
                    // is this the created or modified date
                    if (runtimeConfig.hideModifierFields) {
                        if (fieldDef.id === _model_BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_3__.FIELD_CreatedOn) {
                            fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_5__.UIFieldType.hidden;
                        }
                        if (fieldDef.id === _model_BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_3__.FIELD_ModifiedOn) {
                            fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_5__.UIFieldType.hidden;
                        }
                    }
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.userId): {
                    if (runtimeConfig.hideModifierFields) {
                        fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_5__.UIFieldType.hidden;
                    }
                    else {
                        fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_5__.UIFieldType.text;
                    }
                    break;
                }
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.uuid):
                case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.id): {
                    fieldType = _CommonTypes__WEBPACK_IMPORTED_MODULE_5__.UIFieldType.hidden;
                    break;
                }
            }
            // see if the field was supplied with a display order, no order, no display for a table
            const displayOrder = runtimeConfig.fieldDisplayOrders.find((value) => value.fieldId === fieldDef.id);
            let displayOrderValue = index;
            if (displayOrder) {
                displayOrderValue = displayOrder.displayOrder;
                if ((fieldDef.type !== _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.id) && (fieldDef.type !== _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.uuid) && (fieldType !== _CommonTypes__WEBPACK_IMPORTED_MODULE_5__.UIFieldType.hidden)) { // no labels, descriptions, container for id,uuid
                    let headerConfig = {
                        field: fieldDef,
                        element: {
                            type: 'th',
                            attributes: [{ name: 'scope', value: 'col' }],
                            classes: '',
                            innerHTML: fieldDef.displayName
                        },
                        displayOrder: displayOrderValue
                    };
                    // construct the field ui config
                    let fieldUIConfig = {
                        field: fieldDef,
                        displayOrder: displayOrderValue,
                        elementType: _CommonTypes__WEBPACK_IMPORTED_MODULE_5__.UIFieldType.tableData,
                        elementClasses: 'text-center',
                        renderer: fieldOperations,
                        getValue: _CommonTypes__WEBPACK_IMPORTED_MODULE_5__.defaultGetValue
                    };
                    if (fieldDef.type === _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.limitedChoice) {
                        fieldUIConfig.renderer = choiceRenderer;
                    }
                    // see if the field was supplied with a field runtime
                    if (runtimeConfig.fieldRuntimeConfigs) {
                        const fieldRuntime = runtimeConfig.fieldRuntimeConfigs.find((value) => value.fieldId === fieldDef.id);
                        if (fieldRuntime) {
                            if (fieldRuntime.validator) {
                                if (fieldUIConfig.validator)
                                    fieldUIConfig.validator.validator = fieldRuntime.validator;
                            }
                            if (fieldRuntime.editor) {
                                if (fieldUIConfig.editor)
                                    fieldUIConfig.editor = fieldRuntime.editor;
                            }
                            if (fieldRuntime.renderer) {
                                if (fieldUIConfig.renderer)
                                    fieldUIConfig.renderer = fieldRuntime.renderer;
                            }
                            if (fieldRuntime.label) {
                                if (fieldRuntime.label.labelPosition === _CommonTypes__WEBPACK_IMPORTED_MODULE_5__.FieldLabelPosition.noLabel) {
                                    if (headerConfig.element)
                                        headerConfig.element.innerHTML = '';
                                }
                                if (fieldRuntime.label.label) {
                                    if (fieldUIConfig.label)
                                        fieldUIConfig.label.label = fieldRuntime.label.label;
                                }
                            }
                        }
                    }
                    columnHeaderConfigs.push(headerConfig);
                    fieldUIConfigs.push(fieldUIConfig);
                }
            }
        });
        let actionColumn = null;
        if (runtimeConfig.hasActions) {
            actionColumn = {
                element: {
                    type: 'th',
                    attributes: [{ name: 'scope', value: 'col' }],
                    classes: 'text-right',
                    innerHTML: 'Actions'
                },
                displayOrder: 1000
            };
        }
        const tableConfig = {
            id: dataObjDef.id,
            displayName: dataObjDef.displayName,
            container: {
                type: 'div',
                classes: 'table-responsive'
            },
            table: {
                type: 'table',
                classes: 'table table-hover table-sm'
            },
            header: {
                type: 'thead',
                classes: ''
            },
            headerColumns: columnHeaderConfigs,
            body: {
                type: 'tbody',
                classes: ''
            },
            columns: fieldUIConfigs,
            itemDetailColumn: runtimeConfig.itemDetailColumn,
            editableFields: runtimeConfig.editableFields,
            lazyLoadPageSize: runtimeConfig.lazyLoadPageSize
        };
        // sort the fields into display order
        tableConfig.columns.sort((a, b) => {
            return (a.displayOrder - b.displayOrder);
        });
        tableConfig.headerColumns.sort((a, b) => {
            return (a.displayOrder - b.displayOrder);
        });
        if (actionColumn) {
            tableConfig.actionColumn = actionColumn;
        }
        if (runtimeConfig.itemDetailLabel && (runtimeConfig.itemDetailColumn < tableConfig.headerColumns.length)) {
            const headerConfig = tableConfig.headerColumns[runtimeConfig.itemDetailColumn - 1];
            headerConfig.element.innerHTML = runtimeConfig.itemDetailLabel;
        }
        logger(tableConfig);
        return tableConfig;
    }
}
//# sourceMappingURL=BootstrapTableConfigHelper.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/helper/CollectionViewFilterHelper.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/helper/CollectionViewFilterHelper.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CollectionViewFilterHelper": () => (/* binding */ CollectionViewFilterHelper)
/* harmony export */ });
class CollectionViewFilterHelper {
    constructor(view, filterFieldId, filter) {
        this.view = view;
        this.filterFieldId = filterFieldId;
        this.filter = filter;
        this.filterEl = null;
    }
    addPartialMatch(filter, matchingFieldIds, minLength) {
        this.filter.contains.push({ filter, matchingFieldIds, minLength });
    }
    clearPartialMatch() {
        this.filter.contains = [];
    }
    addExactMatch(fieldId, values) {
        this.filter.exactMatch.push({ matchingFieldId: fieldId, matchValues: values, isStrictMatch: false });
    }
    clearExactMatch() {
        this.filter.exactMatch = [];
    }
    applyCurrentFilter() {
        this.view.applyFilter(this.filter);
    }
    onDocumentLoaded() {
        this.filterEl = document.getElementById(this.filterFieldId);
        if (this.filterEl) {
            this.filterEl.addEventListener('keyup', (event) => {
                if (event.isComposing || event.keyCode === 229) {
                    return;
                }
                if (this.filter.contains.length > 0) {
                    // @ts-ignore
                    const filterValue = this.filterEl.value.trim();
                    if (filterValue.length >= this.filter.contains[0].minLength) {
                        this.filter.contains[0].filter = filterValue;
                        this.view.applyFilter(this.filter);
                    }
                    else {
                        if (this.view.hasFilter()) {
                            this.view.clearFilter();
                        }
                    }
                }
            });
        }
    }
}
//# sourceMappingURL=CollectionViewFilterHelper.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/helper/CollectionViewProcessor.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/helper/CollectionViewProcessor.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CollectionViewProcessor": () => (/* binding */ CollectionViewProcessor)
/* harmony export */ });
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");



const logger = debug__WEBPACK_IMPORTED_MODULE_1___default()('collection-view-processor');
class CollectionViewProcessor {
    static hasConditionalMatch(collectionName, item, config, index) {
        let result = false;
        if (item) {
            const conditionMatch = config.conditionMatch[index];
            const fieldValue = item[conditionMatch.matchingFieldId];
            if (fieldValue !== undefined) {
                switch (conditionMatch.condition) {
                    case _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ComparisonType.equals: {
                        if (fieldValue == conditionMatch.matchValue) {
                            result = true;
                        }
                        break;
                    }
                    case _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ComparisonType.lessThan: {
                        if (fieldValue < conditionMatch.matchValue) {
                            result = true;
                        }
                        break;
                    }
                    case _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ComparisonType.lessThanEqual: {
                        if (fieldValue <= conditionMatch.matchValue) {
                            result = true;
                        }
                        break;
                    }
                    case _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ComparisonType.greaterThan: {
                        if (fieldValue > conditionMatch.matchValue) {
                            result = true;
                        }
                        break;
                    }
                    case _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ComparisonType.greaterThanEqual: {
                        if (fieldValue >= conditionMatch.matchValue) {
                            result = true;
                        }
                        break;
                    }
                    case _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ComparisonType.isNotNull: {
                        result = true;
                        break;
                    }
                }
                logger(`Conditional match for ${collectionName} item, field ${conditionMatch.matchingFieldId} with value ${fieldValue} against values ${conditionMatch.matchValue} - is match? ${result}`);
            }
            else {
                if (conditionMatch.condition === _CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ComparisonType.isNull) {
                    logger(`Conditional match for ${collectionName} item, field ${conditionMatch.matchingFieldId} has NO field value for null condition - TRUE`);
                    result = true;
                }
                else {
                    logger(`Conditional match for ${collectionName} item, field ${conditionMatch.matchingFieldId} has NO field value against values ${conditionMatch.matchValue}`);
                }
            }
        }
        return result;
    }
    static hasConditionalMatchOrNoMatchNeeded(collectionName, item, config) {
        let result = true;
        if (config.conditionMatch.length > 0) {
            if (item) {
                let conditionalMatchResults = [];
                config.conditionMatch.forEach((exactMatch, index) => {
                    conditionalMatchResults.push(CollectionViewProcessor.hasConditionalMatch(collectionName, item, config, index));
                });
                // what logic are we applying to conditional matches>?
                if (conditionalMatchResults.length > 1) {
                    if (!config.conditionalMatchLogicType) {
                        config.conditionalMatchLogicType = _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.MatchLogicType.AND;
                    }
                    if (config.conditionalMatchLogicType === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.MatchLogicType.AND) {
                        result = true;
                        conditionalMatchResults.forEach((itemResult) => {
                            result = result && itemResult;
                        });
                    }
                    if (config.conditionalMatchLogicType === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.MatchLogicType.OR) {
                        result = false;
                        conditionalMatchResults.forEach((itemResult, index) => {
                            const exactMatch = config.exactMatch[index];
                            if (exactMatch.isStrictMatch) {
                                result = result && itemResult;
                            }
                            else {
                                result = result || itemResult;
                            }
                        });
                    }
                }
                else {
                    result = conditionalMatchResults[0];
                }
            }
        }
        else {
            logger(`No conditional match needed, sending true`);
            result = true;
        }
        return result;
    }
    static hasExactMatch(collectionName, item, config, index) {
        let result = false;
        if (item) {
            const exactMatch = config.exactMatch[index];
            const fieldValue = item[exactMatch.matchingFieldId];
            if (fieldValue !== undefined) {
                exactMatch.matchValues.forEach((matchValue) => {
                    if (fieldValue == matchValue)
                        result = true;
                });
                logger(`Exact match for ${collectionName} item, field ${exactMatch.matchingFieldId} with value ${fieldValue} against values ${exactMatch.matchValues} - is match? ${result}`);
            }
            else {
                logger(`Exact match for ${collectionName} item, field ${exactMatch.matchingFieldId} has NO field value against values ${exactMatch.matchValues}`);
            }
        }
        return result;
    }
    static hasExactMatchOrNoExactMatchNeeded(collectionName, item, config) {
        let result = true;
        if (config.exactMatch.length > 0) {
            if (item) {
                let exactMatchResults = [];
                config.exactMatch.forEach((exactMatch, index) => {
                    exactMatchResults.push(CollectionViewProcessor.hasExactMatch(collectionName, item, config, index));
                });
                // what logic are we applying to exact matches>?
                if (exactMatchResults.length > 1) {
                    if (!config.exactMatchLogicType) {
                        config.exactMatchLogicType = _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.MatchLogicType.AND;
                    }
                    if (config.exactMatchLogicType === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.MatchLogicType.AND) {
                        result = true;
                        exactMatchResults.forEach((itemResult) => {
                            result = result && itemResult;
                        });
                    }
                    if (config.exactMatchLogicType === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.MatchLogicType.OR) {
                        result = false;
                        exactMatchResults.forEach((itemResult, index) => {
                            const exactMatch = config.exactMatch[index];
                            if (exactMatch.isStrictMatch) {
                                result = result && itemResult;
                            }
                            else {
                                result = result || itemResult;
                            }
                        });
                    }
                }
                else {
                    result = exactMatchResults[0];
                }
            }
        }
        else {
            logger(`No exact match needed, sending true`);
            result = true;
        }
        return result;
    }
    static hasPartialMatch(collectionName, item, partialMatch) {
        let result = false;
        if (item) {
            const filterValue = partialMatch.filter.trim().toLowerCase();
            let done = false;
            let counter = 0;
            while (!done) {
                if (counter < partialMatch.matchingFieldIds.length) {
                    const fieldId = partialMatch.matchingFieldIds[counter];
                    const fieldValue = item[fieldId];
                    if (fieldValue !== undefined) {
                        let fieldValueString = fieldValue + '';
                        fieldValueString = fieldValueString.toLowerCase();
                        if (fieldValueString.includes(filterValue)) {
                            logger(`Partial match for ${collectionName} item found in field ${fieldId} with filter ${filterValue}`);
                            result = true;
                            done = true;
                        }
                    }
                    counter++;
                }
                else {
                    logger(`Partial match for ${collectionName} item not found in matching fields`);
                    done = true;
                }
            }
        }
        return result;
    }
    static hasPartialMatchOrNoPartialMatchNeeded(collectionName, item, config) {
        let result = false;
        if (config.contains.length > 0) {
            if (item) {
                config.contains.forEach((partialMatch) => {
                    if (CollectionViewProcessor.hasPartialMatch(collectionName, item, partialMatch)) {
                        result = true;
                    }
                });
            }
        }
        else {
            logger(`No partial match needed, sending true`);
            result = true;
        }
        return result;
    }
    static doesItemMatchFilterConfig(collectionName, item, config) {
        return CollectionViewProcessor.hasExactMatchOrNoExactMatchNeeded(collectionName, item, config) &&
            CollectionViewProcessor.hasPartialMatchOrNoPartialMatchNeeded(collectionName, item, config) &&
            CollectionViewProcessor.hasConditionalMatchOrNoMatchNeeded(collectionName, item, config);
    }
}
//# sourceMappingURL=CollectionViewProcessor.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/helper/ColourEditor.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/helper/ColourEditor.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColourEditor": () => (/* binding */ ColourEditor)
/* harmony export */ });
/* harmony import */ var _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../util/BrowserUtil */ "./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_1__);


const logger = debug__WEBPACK_IMPORTED_MODULE_1___default()('colour-editor');
class ColourEditor {
    constructor(colourPickerContainerId) {
        this.field = null;
        this.container = null;
        this.colourPickerContainerId = colourPickerContainerId;
        this.editValue = this.editValue.bind(this);
        this.editCompleted = this.editCompleted.bind(this);
        this.cbColourChange = this.cbColourChange.bind(this);
        this.container = document.getElementById(this.colourPickerContainerId);
        if (this.container) {
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(this.container, 'd-none');
            $(this.container).farbtastic(this.cbColourChange);
        }
    }
    editCompleted(field, fieldDef) {
        logger(`Field at edit completed`);
        this.field = field;
        if (this.container)
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(this.container, 'd-none');
    }
    editValue(field, fieldDef, currentValue) {
        this.field = field;
        logger(`Field at edit value`);
        logger(this.field);
        // do we have a valid value?
        if (/^#[0-9a-f]{6}$/.test(currentValue) && this.container) {
            // @ts-ignore
            this.container['data-field'] = field;
            $.farbtastic(this.container).setColor(currentValue);
        }
        if (field && this.container) {
            let element = field.getElement();
            let offset = (0,_util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__.getElementOffset)(element);
            offset.top += element.offsetHeight;
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].removeAttributes(this.container, ['style']);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(this.container, [{
                    name: 'style',
                    value: `top:${offset.top}px; left: ${offset.left}px;`
                }]);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].removeClasses(this.container, 'd-none');
        }
        return currentValue;
    }
    cbColourChange(colour) {
        logger(`Colour changed to ${colour}`);
        if (/^#[0-9a-f]{6}$/.test(colour)) {
            logger(`Field at CB Colour Change`);
            logger(this.field);
            // @ts-ignore
            let field = this.container['data-field'];
            logger(field);
            if (this.field)
                this.field.setValue(colour);
            if (field)
                field.setValue(colour);
            if (this.container)
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(this.container, 'd-none');
        }
    }
}
//# sourceMappingURL=ColourEditor.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/helper/FormConfigHelperFunctions.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/helper/FormConfigHelperFunctions.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FormConfigHelperFunctions": () => (/* binding */ FormConfigHelperFunctions)
/* harmony export */ });
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");

class FormConfigHelperFunctions {
    static makeFieldHidden(field) {
        field.elementType = _CommonTypes__WEBPACK_IMPORTED_MODULE_0__.UIFieldType.hidden;
        field.containedBy = undefined;
        field.label = undefined;
        field.describedBy = undefined;
        field.validator = undefined;
    }
    static makeFieldHiddenInConfig(config, fieldId) {
        const foundIndex = config.fieldGroups[0].fields.findIndex((value) => value.field.id === fieldId);
        if (foundIndex >= 0) {
            let fieldDef = config.fieldGroups[0].fields[foundIndex];
            FormConfigHelperFunctions.makeFieldHidden(fieldDef);
        }
    }
    static reconfigureTextAreaInConfig(config, fieldId, columns, rows) {
        const foundIndex = config.fieldGroups[0].fields.findIndex((value) => value.field.id === fieldId);
        if (foundIndex >= 0) {
            let fieldDef = config.fieldGroups[0].fields[foundIndex];
            if (fieldDef.elementType === _CommonTypes__WEBPACK_IMPORTED_MODULE_0__.UIFieldType.textarea) {
                if (fieldDef.textarea) {
                    fieldDef.textarea.cols = columns;
                    fieldDef.textarea.rows = rows;
                }
            }
        }
    }
}
//# sourceMappingURL=FormConfigHelperFunctions.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/helper/LimitedChoiceTextRenderer.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/helper/LimitedChoiceTextRenderer.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LimitedChoiceTextRenderer": () => (/* binding */ LimitedChoiceTextRenderer)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);

const rlogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('limited-choice-text-renderer');
class LimitedChoiceTextRenderer {
    constructor() {
    }
    renderValue(field, fieldDef, currentValue) {
        rlogger(`Rendering value for field ${fieldDef.displayName} with new value ${currentValue}`);
        // find the current value in the data source and convert to text for display
        let result = currentValue;
        if (fieldDef.dataSource) {
            const valueOptions = fieldDef.dataSource.getOptions();
            const foundIndex = valueOptions.findIndex((option) => option.value === currentValue);
            if (foundIndex >= 0) {
                result = valueOptions[foundIndex].name;
            }
        }
        return result;
    }
    generate(field, isCreate) {
        return '';
    }
    setSubElements(elements) {
    }
}
//# sourceMappingURL=LimitedChoiceTextRenderer.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/helper/LinkedCollectionDetailController.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/helper/LinkedCollectionDetailController.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ChangeDataObjectDelegate": () => (/* binding */ ChangeDataObjectDelegate),
/* harmony export */   "LinkedCollectionDetailController": () => (/* binding */ LinkedCollectionDetailController)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _model_DataObjectController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../model/DataObjectController */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectController.js");
/* harmony import */ var _alert_AlertListener__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../alert/AlertListener */ "./node_modules/ui-framework-jps/dist/framework/ui/alert/AlertListener.js");
/* harmony import */ var _alert_AlertManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../alert/AlertManager */ "./node_modules/ui-framework-jps/dist/framework/ui/alert/AlertManager.js");




const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('linked-controller');
const dlogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('linked-controller-detail');
class ChildViewListenerDelegate {
    constructor(controller) {
        this.controller = controller;
    }
    addView(view) {
        view.addEventListener(this);
    }
    canDeleteItem(view, selectedItem) {
        return true;
    }
    documentLoaded(view) {
    }
    hideRequested(view) {
    }
    itemAction(view, actionName, selectedItem) {
    }
    itemDeleted(view, selectedItem) {
    }
    itemDropped(view, droppedItem) {
    }
    showRequested(view) {
    }
    cancelled(view, dataObj) {
        this.controller.cancelled(view, dataObj);
    }
    deletedItem(view, dataObj) {
        this.controller.deletedItem(view, dataObj);
    }
    saveNewItem(view, dataObj) {
        this.controller.saveNewItem(view, dataObj);
    }
    updateItem(view, dataObj) {
        this.controller.updateItem(view, dataObj);
    }
}
class ChangeDataObjectDelegate {
    constructor(callback) {
        this.callback = callback;
    }
    shouldDiscardChanges() {
        _alert_AlertManager__WEBPACK_IMPORTED_MODULE_3__.AlertManager.getInstance().startAlert(this, 'Discard Changes', 'There are unsaved changes.  Discard?', {});
    }
    alertCompleted(event) {
        if (event.outcome === _alert_AlertListener__WEBPACK_IMPORTED_MODULE_2__.AlertType.confirmed) {
            this.callback();
        }
    }
}
class LinkedCollectionDetailController extends _model_DataObjectController__WEBPACK_IMPORTED_MODULE_1__.DataObjectController {
    constructor(typeName, parentView) {
        super(typeName);
        this.children = [];
        logger(`Starting with parent view ${parentView.getName()}`);
        this.parentView = parentView;
        this.delegate = new ChildViewListenerDelegate(this);
        this.parentView.addEventListener(this);
    }
    collectionChanged(view) {
        this.children.forEach((childView) => {
            childView.clearDisplay();
            childView.setReadOnly();
        });
    }
    addLinkedDetailView(childView) {
        logger(`Adding child view ${childView.getName()}`);
        this.children.push(childView);
        this.delegate.addView(childView); // this delegate will only pass us the unique detail view events (save, new, etc)
    }
    initialise() {
    }
    canDeleteItem(view, selectedItem) {
        logger(`Handling delete item from view ${view.getName()}`);
        dlogger(selectedItem);
        return this.parentView.hasPermissionToDeleteItemInNamedCollection('', selectedItem);
    }
    documentLoaded(view) {
        logger(`Handling document loaded view ${view.getName()}`);
        // let the children know
        this.children.forEach((childView) => {
            childView.onDocumentLoaded();
        });
    }
    hideRequested(view) {
        // let the children know
        logger(`Handling hide  from view ${view.getName()}`);
        this.children.forEach((childView) => {
            childView.hide();
        });
    }
    itemAction(view, actionName, selectedItem) {
        logger(`Handling item action ${actionName} from view ${view.getName()}`);
        dlogger(selectedItem);
        this.children.forEach((childView) => {
            childView.handleActionItem(actionName, selectedItem);
        });
    }
    itemDeleted(view, selectedItem) {
        logger(`Handling item deleted from view ${view.getName()}`);
        dlogger(selectedItem);
        this.children.forEach((childView) => {
            // clear the child display and set readonly
            childView.clearDisplay();
            childView.setReadOnly();
        });
    }
    itemDeselected(view, selectedItem) {
        logger(`Handling item deselected from view ${view.getName()}`);
        dlogger(selectedItem);
        this.children.forEach((childView) => {
            // clear the child display and set readonly
            childView.clearDisplay();
            childView.setReadOnly();
        });
    }
    itemDragStarted(view, selectedItem) {
    }
    itemDropped(view, droppedItem) {
    }
    itemSelected(view, selectedItem) {
        logger(`Handling item selected from view ${view.getName()}`);
        dlogger(selectedItem);
        this.children.forEach((childView) => {
            childView.displayItem(selectedItem);
        });
    }
    showRequested(view) {
        logger(`Handling show from view ${view.getName()}`);
        // let the children know
        this.children.forEach((childView) => {
            childView.show();
        });
    }
    canSelectItem(view, selectedItem) {
        logger(`Handling can select item from view ${view.getName()}`);
        dlogger(selectedItem);
        // are we currently in the middle of creating a new object?
        if (this.isCreatingNew)
            return false;
        // prevent selection if the children views have modified this item
        let canProceedWithSelection = true;
        this.children.forEach((childView) => {
            if (childView.hasChanged()) {
                dlogger(`child view ${childView.getName()} has changed - cancelling`);
                canProceedWithSelection = false;
            }
        });
        if (!canProceedWithSelection) {
            canProceedWithSelection = confirm(`${view.getName()} - unsaved changes.  Discard them?`);
        }
        return canProceedWithSelection;
    }
    cancelled(view, dataObj) {
        logger(`Handling cancelled from child view ${view.getName()}`);
        dlogger(dataObj);
        this.isCreatingNew = false;
    }
    deletedItem(view, dataObj) {
        logger(`Handling deleted from child view ${view.getName()}`);
        dlogger(dataObj);
        this.informListenersOfDelete(dataObj);
    }
    saveNewItem(view, dataObj) {
        logger(`Handling save new from child view ${view.getName()}`);
        dlogger(dataObj);
        this.informListenersOfCreate(dataObj);
    }
    updateItem(view, dataObj) {
        logger(`Handling update from child view ${view.getName()}`);
        dlogger(dataObj);
        this.informListenersOfUpdate(dataObj);
    }
    _startNewObject(startingDataObj) {
        logger(`Handling start new object`);
        // assume the first detail view will create the object for us
        let canProceedWithCreateNew = true;
        this.children.forEach((childView) => {
            if (childView.hasChanged()) {
                dlogger(`child view ${childView.getName()} has changed - cancelling`);
                canProceedWithCreateNew = false;
            }
        });
        if (!canProceedWithCreateNew) {
            canProceedWithCreateNew = confirm(`There are unsaved changes.  Discard them?`);
        }
        if (this.children.length > 0) {
            logger(`Handling start new object with child view ${this.children[0].getName()}`);
            let dataObj = this.children[0].createItem(startingDataObj);
            if (dataObj) {
                canProceedWithCreateNew = true;
                this.children[0].show();
            }
        }
        return canProceedWithCreateNew;
    }
}
//# sourceMappingURL=LinkedCollectionDetailController.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/helper/RBGFieldOperations.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/helper/RBGFieldOperations.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RBGFieldOperations": () => (/* binding */ RBGFieldOperations)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");


const flogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('basic-field-operations-formatter');
const vlogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('basic-field-operations-validator');
const glogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('basic-field-operations-generator');
const rlogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('basic-field-operations-renderer');
class RBGFieldOperations {
    constructor() {
        this.radioButtons = [];
    }
    // called when saving, change to final values
    formatValue(field, currentValue) {
        flogger(`Handling format value for RBG ${field.displayName} with value ${currentValue}`);
        let result = currentValue;
        // find the current selected radio button
        this.radioButtons.forEach((radioButton) => {
            if (radioButton.checked) {
                result = radioButton.value;
                if (field.idType === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.KeyType.number) {
                    result = parseInt(result);
                }
            }
        });
        flogger(`Handling format value for field ${field.displayName} with value ${currentValue} - result is ${result}`);
        return result;
    }
    isValidValue(field, currentValue) {
        vlogger(`Handling is valid value for field ${field.displayName} with value ${currentValue}`);
        let response = {
            isValid: false,
            resetOnFailure: false
        };
        // basics first, is the field mandatory?
        if (field.mandatory) {
            this.radioButtons.forEach((radioButton) => {
                if (radioButton.checked) {
                    response.isValid = true;
                }
            });
            if (!response.isValid) {
                response.message = `${field.displayName} is required. Please select one of the values.`;
                vlogger(`Handling is valid value for field ${field.displayName} with value ${currentValue} - is valid is ${response.isValid} with message ${response.message}`);
                return response;
            }
        }
        else {
            response.isValid = true;
        }
        // ok, so we have some content, we need to check if the value is a valid format with regular expressions
        vlogger(`Handling is valid value for field ${field.displayName} with value ${currentValue} - is valid is ${response.isValid} with message ${response.message}`);
        return response;
    }
    renderValue(field, fieldDef, currentValue) {
        rlogger(`Rendering value for field ${fieldDef.displayName} with new value ${currentValue}`);
        this.radioButtons.forEach((radioButton) => {
            if (radioButton.value === currentValue)
                radioButton.checked = true;
        });
        return null;
    }
    generate(field, isCreate) {
        return '';
    }
    setSubElements(elements) {
        this.radioButtons = elements;
    }
}
//# sourceMappingURL=RBGFieldOperations.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/helper/SimpleValueDataSource.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/helper/SimpleValueDataSource.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SimpleValueDataSource": () => (/* binding */ SimpleValueDataSource)
/* harmony export */ });
class SimpleValueDataSource {
    constructor(options) {
        this.options = options;
        this.listeners = [];
    }
    addValueOption(name, value) {
        this.options.push({ name, value });
    }
    clearValueOptions() {
        this.options = [];
        this.informListeners();
    }
    informListeners() {
        this.listeners.forEach((listener) => listener.optionsChanged(this.options));
    }
    addListener(listener) {
        this.listeners.push(listener);
    }
    getOptions() {
        return this.options;
    }
}
//# sourceMappingURL=SimpleValueDataSource.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/key-binding-manager/KeyBindingManager.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/key-binding-manager/KeyBindingManager.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KeyBindingManager": () => (/* binding */ KeyBindingManager)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_MiscFunctions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../util/MiscFunctions */ "./node_modules/ui-framework-jps/dist/framework/util/MiscFunctions.js");


const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('key-binding-manager');
class KeyBindingManager {
    constructor() {
        this.defaultContextBinding = null;
        this.currentContextBinding = null;
        this.contextBindings = [];
        this.contextStack = [];
        this.handleKeyBinding = this.handleKeyBinding.bind(this);
    }
    static getInstance() {
        if (!(KeyBindingManager._instance)) {
            KeyBindingManager._instance = new KeyBindingManager();
        }
        return KeyBindingManager._instance;
    }
    onDocumentLoaded() {
        window.addEventListener('keyup', this.handleKeyBinding);
    }
    handleKeyBinding(event) {
        const key = event.code;
        if (this.currentContextBinding) {
            let foundAllBindings = false;
            let foundIndex = -1;
            while (!foundAllBindings) {
                foundIndex = this.currentContextBinding.keyBindings.findIndex((keyBinding, index) => ((keyBinding.keyCode === key) && (index > foundIndex)));
                if (foundIndex >= 0) {
                    const binding = this.currentContextBinding.keyBindings[foundIndex];
                    if (event.altKey === binding.altKeyRequired) {
                        if (event.ctrlKey === binding.controlKeyRequired) {
                            if (event.shiftKey === binding.shiftKeyRequired) {
                                if (event.metaKey === binding.metaKeyRequired) {
                                    if (binding.receiver) {
                                        if (binding.contextName) {
                                            event.preventDefault();
                                            event.stopPropagation();
                                            logger(`Key binding activated for context ${binding.contextName} with key ${key} and action ${binding.actionName}`);
                                            binding.receiver.keyActionEvent({
                                                actionName: binding.actionName,
                                                contextName: binding.contextName
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else {
                    foundAllBindings = true;
                }
            }
        }
    }
    resetToDefaultBindings() {
        var _a;
        if (this.defaultContextBinding) {
            const defaultReceiver = (_a = this.defaultContextBinding) === null || _a === void 0 ? void 0 : _a.receiver;
            this.defaultContextBinding.receiver = undefined;
            this.currentContextBinding = (0,_util_MiscFunctions__WEBPACK_IMPORTED_MODULE_1__.copyObject)(this.defaultContextBinding);
            this.defaultContextBinding.receiver = defaultReceiver;
            if (this.currentContextBinding) {
                this.currentContextBinding.receiver = defaultReceiver;
                if (this.currentContextBinding && this.defaultContextBinding) {
                    this.currentContextBinding.keyBindings.forEach((keyBinding) => {
                        // @ts-ignore
                        keyBinding.contextName = this.currentContextBinding.contextName;
                        // @ts-ignore
                        keyBinding.receiver = this.currentContextBinding.receiver;
                    });
                }
            }
        }
    }
    setDefaultKeyBindings(defaultContextBinding) {
        logger('Setting default key bindings');
        defaultContextBinding.contextName = KeyBindingManager.CONTEXT_Default;
        this.defaultContextBinding = defaultContextBinding;
        this.resetToDefaultBindings();
        this.contextStack.push(KeyBindingManager.CONTEXT_Default);
    }
    addContextKeyBindings(contextBinding) {
        logger(`Adding key bindings for context ${contextBinding.contextName}`);
        contextBinding.keyBindings.forEach((keyBinding) => {
            keyBinding.contextName = contextBinding.contextName;
            keyBinding.receiver = contextBinding.receiver;
        });
        this.contextBindings.push(contextBinding);
    }
    isSameKeyBinding(keyBinding1, keyBinding2) {
        let result = false;
        if (keyBinding1.keyCode === keyBinding2.keyCode) {
            if (keyBinding1.controlKeyRequired === keyBinding2.controlKeyRequired) {
                if (keyBinding1.altKeyRequired === keyBinding2.altKeyRequired) {
                    if (keyBinding1.shiftKeyRequired === keyBinding2.shiftKeyRequired) {
                        if (keyBinding1.metaKeyRequired === keyBinding2.metaKeyRequired) {
                            result = true;
                        }
                    }
                }
            }
        }
        return result;
    }
    combineBindings(startingBinding, addOrReplaceWithBinding) {
        let results = [];
        let usedKeyBindingsFromReplacementSet = [];
        logger(`Combining key bindings for contexts ${startingBinding.contextName} and ${addOrReplaceWithBinding.contextName}`);
        startingBinding.keyBindings.forEach((keyBinding) => {
            let index = addOrReplaceWithBinding.keyBindings.length - 1;
            let replaced = false;
            while (index >= 0) {
                let addOrReplaceWithBindingKeyBinding = addOrReplaceWithBinding.keyBindings[index];
                if (this.isSameKeyBinding(keyBinding, addOrReplaceWithBindingKeyBinding)) {
                    logger(`Context ${addOrReplaceWithBinding.contextName} key binding for key ${addOrReplaceWithBindingKeyBinding.keyCode} replacing context ${startingBinding.contextName}`);
                    replaced = true;
                    usedKeyBindingsFromReplacementSet.push(index);
                    addOrReplaceWithBindingKeyBinding.receiver = addOrReplaceWithBinding.receiver;
                    addOrReplaceWithBindingKeyBinding.contextName = addOrReplaceWithBinding.contextName;
                    results.push(addOrReplaceWithBindingKeyBinding);
                }
                index--;
            }
            if (!replaced) {
                keyBinding.receiver = startingBinding.receiver;
                keyBinding.contextName = startingBinding.contextName;
                results.push(keyBinding);
            }
        });
        //  add the unused key bindings
        addOrReplaceWithBinding.keyBindings.forEach((keyBinding, index) => {
            const foundIndex = usedKeyBindingsFromReplacementSet.findIndex((usedIndex) => usedIndex === index);
            if (foundIndex < 0) {
                let addOrReplaceWithBindingKeyBinding = addOrReplaceWithBinding.keyBindings[index];
                logger(`Adding new key binding for context ${addOrReplaceWithBinding.contextName} for key ${addOrReplaceWithBindingKeyBinding.keyCode}`);
                addOrReplaceWithBindingKeyBinding.receiver = addOrReplaceWithBinding.receiver;
                addOrReplaceWithBindingKeyBinding.contextName = addOrReplaceWithBinding.contextName;
                results.push(addOrReplaceWithBinding.keyBindings[index]);
            }
        });
        return results;
    }
    addContextToStackAndKeyBindings(keyBinding) {
        const foundIndex = this.contextStack.findIndex((item) => item === keyBinding.contextName);
        if (foundIndex < 0) {
            this.contextStack.push(keyBinding.contextName);
            if (this.currentContextBinding) {
                let newKeyBindings = this.combineBindings(this.currentContextBinding, keyBinding);
                this.currentContextBinding = {
                    keyBindings: newKeyBindings,
                    contextName: '',
                    receiver: this
                };
            }
        }
    }
    getKeyBindingForContext(contextName) {
        let result = null;
        const foundIndex = this.contextBindings.findIndex((binding) => binding.contextName === contextName);
        if (foundIndex >= 0) {
            result = this.contextBindings[foundIndex];
        }
        return result;
    }
    removeContextFromStackAndKeyBindings(contextName) {
        logger(`Removing key bindings for context ${contextName}`);
        const foundIndex = this.contextStack.findIndex((stackItem) => stackItem === contextName);
        if (foundIndex >= 0) {
            this.contextStack.splice(foundIndex, 1);
            logger(`Removing key bindings for context ${contextName}, stack is now ${this.contextStack} with length ${this.contextStack.length}`);
        }
        this.resetToDefaultBindings();
        if (this.contextStack.length > 1) {
            for (let index = 1; index < this.contextStack.length; index++) {
                const stackContextName = this.contextStack[index];
                const keyBinding = this.getKeyBindingForContext(stackContextName);
                if (this.currentContextBinding && keyBinding) {
                    logger(`Adding key bindings back in for context ${stackContextName}`);
                    let newKeyBindings = this.combineBindings(this.currentContextBinding, keyBinding);
                    this.currentContextBinding = {
                        keyBindings: newKeyBindings,
                        contextName: '',
                        receiver: this
                    };
                }
            }
        }
    }
    activateContext(contextName) {
        const foundIndex = this.contextBindings.findIndex((binding) => binding.contextName === contextName);
        if (foundIndex >= 0) {
            logger(`Activating key bindings for context ${contextName}`);
            const keyBinding = this.contextBindings[foundIndex];
            this.addContextToStackAndKeyBindings(keyBinding);
            logger(`Activating key bindings for context ${contextName}, stack is now ${this.contextStack}`);
        }
    }
    deactivateContext(contextName) {
        const foundIndex = this.contextBindings.findIndex((binding) => binding.contextName === contextName);
        if (foundIndex >= 0) {
            logger(`Deactivating key bindings for context ${contextName}`);
            this.removeContextFromStackAndKeyBindings(contextName);
        }
    }
    keyActionEvent(event) {
    }
}
KeyBindingManager.CONTEXT_Default = 'DEFAULT';
//# sourceMappingURL=KeyBindingManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/table/BasicTableRowImplementation.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/table/BasicTableRowImplementation.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BasicTableRowImplementation": () => (/* binding */ BasicTableRowImplementation)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _view_item_DefaultItemView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../view/item/DefaultItemView */ "./node_modules/ui-framework-jps/dist/framework/ui/view/item/DefaultItemView.js");
/* harmony import */ var _factory_ItemViewElementFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../factory/ItemViewElementFactory */ "./node_modules/ui-framework-jps/dist/framework/ui/factory/ItemViewElementFactory.js");
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");




const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('basic-table-row');
class BasicTableRowImplementation extends _view_item_DefaultItemView__WEBPACK_IMPORTED_MODULE_1__.DefaultItemView {
    constructor(idField, containerId, dataObjDef, configHelper, permissionChecker, hasExternalControl = false) {
        super(containerId, dataObjDef, configHelper, permissionChecker, hasExternalControl);
        this.idField = idField;
        this.__buildUIElements = this.__buildUIElements.bind(this);
        this.__getFactoryElements = this.__getFactoryElements.bind(this);
        this.__preDisplayCurrentDataObject = this.__preDisplayCurrentDataObject.bind(this);
        this._hidden = this._hidden.bind(this);
    }
    valueChanged(view, field, fieldDef, newValue) {
        super.valueChanged(view, field, fieldDef, newValue);
        logger(`values has changed - attempting save`);
        let event = {
            target: this,
            identifier: this.getId(),
            eventType: _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.SAVING
        };
        this.itemViewEvent(this.dataObjDef.displayName, event, this.currentDataObj);
    }
    getRowElement() {
        let result = null;
        if (this.factoryElements) {
            result = this.factoryElements.top;
        }
        return result;
    }
    __buildUIElements() {
        // do nothing here, we build our ui element just before display
        logger(`not loading ui elements yet, awaiting object`);
    }
    __getFactoryElements() {
        return _factory_ItemViewElementFactory__WEBPACK_IMPORTED_MODULE_2__.ItemViewElementFactory.getInstance().createTableRowElements(this.id, this, this.listeners, (this.uiDef), this.fieldListeners);
    }
    buildTableRowElements() {
        logger(`loading ui elements now using the super class`);
        super.__buildUIElements();
        logger(`Add ourselves to the container`);
        super._visible();
    }
    __preDisplayCurrentDataObject(dataObj) {
        this.id = dataObj[this.idField];
        logger(`pre-display data object id is ${this.id}`);
        this.buildTableRowElements();
    }
    _hidden() {
    }
}
//# sourceMappingURL=BasicTableRowImplementation.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/validation/ValidationHelperFunctions.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/validation/ValidationHelperFunctions.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ValidationHelperFunctions": () => (/* binding */ ValidationHelperFunctions)
/* harmony export */ });
/* harmony import */ var _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../model/DataObjectTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectTypeDefs.js");
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_2__);



const logger = debug__WEBPACK_IMPORTED_MODULE_2___default()('validation-helper-functions');
class ValidationHelperFunctions {
    constructor() {
    }
    static getInstance() {
        if (!(ValidationHelperFunctions._instance)) {
            ValidationHelperFunctions._instance = new ValidationHelperFunctions();
        }
        return ValidationHelperFunctions._instance;
    }
    areTwoFieldsEqual(targetField, sourceField) {
        let result = { ruleFailed: false };
        if (targetField.getValue() !== sourceField.getValue()) {
            result = {
                ruleFailed: true,
                message: `${targetField.getName()} must be equal to ${sourceField.getName()}`,
            };
        }
        return result;
    }
    isFieldAndValueEqual(field, value) {
        let result = { ruleFailed: false };
        if (field.getValue() !== value) {
            result = {
                ruleFailed: true,
                message: `${field.getName()} must be equal to ${value}`,
            };
        }
        return result;
    }
    compareTwoValuesWithTypes(targetType, targetValue, sourceType, sourceValue, comparison) {
        if (!(targetValue) || !(sourceValue))
            return false; // no null comparisons
        logger(`Comparing two values with types and comparison ${comparison} - target value (type:${targetType},value:${targetValue}), source value (type:${sourceType},value:${sourceValue})`);
        switch (targetType) {
            case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.date): {
                targetValue += ' 00:00:00';
                if (sourceType === _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.date) {
                    sourceValue += ' 00:00:00';
                }
                break;
            }
            case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.datetime): {
                if (sourceType === _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.date) {
                    sourceValue += ' 00:00:00';
                }
                break;
            }
            case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.time): {
                if (sourceType === _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.shortTime) {
                    sourceValue += ':00';
                }
                break;
            }
            case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.shortTime): {
                targetValue += ':00';
                if (sourceType === _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_0__.FieldType.shortTime) {
                    sourceValue += ':00';
                }
                break;
            }
        }
        logger(`Comparing ${targetValue} of type ${targetType} against ${sourceValue} of type ${sourceType}`);
        switch (comparison) {
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.lessThan: {
                return (targetValue < sourceValue);
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.lessThanEqual: {
                return (targetValue <= sourceValue);
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.greaterThanEqual: {
                return (targetValue >= sourceValue);
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.greaterThan: {
                return (targetValue > sourceValue);
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.equals: {
                return (targetValue === sourceValue);
            }
        }
        return false;
    }
    isTargetLessThanSource(targetField, sourceField) {
        let result = { ruleFailed: false };
        let sourceType = sourceField.getFieldDefinition().type;
        let targetType = targetField.getFieldDefinition().type;
        let sourceValue = sourceField.getValue();
        let targetValue = targetField.getValue();
        if (!this.compareTwoValuesWithTypes(targetType, targetValue, sourceType, sourceValue, _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.lessThan)) {
            result = {
                ruleFailed: true,
                message: `${targetField.getName()} must be less than ${sourceField.getName()}`,
            };
        }
        return result;
    }
    isFieldLessThanValue(field, value) {
        let result = { ruleFailed: false };
        let type = field.getFieldDefinition().type;
        let sourceValue = field.getValue();
        if (!this.compareTwoValuesWithTypes(type, sourceValue, type, value, _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.lessThan)) {
            result = {
                ruleFailed: true,
                message: `${field.getName()} must be less than ${value}`,
            };
        }
        return result;
    }
    isFieldLessThanEqualValue(field, value) {
        let result = { ruleFailed: false };
        let check = this.isFieldAndValueEqual(field, value);
        if (check.ruleFailed) {
            check = this.isFieldLessThanValue(field, value);
            if (check.ruleFailed) {
                result = {
                    ruleFailed: true,
                    message: `${field.getName()} must be less than or equal to ${value}`,
                };
            }
        }
        return result;
    }
    isFieldGreaterThanValue(field, value) {
        let result = { ruleFailed: false };
        let type = field.getFieldDefinition().type;
        let sourceValue = field.getValue();
        if (!this.compareTwoValuesWithTypes(type, sourceValue, type, value, _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.greaterThan)) {
            result = {
                ruleFailed: true,
                message: `${field.getName()} must be greater than ${value}`,
            };
        }
        return result;
    }
    isFieldGreaterThanEqualValue(field, value) {
        let result = { ruleFailed: false };
        let check = this.isFieldAndValueEqual(field, value);
        if (check.ruleFailed) {
            check = this.isFieldGreaterThanValue(field, value);
            if (check.ruleFailed) {
                result = {
                    ruleFailed: true,
                    message: `${field.getName()} must be greater than or equal to ${value}`,
                };
            }
        }
        return result;
    }
    isTargetLessThanEqualSource(targetField, sourceField) {
        let result = { ruleFailed: false };
        let check = this.areTwoFieldsEqual(targetField, sourceField);
        if (check.ruleFailed) {
            check = this.isTargetLessThanSource(targetField, sourceField);
            if (check.ruleFailed) {
                result = {
                    ruleFailed: true,
                    message: `${targetField.getName()} must be less than or equal to ${sourceField.getName()}`,
                };
            }
        }
        return result;
    }
    isTargetGreaterThan(targetField, sourceField) {
        let result = { ruleFailed: false };
        let sourceType = sourceField.getFieldDefinition().type;
        let targetType = targetField.getFieldDefinition().type;
        let sourceValue = sourceField.getValue();
        let targetValue = targetField.getValue();
        if (!this.compareTwoValuesWithTypes(targetType, targetValue, sourceType, sourceValue, _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.greaterThan)) {
            result = {
                ruleFailed: true,
                message: `${targetField.getName()} must be greater than ${sourceField.getName()}`,
            };
        }
        return result;
    }
    isFieldNull(sourceField) {
        let result = { ruleFailed: false };
        let targetValue = sourceField.getValue();
        // @ts-ignore
        logger(`field ${field.getId()} is null - current value is '${targetValue}'`);
        if ((targetValue) && (targetValue.trim().length > 0)) {
            result = {
                ruleFailed: true,
                message: `${sourceField.getName()} must be empty`,
            };
        }
        return result;
    }
    isFieldNotNull(field) {
        let result = { ruleFailed: false };
        let targetValue = field.getValue();
        logger(`field ${field.getId()} is NOT null - current value is '${targetValue}'`);
        // @ts-ignore
        if (targetValue) {
            if (targetValue.trim().length === 0) {
                result = {
                    ruleFailed: true,
                    message: `${field.getName()} must not be empty`,
                };
            }
        }
        else {
            result = {
                ruleFailed: true,
                message: `${field.getName()} must not be empty`,
            };
        }
        return result;
    }
    doesFieldHaveValue(field, values) {
        let result = { ruleFailed: false };
        let targetValue = field.getValue();
        logger(`does field ${field.getId()} have value from ${values} - current value is ${targetValue}`);
        if (targetValue) {
            // split the values by commas
            let foundInValue = false;
            values.forEach((split) => {
                if (targetValue === split) {
                    logger(`does field ${field.getId()} have value from ${values} - current value is ${targetValue} - found in value(s)`);
                    foundInValue = true;
                }
            });
            if (!foundInValue) {
                result = {
                    ruleFailed: true,
                    message: `${field.getName()} must be have a value in ${values}`,
                };
            }
        }
        return result;
    }
    doesSourceFieldHaveValue(field, values) {
        return this.doesFieldHaveValue(field, values);
    }
    isFieldNotValue(field, values) {
        let result = { ruleFailed: false };
        let targetValue = field.getValue();
        logger(`does field ${field.getId()} not match value from ${values} - current value is ${targetValue}`);
        if (targetValue) {
            // split the values by commas
            let foundInValue = false;
            values.forEach((split) => {
                if (targetValue === split) {
                    logger(`does field ${field.getId()} not match value from ${values} - current value is ${targetValue} - found in value(s)`);
                    foundInValue = true;
                }
            });
            if (foundInValue) {
                result = {
                    ruleFailed: true,
                    message: `${field.getName()} must not be a value in ${values}`,
                };
            }
        }
        return result;
    }
    sourceFieldIsNotValue(field, values) {
        return this.isFieldNotValue(field, values);
    }
    isTargetGreaterThanEqualSource(targetField, sourceField) {
        let result = { ruleFailed: false };
        let check = this.areTwoFieldsEqual(targetField, sourceField);
        if (check.ruleFailed) {
            check = this.isTargetGreaterThan(targetField, sourceField);
            if (check.ruleFailed) {
                result = {
                    ruleFailed: true,
                    message: `${targetField.getName()} must be greater than or equal to ${sourceField.getName()}`,
                };
            }
        }
        return result;
    }
    compareFields(targetField, sourceField, comparison, value) {
        switch (comparison) {
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.equals: {
                return this.areTwoFieldsEqual(targetField, sourceField);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.lessThan: {
                return this.isTargetLessThanSource(targetField, sourceField);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.lessThanEqual: {
                return this.isTargetLessThanEqualSource(targetField, sourceField);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.greaterThan: {
                return this.isTargetGreaterThan(targetField, sourceField);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.greaterThanEqual: {
                return this.isTargetGreaterThanEqualSource(targetField, sourceField);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.isNull: {
                return this.isFieldNull(sourceField);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.isNotNull: {
                return this.isFieldNotNull(sourceField);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.hasValue: {
                return this.doesSourceFieldHaveValue(sourceField, value);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.isNotValue: {
                return this.sourceFieldIsNotValue(sourceField, value);
                break;
            }
        }
    }
    compareFieldWithValue(field, comparison, value) {
        switch (comparison) {
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.equals: {
                return this.isFieldAndValueEqual(field, value[0]);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.lessThan: {
                return this.isFieldLessThanValue(field, value[0]);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.lessThanEqual: {
                return this.isFieldLessThanEqualValue(field, value[0]);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.greaterThan: {
                return this.isFieldGreaterThanValue(field, value[0]);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.greaterThanEqual: {
                return this.isFieldGreaterThanEqualValue(field, value[0]);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.isNull: {
                return this.isFieldNull(field);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.isNotNull: {
                return this.isFieldNotNull(field);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.hasValue: {
                return this.doesSourceFieldHaveValue(field, value);
                break;
            }
            case _CommonTypes__WEBPACK_IMPORTED_MODULE_1__.ComparisonType.isNotValue: {
                return this.sourceFieldIsNotValue(field, value);
                break;
            }
        }
    }
}
//# sourceMappingURL=ValidationHelperFunctions.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/validation/ValidationManager.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/validation/ValidationManager.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ValidationManager": () => (/* binding */ ValidationManager)
/* harmony export */ });
/* harmony import */ var _ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ValidationTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/ui/validation/ValidationTypeDefs.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../model/DataObjectTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectTypeDefs.js");
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");
/* harmony import */ var _ValidationHelperFunctions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ValidationHelperFunctions */ "./node_modules/ui-framework-jps/dist/framework/ui/validation/ValidationHelperFunctions.js");





const logger = debug__WEBPACK_IMPORTED_MODULE_1___default()('validation-manager');
const flogger = debug__WEBPACK_IMPORTED_MODULE_1___default()('validation-manager-rule-failure');
const erLogger = debug__WEBPACK_IMPORTED_MODULE_1___default()('validation-manager-execute-rule');
const merLogger = debug__WEBPACK_IMPORTED_MODULE_1___default()('validation-manager-multiple-condition-rule-results');
class ValidationManager {
    constructor() {
        this.viewRules = [];
        this.viewValidators = [];
    }
    static getInstance() {
        if (!(ValidationManager._instance)) {
            ValidationManager._instance = new ValidationManager();
        }
        return ValidationManager._instance;
    }
    addViewValidator(validator) {
        this.viewValidators.push(validator);
    }
    getName() {
        return "Validation Manager";
    }
    createRuleCondition(validatableView, targetField, rule, condition) {
        let result = null;
        if (!(condition.values) && !(condition.sourceDataFieldId)) { // direct field comparison
            logger(`Rule added for form ${validatableView.getId()} for target field ${rule.targetDataFieldId} - condition is a simple comparison of target field (isNull, isNotNull)`);
            if ((condition.comparison === _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ComparisonType.isNotNull) || (condition.comparison === _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ComparisonType.isNull)) {
                result = {
                    comparison: condition.comparison
                };
            }
            else {
                flogger(`Rule not added for form ${validatableView.getId()} for target field ${rule.targetDataFieldId} - condition is a simple comparison of target field (isNull, isNotNull) - comparison type is invalid`);
            }
        }
        else if ((condition.values) && (condition.sourceDataFieldId)) { // is this a target field value comparison?
            logger(`Rule adding for form ${validatableView.getId()} for target field ${rule.targetDataFieldId} - source field ${condition.sourceDataFieldId} with values ${condition.values}`);
            let sourceField = validatableView.getFieldFromDataFieldId(condition.sourceDataFieldId);
            if (!sourceField) {
                flogger(`Rule not added for form ${validatableView.getId()} for target field ${rule.targetDataFieldId} - source field ${condition.sourceDataFieldId} NOT FOUND`);
            }
            else {
                result = {
                    sourceField: sourceField,
                    comparison: condition.comparison,
                    values: condition.values
                };
                sourceField.addFieldListener(this);
            }
        }
        else if ((condition.values) && !(condition.sourceDataFieldId)) { // is this a value comparison?
            logger(`Rule adding for form ${validatableView.getId()} for target field ${rule.targetDataFieldId} - values ${condition.values}`);
            // add a new value rule to the internal structure
            result = { values: condition.values, comparison: condition.comparison };
            if (targetField)
                targetField.addFieldListener(this);
        }
        else if ((condition.sourceDataFieldId) && (!condition.values)) { // is this a field vs field comparison
            logger(`Rule adding for form ${validatableView.getId()} for target field ${rule.targetDataFieldId} - source field ${condition.sourceDataFieldId}`);
            let sourceField = validatableView.getFieldFromDataFieldId(condition.sourceDataFieldId);
            if (!sourceField) {
                flogger(`Rule not added for form ${validatableView.getId()} for target field ${rule.targetDataFieldId} - source field ${condition.sourceDataFieldId} NOT FOUND`);
            }
            else {
                if (this.canCompareSourceAndTarget(validatableView, rule, sourceField, targetField)) {
                    result = {
                        sourceField: sourceField,
                        comparison: condition.comparison
                    };
                    sourceField.addFieldListener(this);
                }
            }
        }
        return result;
    }
    canCompareSourceAndTarget(validatableView, rule, sourceField, targetField) {
        let result = true;
        /*
           are we comparing two fields that can be compared?
           allowed combinations are:
           date|datetime vs date|datetime
           time|short time vs time|short time
           boolean vs boolean
           integer|float vs number|float
           any other vs any other
         */
        let sourceType = sourceField.getFieldDefinition().type;
        let targetType = targetField === null || targetField === void 0 ? void 0 : targetField.getFieldDefinition().type;
        switch (targetType) {
            case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.date):
            case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.datetime): {
                if ((sourceType !== _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.datetime) &&
                    (sourceType !== _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.date)) {
                    flogger(`Rule not added for form ${validatableView.getId()} for target field ${rule.targetDataFieldId} - target is date(time), source is NOT`);
                    result = false;
                }
                break;
            }
            case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.time):
            case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.shortTime): {
                if ((sourceType !== _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.time) &&
                    (sourceType !== _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.shortTime)) {
                    flogger(`Rule not added for form ${validatableView.getId()} for target field ${rule.targetDataFieldId} - target is time, source is NOT`);
                    result = false;
                }
                break;
            }
            case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.boolean): {
                if ((sourceType !== _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.boolean)) {
                    flogger(`Rule not added for form ${validatableView.getId()} for target field ${rule.targetDataFieldId} - target is boolean, source is NOT`);
                    result = false;
                }
                break;
            }
            case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.integer):
            case (_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.float): {
                if ((sourceType !== _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.integer) &&
                    (sourceType !== _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_2__.FieldType.float)) {
                    flogger(`Rule not added for form ${validatableView.getId()} for target field ${rule.targetDataFieldId} - target is number, source is NOT`);
                    result = false;
                }
                break;
            }
        }
        return result;
    }
    addRuleToView(validatableView, rule) {
        logger(`Adding rule on form ${validatableView.getId()} for target field ${rule.targetDataFieldId}`);
        /*
         validate the rule
         1. does the rule have a comparison field or static for each condition?
         2. do the fields exist?
         3. are the comparisons valid types to compare?
        */
        let targetField = validatableView.getFieldFromDataFieldId(rule.targetDataFieldId);
        if (!targetField) {
            flogger(`Rule not added for form ${validatableView.getId()} for target field ${rule.targetDataFieldId} - NOT FOUND in form`);
        }
        else {
            let convertedRule = {
                viewMode: rule.viewMode,
                targetField: targetField,
                response: rule.response,
                conditions: [],
                multipleConditionLogic: _ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_0__.MultipleConditionLogic.failIfAnyConditionFails
            };
            if (rule.multipleConditionLogic) {
                convertedRule.multipleConditionLogic = rule.multipleConditionLogic;
            }
            if (rule.conditions) {
                rule.conditions.forEach((condition) => {
                    if (targetField) {
                        const convertedCondition = this.createRuleCondition(validatableView, targetField, rule, condition);
                        if (convertedCondition) {
                            convertedRule.conditions.push(convertedCondition);
                        }
                    }
                });
            }
            logger(`Converted rule to `);
            logger(convertedRule);
            logger(`Converted rule has ${convertedRule.conditions.length} conditions`);
            let index = this.viewRules.findIndex((viewRule) => viewRule.validatableView.getId() === validatableView.getId());
            let formRuleSet;
            // store the rules for later execution
            if (index < 0) {
                formRuleSet = {
                    validatableView: validatableView,
                    rules: []
                };
                formRuleSet.rules.push(convertedRule);
                this.viewRules.push(formRuleSet);
            }
            else {
                formRuleSet = this.viewRules[index];
                formRuleSet.rules.push(convertedRule);
            }
            logger(`Current set of rules for form ${validatableView.getId()}`);
            logger(formRuleSet);
        }
    }
    failedValidation(view, field, currentValue, message) {
    } // ignored, we might be causing
    applyRulesToTargetField(validatableView, viewMode, field, onlyRulesOfType) {
        logger(`Checking rules for form ${validatableView.getId()}, data field ${field.id} of type ${onlyRulesOfType}`);
        // which rules apply?
        let rules = this.getRulesForFieldChange(validatableView, field.id, false);
        let result = {
            ruleFailed: false
        };
        // get the rules for the field, filtered by the condition response type
        if (onlyRulesOfType) {
            logger(`Only validating rules of type ${onlyRulesOfType}`);
            let ruleSubset = [];
            rules.forEach((rule) => {
                if (rule.response === onlyRulesOfType) {
                    ruleSubset.push(rule);
                }
            });
            rules = ruleSubset;
        }
        rules.forEach((rule) => {
            let response = this.executeRule(viewMode, rule);
            if (response.ruleFailed) {
                flogger(`Rule failed for form ${validatableView.getId()} with field ${field.displayName} with message ${response.message}`);
                result.ruleFailed = true;
                result.message = response.message;
            }
        });
        // if we haven't failed yet and we have validators
        this.viewValidators.forEach((validator) => {
            let ruleCheck = validator.applyRulesToTargetField(validatableView, viewMode, field, onlyRulesOfType);
            if (ruleCheck.ruleFailed) {
                flogger(`FormFieldValidator - Rule failed for form ${validatableView.getId()} with field ${field.displayName} with message ${ruleCheck.message}`);
                result.ruleFailed = true;
                result.message = ruleCheck.message;
            }
        });
        return result;
    }
    valueChanged(view, field, fieldDef, newValue) {
        logger(`Handling field change - form ${view}, data field ${fieldDef.id}, value ${newValue}`);
        // a field we are listening to has changed
        // which rules apply?
        const rules = this.getRulesForFieldChange(view, fieldDef.id, true);
        // execute each rule and collect the responses
        let failedResponses = [];
        rules.forEach((rule) => {
            let response = this.executeRule(view.getViewMode(), rule);
            if (response.ruleFailed) {
                failedResponses.push(response);
            }
        });
        logger(`Have ${failedResponses.length} failed rules - applying each`);
        // for each failed response let the target field know based on the response type
        failedResponses.forEach((response) => {
            switch (response.response) {
                case _ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_0__.ConditionResponse.hide: {
                    logger(`Apply hide ${response.field.getId()}`);
                    response.field.hide();
                    break;
                }
                case _ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_0__.ConditionResponse.show: {
                    logger(`Apply show ${response.field.getId()}`);
                    response.field.show();
                    break;
                }
                case _ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_0__.ConditionResponse.invalid: {
                    logger(`Apply invalid ${response.field.getId()}`);
                    if (response.message)
                        response.field.setInvalid(response.message);
                    break;
                }
                case _ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_0__.ConditionResponse.valid: {
                    logger(`Apply valid ${response.field.getId()}`);
                    response.field.setValid();
                    break;
                }
            }
        });
    }
    executeRule(formMode, rule) {
        let response = {
            field: rule.targetField,
            ruleFailed: false,
            response: rule.response,
        };
        // run each field comparison
        erLogger(`Executing rule with response ${rule.response} for target ${rule.targetField.getId()}`);
        erLogger(rule);
        let ruleChecks = [];
        if (rule.conditions.length > 0) {
            rule.conditions.forEach((condition) => {
                erLogger('condition rule');
                erLogger(condition);
                let values = [''];
                if (condition.values) {
                    values = condition.values;
                }
                let ruleCheck;
                if (condition.sourceField) {
                    erLogger('condition rule - source field present');
                    ruleCheck = _ValidationHelperFunctions__WEBPACK_IMPORTED_MODULE_4__.ValidationHelperFunctions.getInstance().compareFields(rule.targetField, condition.sourceField, condition.comparison, values);
                }
                else {
                    erLogger(`condition rule - target field value check - ${values}`);
                    ruleCheck = _ValidationHelperFunctions__WEBPACK_IMPORTED_MODULE_4__.ValidationHelperFunctions.getInstance().compareFieldWithValue(rule.targetField, condition.comparison, values);
                }
                ruleChecks.push(ruleCheck);
                if (ruleCheck.ruleFailed) {
                    flogger('condition rule FAILED');
                }
                else {
                    flogger('condition rule PASSED');
                }
            });
            // are we dealing with one rule check or multiple?
            if (ruleChecks.length === 1) {
                flogger(`Single rule check - rule failed? ${ruleChecks[0].ruleFailed}`);
                response.message = ruleChecks[0].message;
                response.ruleFailed = ruleChecks[0].ruleFailed;
            }
            else {
                let errorMessageBuffer = '';
                let failedRuleChecks = [];
                ruleChecks.forEach((ruleCheck, index) => {
                    if (ruleCheck.ruleFailed) {
                        ruleCheck.index = index;
                        failedRuleChecks.push(ruleCheck);
                        errorMessageBuffer += ruleCheck.message + ', ';
                    }
                });
                if (errorMessageBuffer.length > 0) {
                    errorMessageBuffer = errorMessageBuffer.substr(0, errorMessageBuffer.length - 2);
                }
                merLogger(`Multiple rule check - number of failures ${failedRuleChecks.length} with message ${errorMessageBuffer}`);
                switch (rule.multipleConditionLogic) {
                    case _ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_0__.MultipleConditionLogic.failIfAnyConditionFails: {
                        if (failedRuleChecks.length > 0) {
                            flogger(`Multiple rule check - when any conditions fail - rule FAILED`);
                            merLogger(`Multiple rule check - when any conditions fail - rule FAILED`);
                            response.message = errorMessageBuffer;
                            response.ruleFailed = true;
                        }
                        break;
                    }
                    case _ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_0__.MultipleConditionLogic.onlyFailIfAllConditionsFail: {
                        if (failedRuleChecks.length === ruleChecks.length) {
                            flogger(`Multiple rule check - when all conditions fail - rule FAILED`);
                            merLogger(`Multiple rule check - when all conditions fail - rule FAILED`);
                            response.ruleFailed = true;
                            response.message = errorMessageBuffer;
                        }
                        break;
                    }
                    case _ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_0__.MultipleConditionLogic.failWhenTheNextInSequenceFails: {
                        if (failedRuleChecks.length > 0) {
                            flogger(`Multiple rule check - when next in sequence fails - rule FAILED`);
                            merLogger(`Multiple rule check - when next in sequence fails - rule FAILED`);
                            response.message = errorMessageBuffer;
                            response.ruleFailed = true;
                        }
                        break;
                    }
                    case _ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_0__.MultipleConditionLogic.whenAllConditionsFailRuleShouldNotBeApplied: {
                        if ((failedRuleChecks.length === ruleChecks.length) || (failedRuleChecks.length === 0)) {
                            merLogger(`Multiple rule check - when all fail rule does not apply - rule PASSED`);
                            response.ruleFailed = false;
                            response.message = errorMessageBuffer;
                        }
                        else {
                            flogger(`Multiple rule check - when all fail rule does not apply - rule FAILED`);
                            merLogger(`Multiple rule check - when all fail rule does not apply - rule FAILED`);
                            response.ruleFailed = true;
                            response.message = errorMessageBuffer;
                        }
                        break;
                    }
                    case _ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_0__.MultipleConditionLogic.failOnlyIfFinalConditionIsAFailAndPreviousConditionsAreNotFails: {
                        if (failedRuleChecks.length === 1) {
                            const failedRuleIndex = failedRuleChecks[0].index;
                            // is this the last rule in the chain of conditions?
                            if (failedRuleIndex === (ruleChecks.length - 1)) {
                                flogger(`Multiple rule check - only if final is a fail, others are not fails - rule FAILED`);
                                merLogger(`Multiple rule check - only if final is a fail, others are not fails - rule FAILED`);
                                response.message = errorMessageBuffer;
                                response.ruleFailed = true;
                            }
                        }
                        break;
                    }
                }
            }
        }
        else {
            // no conditions, should be based on the form mode only
            if ((rule.viewMode === formMode) || (rule.viewMode === _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ViewMode.any)) {
                response.ruleFailed = true;
                response.message = '';
                erLogger(`Zero condition rule applied with matching form mode`);
            }
        }
        // for show and hide rules, we want the opposite effect (i.e. a success on conditions show cause the action)
        if ((response.response === _ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_0__.ConditionResponse.hide) || (response.response === _ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_0__.ConditionResponse.show)) {
            erLogger(`Changing show/hide rule result to opposite boolean value to cause activation if the conditions were PASSED`);
            response.ruleFailed = !response.ruleFailed;
        }
        return response;
    }
    getRulesForFieldChange(validatableView, dataFieldId, includeSourceFields) {
        let rules = [];
        const viewMode = validatableView.getViewMode();
        // lets go through the rules for the form
        logger(`Finding rules for form ${validatableView} and data field ${dataFieldId}`);
        let index = this.viewRules.findIndex((formRule) => formRule.validatableView.getId() === validatableView.getId());
        if (index >= 0) {
            const ruleSet = this.viewRules[index];
            // the dataFieldId could be the target or one of the sources
            ruleSet.rules.forEach((rule) => {
                // check the rule applies to the current form mode
                const ruleViewMode = rule.viewMode;
                logger(`Rule applies to mode ${ruleViewMode} (any? ${(ruleViewMode === _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ViewMode.any)}) and current form mode is ${viewMode}`);
                if ((ruleViewMode === _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ViewMode.any) ||
                    (ruleViewMode === viewMode)) {
                    if (rule.targetField.getId() === dataFieldId) {
                        logger(`Found rule where data field ${dataFieldId} is target`);
                        if (rule.targetField.isValid()) {
                            rules.push(rule);
                        }
                        else {
                            flogger(`Found rule where data field ${dataFieldId} is target but value is not currently valid`);
                        }
                    }
                    else {
                        if (includeSourceFields) {
                            // rule.fieldConditions.every((value: { sourceField: Field, comparison: ComparisonType }) => {
                            rule.conditions.forEach((condition) => {
                                if (condition.sourceField) {
                                    if (condition.sourceField.getId() === dataFieldId) {
                                        logger(`Found rule where data field ${dataFieldId} is source`);
                                        if (condition.sourceField.isValid()) {
                                            rules.push(rule);
                                        }
                                        else {
                                            flogger(`Found rule where data field ${dataFieldId} is source but value is not currently valid`);
                                        }
                                    }
                                }
                            });
                        }
                    }
                }
            });
        }
        return rules;
    }
}
//# sourceMappingURL=ValidationManager.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/validation/ValidationTypeDefs.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/validation/ValidationTypeDefs.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConditionResponse": () => (/* binding */ ConditionResponse),
/* harmony export */   "MultipleConditionLogic": () => (/* binding */ MultipleConditionLogic)
/* harmony export */ });
var ConditionResponse;
(function (ConditionResponse) {
    ConditionResponse[ConditionResponse["show"] = 0] = "show";
    ConditionResponse[ConditionResponse["hide"] = 1] = "hide";
    ConditionResponse[ConditionResponse["invalid"] = 2] = "invalid";
    ConditionResponse[ConditionResponse["valid"] = 3] = "valid";
})(ConditionResponse || (ConditionResponse = {}));
var MultipleConditionLogic;
(function (MultipleConditionLogic) {
    MultipleConditionLogic[MultipleConditionLogic["onlyFailIfAllConditionsFail"] = 0] = "onlyFailIfAllConditionsFail";
    MultipleConditionLogic[MultipleConditionLogic["failIfAnyConditionFails"] = 1] = "failIfAnyConditionFails";
    MultipleConditionLogic[MultipleConditionLogic["failWhenTheNextInSequenceFails"] = 2] = "failWhenTheNextInSequenceFails";
    MultipleConditionLogic[MultipleConditionLogic["whenAllConditionsFailRuleShouldNotBeApplied"] = 3] = "whenAllConditionsFailRuleShouldNotBeApplied";
    MultipleConditionLogic[MultipleConditionLogic["failOnlyIfFinalConditionIsAFailAndPreviousConditionsAreNotFails"] = 4] = "failOnlyIfFinalConditionIsAFailAndPreviousConditionsAreNotFails";
})(MultipleConditionLogic || (MultipleConditionLogic = {}));
//# sourceMappingURL=ValidationTypeDefs.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/CollectionViewEventHandlerDelegate.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/CollectionViewEventHandlerDelegate.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CollectionViewEventHandlerDelegate": () => (/* binding */ CollectionViewEventHandlerDelegate)
/* harmony export */ });
/* harmony import */ var _implementation_AbstractView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../implementation/AbstractView */ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractView.js");
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var _alert_AlertManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../alert/AlertManager */ "./node_modules/ui-framework-jps/dist/framework/ui/alert/AlertManager.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _alert_AlertListener__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../alert/AlertListener */ "./node_modules/ui-framework-jps/dist/framework/ui/alert/AlertListener.js");
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");






const logger = debug__WEBPACK_IMPORTED_MODULE_3___default()('collection-view-event-handler-delegate');
class CollectionViewEventHandlerDelegate {
    constructor(view, forwarder) {
        this.selectedItem = null;
        this.view = view;
        this.eventForwarder = forwarder;
        // event handlers
        this.eventStartDrag = this.eventStartDrag.bind(this);
        this.eventActionClicked = this.eventActionClicked.bind(this);
        this.eventClickItem = this.eventClickItem.bind(this);
        this.eventDeleteClickItem = this.eventDeleteClickItem.bind(this);
    }
    getDragData(event) {
        var _a, _b;
        const context = this.getItemContext(event);
        let itemId = context.itemId;
        const dataSource = context.dataSource;
        if (this.view.getCollectionUIConfig().keyType === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.KeyType.number) { // @ts-ignore
            itemId = parseInt(itemId);
        }
        logger(`view ${this.view.getName()}: Item with id ${itemId} getting drag data from ${dataSource}`);
        let compareWith = {};
        // @ts-ignore
        compareWith[this.view.getCollectionUIConfig().keyId] = itemId;
        let selectedItem = {};
        selectedItem = this.view.getItemInNamedCollection(this.view.getCollectionName(), compareWith);
        if (selectedItem) {
            // @ts-ignore
            selectedItem[_CommonTypes__WEBPACK_IMPORTED_MODULE_5__.DRAGGABLE_TYPE] = (_a = this.view.getCollectionUIConfig().detail.drag) === null || _a === void 0 ? void 0 : _a.type;
            // @ts-ignore
            selectedItem[_CommonTypes__WEBPACK_IMPORTED_MODULE_5__.DRAGGABLE_FROM] = (_b = this.view.getCollectionUIConfig().detail.drag) === null || _b === void 0 ? void 0 : _b.from;
        }
        return selectedItem;
    }
    eventStartDrag(event) {
        logger(`view ${this.view.getName()}: drag start`);
        logger(event.target);
        const data = JSON.stringify(this.getDragData(event));
        logger(data);
        // @ts-ignore
        event.dataTransfer.setData(_CommonTypes__WEBPACK_IMPORTED_MODULE_5__.DRAGGABLE_KEY_ID, data);
        (this.eventForwarder).itemDragStarted(this.view, data);
    }
    eventClickItem(event) {
        event.preventDefault();
        event.stopPropagation();
        const context = this.getItemContext(event);
        let itemId = context.itemId;
        const dataSource = context.dataSource;
        if (this.view.getCollectionUIConfig().keyType === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.KeyType.number) { // @ts-ignore
            itemId = parseInt(itemId);
        }
        logger(`view ${this.view.getName()}: Item with id ${itemId} clicked from ${dataSource}`);
        let compareWith = {};
        // @ts-ignore
        compareWith[this.view.getCollectionUIConfig().keyId] = itemId;
        logger(compareWith);
        let selectedItem = this.view.getItemInNamedCollection(this.view.getCollectionName(), compareWith);
        logger(selectedItem);
        if (selectedItem) {
            const shouldSelect = (this.eventForwarder).canSelectItem(this.view, selectedItem);
            logger(`view ${this.view.getName()}: Item with id ${itemId} attempting selected from ${dataSource} - ${shouldSelect}`);
            if (shouldSelect) {
                this.selectedItem = selectedItem;
                logger(selectedItem);
                (this.eventForwarder).itemSelected(this.view, selectedItem);
            }
        }
    }
    eventDeleteClickItem(event) {
        event.preventDefault();
        event.stopPropagation();
        const context = this.getItemContext(event);
        let itemId = context.itemId;
        const dataSource = context.dataSource;
        if (this.view.getCollectionUIConfig().keyType === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.KeyType.number) { // @ts-ignore
            itemId = parseInt(itemId);
        }
        logger(`view ${this.view.getName()}: Item with id ${itemId} attempting delete from ${dataSource}`);
        let compareWith = {};
        // @ts-ignore
        compareWith[this.view.getCollectionUIConfig().keyId] = itemId;
        logger(compareWith);
        let selectedItem = this.view.getItemInNamedCollection(this.view.getCollectionName(), compareWith);
        if (selectedItem) {
            const shouldDelete = this.eventForwarder.canDeleteItem(this.view, selectedItem);
            logger(`view ${this.view.getName()}: Item with id ${itemId} attempting delete from ${dataSource} - ${shouldDelete}`);
            if (shouldDelete) {
                // do we need to confirm?
                if (this.view.getCollectionUIConfig().detail.quickDelete) {
                    this.selectedItem = null;
                    this.eventForwarder.itemDeleted(this.view, selectedItem, event.target);
                }
                else {
                    _alert_AlertManager__WEBPACK_IMPORTED_MODULE_2__.AlertManager.getInstance().startAlert(this, this.view.getName(), `Are you sure you want to delete this information?`, { actionType: _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.ActionType.DELETE, item: selectedItem, target: event.target });
                }
            }
        }
    }
    eventActionClicked(event) {
        event.preventDefault();
        event.stopPropagation();
        const context = this.getItemContext(event);
        let itemId = context.itemId;
        const dataSource = context.dataSource;
        // @ts-ignore
        const actionName = event.target.getAttribute(_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.EXTRA_ACTION_ATTRIBUTE_NAME);
        // get the action def
        const uiConfig = this.view.getCollectionUIConfig();
        let actionConfig = null;
        if (uiConfig.extraActions) {
            const foundIndex = uiConfig.extraActions.findIndex((extraAction) => extraAction.name === actionName);
            if (foundIndex >= 0)
                actionConfig = uiConfig.extraActions[foundIndex];
        }
        const shouldConfirm = ((actionConfig) && (actionConfig.confirm));
        if (this.view.getCollectionUIConfig().keyType === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.KeyType.number) { // @ts-ignore
            itemId = parseInt(itemId);
        }
        logger(`view ${this.view.getName()}: Item with id ${itemId} attempting action ${actionName} from ${dataSource}`);
        let compareWith = {};
        // @ts-ignore
        compareWith[this.view.getCollectionUIConfig().keyId] = itemId;
        logger(compareWith);
        let selectedItem = this.view.getItemInNamedCollection(this.view.getCollectionName(), compareWith);
        if (selectedItem) {
            const shouldSelect = (this.eventForwarder).canSelectItem(this.view, selectedItem);
            logger(`view ${this.view.getName()}: Item with id ${itemId} attempting action ${actionName} from ${dataSource} - ${shouldSelect}`);
            if (shouldSelect) {
                // do we need to confirm action?
                if (shouldConfirm) {
                    _alert_AlertManager__WEBPACK_IMPORTED_MODULE_2__.AlertManager.getInstance().startAlert(this, this.view.getName(), `${actionName}: please confirm this action`, { actionType: _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.ActionType.EXTRA_ACTION, actionName: actionName, item: selectedItem, target: event.target });
                }
                else {
                    this.selectedItem = selectedItem;
                    logger(selectedItem);
                    this.eventForwarder.itemAction(this.view, actionName, selectedItem, event.target);
                }
            }
        }
    }
    alertCompleted(event) {
        logger(event.context);
        if (event.outcome === _alert_AlertListener__WEBPACK_IMPORTED_MODULE_4__.AlertType.confirmed) {
            if (event.context.actionType === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.ActionType.DELETE) {
                this.selectedItem = null;
                this.eventForwarder.itemDeleted(this.view, event.context.item, event.context.target);
            }
            if (event.context.actionType === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.ActionType.EXTRA_ACTION) {
                this.selectedItem = event.context.item;
                this.eventForwarder.itemAction(this.view, event.context.actionName, event.context.item, event.context.target);
            }
        }
    }
    getItemContext(event) {
        // @ts-ignore
        const itemId = event.target.getAttribute(this.view.getCollectionUIConfig().keyId);
        // @ts-ignore
        const dataSource = event.target.getAttribute(_implementation_AbstractView__WEBPACK_IMPORTED_MODULE_0__.AbstractView.DATA_SOURCE);
        let context = {
            itemId: itemId,
            dataSource: dataSource
        };
        return context;
    }
}
//# sourceMappingURL=CollectionViewEventHandlerDelegate.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/CollectionViewEventHandlerDelegateUsingContext.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/CollectionViewEventHandlerDelegateUsingContext.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CollectionViewEventHandlerDelegateUsingContext": () => (/* binding */ CollectionViewEventHandlerDelegateUsingContext)
/* harmony export */ });
/* harmony import */ var _CollectionViewEventHandlerDelegate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CollectionViewEventHandlerDelegate */ "./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/CollectionViewEventHandlerDelegate.js");
/* harmony import */ var _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../context/ContextualInformationHelper */ "./node_modules/ui-framework-jps/dist/framework/ui/context/ContextualInformationHelper.js");


class CollectionViewEventHandlerDelegateUsingContext extends _CollectionViewEventHandlerDelegate__WEBPACK_IMPORTED_MODULE_0__.CollectionViewEventHandlerDelegate {
    constructor(view, forwarder) {
        super(view, forwarder);
    }
    getItemContext(event) {
        const contextDetail = _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_1__.ContextualInformationHelper.getInstance().findContextFromEvent(event);
        let context;
        if (contextDetail) {
            context = {
                itemId: contextDetail.identifier,
                dataSource: contextDetail.source
            };
        }
        else {
            context = {
                itemId: '',
                dataSource: this.view.getName(),
            };
        }
        return context;
    }
}
//# sourceMappingURL=CollectionViewEventHandlerDelegateUsingContext.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/CollectionViewListenerForwarder.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/CollectionViewListenerForwarder.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CollectionViewListenerForwarder": () => (/* binding */ CollectionViewListenerForwarder)
/* harmony export */ });
/* harmony import */ var _ViewListenerForwarder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewListenerForwarder */ "./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/ViewListenerForwarder.js");

class CollectionViewListenerForwarder extends _ViewListenerForwarder__WEBPACK_IMPORTED_MODULE_0__.ViewListenerForwarder {
    constructor() {
        super();
        this.collectionViewListeners = [];
    }
    addListener(listener) {
        super.addListener(listener);
        this.collectionViewListeners.push(listener);
    }
    itemDragStarted(view, selectedItem) {
        if (!this.suppressEventEmits) {
            this.collectionViewListeners.forEach((listener) => listener.itemDragStarted(view, selectedItem));
        }
    }
    itemSelected(view, selectedItem) {
        if (!this.suppressEventEmits) {
            this.collectionViewListeners.forEach((listener) => listener.itemSelected(view, selectedItem));
        }
    }
    itemDeselected(view, deselectedItem) {
        if (!this.suppressEventEmits) {
            this.collectionViewListeners.forEach((listener) => listener.itemDeselected(view, deselectedItem));
        }
    }
    canSelectItem(view, selectedItem) {
        let result = true; // return false if cancelling delete
        if (!this.suppressEventEmits) {
            this.collectionViewListeners.forEach((listener) => {
                if (!(listener.canSelectItem(view, selectedItem))) {
                    result = false;
                }
            });
        }
        return result;
    }
    collectionChanged(view) {
        if (!this.suppressEventEmits) {
            this.collectionViewListeners.forEach((listener) => listener.collectionChanged(view));
        }
    }
}
//# sourceMappingURL=CollectionViewListenerForwarder.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/DetailViewListenerForwarder.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/DetailViewListenerForwarder.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DetailViewListenerForwarder": () => (/* binding */ DetailViewListenerForwarder)
/* harmony export */ });
/* harmony import */ var _ViewListenerForwarder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewListenerForwarder */ "./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/ViewListenerForwarder.js");

class DetailViewListenerForwarder extends _ViewListenerForwarder__WEBPACK_IMPORTED_MODULE_0__.ViewListenerForwarder {
    constructor() {
        super();
        this.detailViewListeners = [];
    }
    addListener(listener) {
        super.addListener(listener);
        this.detailViewListeners.push(listener);
    }
    saveNewItem(view, dataObj) {
        if (!this.suppressEventEmits) {
            this.detailViewListeners.forEach((listener) => listener.saveNewItem(view, dataObj));
        }
    }
    updateItem(view, dataObj) {
        if (!this.suppressEventEmits) {
            this.detailViewListeners.forEach((listener) => listener.updateItem(view, dataObj));
        }
    }
    deletedItem(view, dataObj) {
        if (!this.suppressEventEmits) {
            this.detailViewListeners.forEach((listener) => listener.deletedItem(view, dataObj));
        }
    }
    cancelled(view, dataObj) {
        if (!this.suppressEventEmits) {
            this.detailViewListeners.forEach((listener) => listener.cancelled(view, dataObj));
        }
    }
}
//# sourceMappingURL=DetailViewListenerForwarder.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/ViewListenerForwarder.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/ViewListenerForwarder.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ViewListenerForwarder": () => (/* binding */ ViewListenerForwarder)
/* harmony export */ });
class ViewListenerForwarder {
    constructor() {
        this.suppressEventEmits = false;
        this.viewListeners = [];
    }
    addListener(listener) {
        this.viewListeners.push(listener);
    }
    suppressEvents() {
        this.suppressEventEmits = true;
    }
    emitEvents() {
        this.suppressEventEmits = false;
    }
    itemDeleted(view, selectedItem, target) {
        if (!this.suppressEventEmits) {
            this.viewListeners.forEach((listener) => listener.itemDeleted(view, selectedItem, target));
        }
    }
    documentLoaded(view) {
        if (!this.suppressEventEmits) {
            this.viewListeners.forEach((listener) => listener.documentLoaded(view));
        }
    }
    itemAction(view, actionName, selectedItem, target) {
        if (!this.suppressEventEmits) {
            this.viewListeners.forEach((listener) => listener.itemAction(view, actionName, selectedItem, target));
        }
    }
    canDeleteItem(view, selectedItem) {
        let result = true; // return false if cancelling delete
        if (!this.suppressEventEmits) {
            this.viewListeners.forEach((listener) => {
                if (!(listener.canDeleteItem(view, selectedItem))) {
                    result = false;
                }
            });
        }
        return result;
    }
    hideRequested(view) {
        if (!this.suppressEventEmits) {
            this.viewListeners.forEach((listener) => listener.hideRequested(view));
        }
    }
    showRequested(view) {
        if (!this.suppressEventEmits) {
            this.viewListeners.forEach((listener) => listener.showRequested(view));
        }
    }
    itemDropped(view, droppedItem) {
        if (!this.suppressEventEmits) {
            this.viewListeners.forEach((listener) => listener.itemDropped(view, droppedItem));
        }
    }
}
//# sourceMappingURL=ViewListenerForwarder.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractCollectionView.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractCollectionView.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractCollectionView": () => (/* binding */ AbstractCollectionView)
/* harmony export */ });
/* harmony import */ var _AbstractView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractView */ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractView.js");
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var _util_EqualityFunctions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/EqualityFunctions */ "./node_modules/ui-framework-jps/dist/framework/util/EqualityFunctions.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _delegate_CollectionViewListenerForwarder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../delegate/CollectionViewListenerForwarder */ "./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/CollectionViewListenerForwarder.js");
/* harmony import */ var _delegate_CollectionViewEventHandlerDelegate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../delegate/CollectionViewEventHandlerDelegate */ "./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/CollectionViewEventHandlerDelegate.js");
/* harmony import */ var _helper_CollectionViewProcessor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../helper/CollectionViewProcessor */ "./node_modules/ui-framework-jps/dist/framework/ui/helper/CollectionViewProcessor.js");







const avLogger = debug__WEBPACK_IMPORTED_MODULE_3___default()('collection-view-ts');
const avLoggerDetails = debug__WEBPACK_IMPORTED_MODULE_3___default()('collection-view-ts-detail');
const avLoggerFilter = debug__WEBPACK_IMPORTED_MODULE_3___default()('collection-view-ts-filter');
class AbstractCollectionView extends _AbstractView__WEBPACK_IMPORTED_MODULE_0__.AbstractView {
    constructor(uiConfig, collectionName) {
        super(uiConfig.viewConfig);
        this.filter = null;
        this.sorterConfig = null;
        this.onlyDisplayWithFilter = false;
        this.buffers = [];
        this.collectionUIConfig = uiConfig;
        this.collectionName = collectionName;
        this.renderer = null;
        let forwarder = new _delegate_CollectionViewListenerForwarder__WEBPACK_IMPORTED_MODULE_4__.CollectionViewListenerForwarder();
        this.eventForwarder = forwarder;
        this.eventHandlerDelegate = new _delegate_CollectionViewEventHandlerDelegate__WEBPACK_IMPORTED_MODULE_5__.CollectionViewEventHandlerDelegate(this, forwarder);
        this.updateViewForNamedCollection = this.updateViewForNamedCollection.bind(this);
        // event handlers
        this.eventStartDrag = this.eventStartDrag.bind(this);
        this.eventActionClicked = this.eventActionClicked.bind(this);
        this.eventClickItem = this.eventClickItem.bind(this);
        this.eventDeleteClickItem = this.eventDeleteClickItem.bind(this);
        this.useSorter = this.useSorter.bind(this);
    }
    setBufferForName(name, values) {
        const foundIndex = this.buffers.findIndex((buffer) => buffer.name === name);
        let buffer = {
            name: name,
            values: values
        };
        if (foundIndex < 0) {
            this.buffers.push(buffer);
        }
        else {
            this.buffers.splice(foundIndex, 1, buffer);
        }
    }
    getBufferForName(name) {
        const foundIndex = this.buffers.findIndex((buffer) => buffer.name === name);
        let result = [];
        if (foundIndex >= 0) {
            result = this.buffers[foundIndex].values;
        }
        return result;
    }
    render() {
        avLogger('ACV render');
        this.updateViewForNamedCollection(this.collectionName, this.getBufferForName(this.collectionName));
    }
    clearDisplay() {
        avLogger('ACV clearDisplay');
        this.updateViewForNamedCollection(this.collectionName, []);
    }
    eventStartDrag(event) {
        this.eventHandlerDelegate.eventStartDrag(event);
    }
    eventClickItem(event) {
        this.eventHandlerDelegate.eventClickItem(event);
    }
    eventDeleteClickItem(event) {
        this.eventHandlerDelegate.eventDeleteClickItem(event);
    }
    eventActionClicked(event) {
        this.eventHandlerDelegate.eventActionClicked(event);
    }
    getCollectionName() {
        return this.collectionName;
    }
    getItemId(from, item) {
        return this.getIdForItemInNamedCollection(from, item);
    }
    getCollectionUIConfig() {
        return this.collectionUIConfig;
    }
    addEventCollectionListener(listener) {
        this.eventForwarder.addListener(listener);
    }
    setContainedBy(container) {
        super.setContainedBy(container);
        if (this.uiConfig.drop) {
            avLoggerDetails(`view ${this.getName()}: Adding dragover events to ${this.uiConfig.dataSourceId}`);
            avLoggerDetails(container);
            container.addEventListener('dragover', (event) => {
                event.preventDefault();
            });
            container.addEventListener('drop', this.handleDrop);
        }
    }
    onDocumentLoaded() {
        super.onDocumentLoaded();
        if (this.renderer)
            this.renderer.onDocumentLoaded();
    }
    renderBackgroundForItemInNamedCollection(containerEl, name, item) {
    }
    compareItemsForEquality(item1, item2) {
        return (0,_util_EqualityFunctions__WEBPACK_IMPORTED_MODULE_2__.isSame)(item1, item2);
    }
    getModifierForItemInNamedCollection(name, item) {
        return _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.normal;
    }
    getSecondaryModifierForItemInNamedCollection(name, item) {
        return _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.normal;
    }
    getBadgeValueForItemInNamedCollection(name, item) {
        return 0;
    }
    getBackgroundImageForItemInNamedCollection(name, item) {
        return '';
    }
    useFieldSorter(item1, item2, fieldId, direction) {
        let result = 0;
        const field1Value = item1[fieldId];
        const field2Value = item2[fieldId];
        if (field1Value) {
            if (field2Value) {
                if (direction === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.CollectionViewSorterDirection.ascending) {
                    if (field1Value >= field2Value) {
                        if (field1Value === field2Value) {
                            result = 0;
                        }
                        else {
                            result = -1;
                        }
                    }
                }
                if (direction === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.CollectionViewSorterDirection.descending) {
                    if (field1Value <= field2Value) {
                        if (field1Value === field2Value) {
                            result = 0;
                        }
                        else {
                            result = 1;
                        }
                    }
                }
            }
            else {
                if (direction === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.CollectionViewSorterDirection.ascending) {
                    result = -1;
                }
                if (direction === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.CollectionViewSorterDirection.descending) {
                    result = 1;
                }
            }
        }
        else {
            if (field2Value) {
                if (direction === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.CollectionViewSorterDirection.ascending) {
                    result = -1;
                }
                if (direction === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.CollectionViewSorterDirection.descending) {
                    result = 1;
                }
            }
        }
        return result;
    }
    useSorter(item1, item2) {
        let result = 0;
        if (this.sorterConfig) {
            result = this.useFieldSorter(item1, item2, this.sorterConfig.majorFieldId, this.sorterConfig.majorDirection);
            if (result === 0) {
                if (this.sorterConfig.minorFieldId) {
                    if (this.sorterConfig.minorDirection) {
                        result = this.useFieldSorter(item1, item2, this.sorterConfig.minorFieldId, this.sorterConfig.minorDirection);
                    }
                }
            }
        }
        return result;
    }
    getFilteredState(currentState) {
        let filteredState = [];
        // do we have a filter?
        if (this.filter) {
            if (currentState) {
                currentState.forEach((item) => {
                    // @ts-ignore
                    if (_helper_CollectionViewProcessor__WEBPACK_IMPORTED_MODULE_6__.CollectionViewProcessor.doesItemMatchFilterConfig(this.collectionName, item, this.filter)) {
                        filteredState.push(item);
                    }
                });
            }
        }
        else {
            // do we only show content with a filter?
            if (this.onlyDisplayWithFilter) {
                filteredState = [];
            }
            else {
                filteredState = currentState;
            }
        }
        return filteredState;
    }
    updateViewForNamedCollection(name, newState) {
        avLogger(`update named collection ${name} with new state`);
        avLogger(newState);
        if (this.viewEl && this.renderer) {
            if (this.isVisible) {
                avLogger('rendering visible state with filtering and sorting as required');
                let filteredState = this.getFilteredState(newState);
                // do we have a sorter?
                if (this.sorterConfig && (filteredState.length > 0)) {
                    filteredState = filteredState.sort(this.useSorter);
                }
                else {
                    // pre sort the collection for display
                    filteredState = filteredState.sort(this.applyDefaultSort);
                }
                this.renderer.setDisplayElementsForCollectionInContainer(this.viewEl, name, filteredState);
            }
            else {
                avLogger('rendering visible state as empty');
                this.renderer.setDisplayElementsForCollectionInContainer(this.viewEl, name, []);
            }
        }
        else {
            avLogger('missing renderer and/or view element');
            avLogger(this.renderer);
            avLogger(this.viewEl);
        }
    }
    hasPermissionToDeleteItemInNamedCollection(name, item) {
        return true;
    }
    hasPermissionToUpdateItemInNamedCollection(name, item) {
        return true;
    }
    hasPermissionForActionOnItemInNamedCollection(actionName, name, item) {
        return true;
    }
    setRenderer(renderer) {
        this.renderer = renderer;
    }
    getSecondaryBadgeValueForItemInNamedCollection(name, item) {
        return 0;
    }
    getTertiaryBadgeValueForItemInNamedCollection(name, item) {
        return 0;
    }
    applyDefaultSort(item1, item2) {
        return 0;
    }
    getItemIcons(name, item) {
        return [];
    }
    prependItemIcons(name, item) {
        return true;
    }
    applyFilter(filter) {
        avLoggerFilter(filter);
        this.filter = filter;
        this.render();
    }
    applySorter(sorter) {
        this.sorterConfig = sorter;
        this.render();
    }
    clearFilter() {
        avLoggerFilter('filter cleared');
        this.filter = null;
        this.render();
    }
    clearSorter() {
        this.sorterConfig = null;
        this.render();
    }
    hasFilter() {
        let result = false;
        if (this.filter) {
            result = true;
        }
        return result;
    }
    getCurrentFilter() {
        return this.filter;
    }
    hasSorter() {
        let result = false;
        if (this.sorterConfig) {
            result = true;
        }
        return result;
    }
    setOnlyDisplayWithFilter(onlyDisplayWithFilter) {
        avLoggerFilter(`Only display with filter? ${onlyDisplayWithFilter}`);
        this.onlyDisplayWithFilter = onlyDisplayWithFilter;
    }
}
//# sourceMappingURL=AbstractCollectionView.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractStatefulCollectionView.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractStatefulCollectionView.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractStatefulCollectionView": () => (/* binding */ AbstractStatefulCollectionView)
/* harmony export */ });
/* harmony import */ var _AbstractCollectionView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractCollectionView */ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractCollectionView.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _model_ObjectDefinitionRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../model/ObjectDefinitionRegistry */ "./node_modules/ui-framework-jps/dist/framework/model/ObjectDefinitionRegistry.js");



const logger = debug__WEBPACK_IMPORTED_MODULE_1___default()('ab-stateful-collection-view');
const loggerEvent = debug__WEBPACK_IMPORTED_MODULE_1___default()('ab-stateful-collection-view-event');
class AbstractStatefulCollectionView extends _AbstractCollectionView__WEBPACK_IMPORTED_MODULE_0__.AbstractCollectionView {
    constructor(uiConfig, stateManager, stateName) {
        super(uiConfig, stateName);
        this.dataListeners = [];
        this.stateManager = stateManager;
        // state change listening
        this.stateChanged = this.stateChanged.bind(this);
        // setup state listener
        this.stateManager.addChangeListenerForName(this.collectionName, this);
    }
    addDataObjectListener(listener) {
        this.dataListeners.push(listener);
    }
    getItemDescription(from, item) {
        return "";
    }
    hasActionPermission(actionName, from, item) {
        return true;
    }
    onDocumentLoaded() {
        super.onDocumentLoaded();
        this.addEventCollectionListener(this);
    }
    getItemInNamedCollection(name, compareWith) {
        return this.stateManager.findItemInState(name, compareWith);
    }
    stateChanged(managerName, name, newValue) {
        logger(`handling state ${name} changed`);
        logger(newValue);
        (this.eventForwarder).collectionChanged(this);
        logger('buffering state on state changed');
        this.setBufferForName(name, newValue);
        this.updateViewForNamedCollection(name, newValue);
    }
    stateChangedItemAdded(managerName, name, itemAdded) {
        var _a;
        logger(`handling state ${name} new item added`);
        logger(itemAdded);
        if (this.stateManager && this.collectionName && this.viewEl) {
            try {
                (_a = this.renderer) === null || _a === void 0 ? void 0 : _a.insertDisplayElementForCollectionItem(this.viewEl, name, itemAdded);
                if (this.hasFilter()) {
                    const filter = this.getCurrentFilter();
                    if (filter)
                        this.applyFilter(filter);
                }
            }
            catch (err) {
                logger(err);
                this.updateViewForNamedCollection(name, this.stateManager.getStateByName(name));
            }
        }
    }
    stateChangedItemRemoved(managerName, name, itemRemoved) {
        var _a;
        logger(`handling state ${name} new item removed`);
        logger(itemRemoved);
        if (this.stateManager && this.collectionName && this.viewEl) {
            try {
                (_a = this.renderer) === null || _a === void 0 ? void 0 : _a.removeDisplayElementForCollectionItem(this.viewEl, name, itemRemoved);
            }
            catch (err) {
                logger(err);
                this.updateViewForNamedCollection(name, this.stateManager.getStateByName(name));
            }
        }
    }
    stateChangedItemUpdated(managerName, name, itemUpdated, itemNewValue) {
        var _a;
        logger(`handling state ${name} new item updated`);
        logger(itemNewValue);
        if (this.stateManager && this.collectionName && this.viewEl) {
            try {
                (_a = this.renderer) === null || _a === void 0 ? void 0 : _a.updateDisplayElementForCollectionItem(this.viewEl, name, itemNewValue);
                if (this.hasFilter()) {
                    const filter = this.getCurrentFilter();
                    if (filter)
                        this.applyFilter(filter);
                }
            }
            catch (err) {
                logger(err);
                this.updateViewForNamedCollection(name, this.stateManager.getStateByName(name));
            }
        }
    }
    getDisplayedCollection() {
        const currentFullState = this.stateManager.getStateByName(this.collectionName);
        return this.getFilteredState(currentFullState);
    }
    documentLoaded(view) {
    }
    hideRequested(view) {
    }
    itemDragStarted(view, selectedItem) {
    }
    itemDropped(view, droppedItem) {
    }
    showRequested(view) {
    }
    itemDeselected(view, selectedItem) {
    }
    itemSelected(view, selectedItem) {
    }
    itemAction(view, actionName, selectedItem) {
    }
    itemDeleted(view, selectedItem) {
        loggerEvent(`Deleting item from state`);
        loggerEvent(selectedItem);
        this.stateManager.removeItemFromState(this.collectionName, selectedItem, false);
    }
    canSelectItem(view, selectedItem) {
        return true;
    }
    canDeleteItem(view, selectedItem) {
        return true;
    }
    getListenerName() {
        return this.getName();
    }
    filterResults(managerName, name, filterResults) {
    }
    foundResult(managerName, name, foundItem) {
    }
    collectionChanged(view) {
    }
    setFieldValue(objectId, fieldId, value) {
        loggerEvent(`handling set field value for object ${objectId} with field ${fieldId} and value ${value}`);
        const def = _model_ObjectDefinitionRegistry__WEBPACK_IMPORTED_MODULE_2__.ObjectDefinitionRegistry.getInstance().findDefinition(this.collectionName);
        if (def) {
            let foundIndex = def.fields.findIndex((field) => field.isKey === true);
            if (foundIndex >= 0) {
                const field = def.fields[foundIndex];
                loggerEvent(`handling set field value for object ${objectId} with field ${fieldId} and value ${value}, key field is ${field.id}`);
                let searchObj = {};
                // @ts-ignore
                searchObj[field.id] = objectId;
                const dataObj = this.stateManager.findItemInState(this.collectionName, searchObj);
                if (dataObj) {
                    dataObj[fieldId] = value;
                    this.dataListeners.forEach((listener) => listener.update(null, this.collectionName, dataObj));
                }
            }
        }
    }
}
//# sourceMappingURL=AbstractStatefulCollectionView.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractView.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractView.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbstractView": () => (/* binding */ AbstractView)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _delegate_ViewListenerForwarder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../delegate/ViewListenerForwarder */ "./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/ViewListenerForwarder.js");
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");



const avLogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('abstract-view-ts');
const avLoggerDetails = debug__WEBPACK_IMPORTED_MODULE_0___default()('abstract-view-ts-detail');
class AbstractView {
    constructor(uiConfig) {
        this.containerEl = null;
        this.viewHasChanged = false;
        this.isVisible = false;
        this.uiConfig = uiConfig;
        this.viewEl = null;
        this.eventForwarder = new _delegate_ViewListenerForwarder__WEBPACK_IMPORTED_MODULE_1__.ViewListenerForwarder();
        this.handleDrop = this.handleDrop.bind(this);
    }
    getItemId(from, item) {
        throw new Error("Method not implemented.");
    }
    getItemDescription(from, item) {
        throw new Error("Method not implemented.");
    }
    hasActionPermission(actionName, from, item) {
        throw new Error("Not implemented");
    }
    getUIConfig() {
        return this.uiConfig;
    }
    addEventListener(listener) {
        this.eventForwarder.addListener(listener);
    }
    onDocumentLoaded() {
        this.viewEl = document.getElementById(this.uiConfig.resultsContainerId);
        this.eventForwarder.documentLoaded(this);
    }
    setContainedBy(container) {
        this.containerEl = container;
    }
    getName() {
        return this.uiConfig.dataSourceId;
    }
    hasChanged() {
        return this.viewHasChanged;
    }
    getDataSourceKeyId() {
        return AbstractView.DATA_SOURCE;
    }
    hide() {
        avLogger('AV hide');
        this.isVisible = false;
        this.clearDisplay();
    }
    show() {
        avLogger('AV show');
        this.isVisible = true;
        this.render();
    }
    handleDrop(event) {
        avLogger(`view ${this.getName()}: drop event`);
        avLoggerDetails(event.target);
        // @ts-ignore
        const draggedObjectJSON = event.dataTransfer.getData(_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.DRAGGABLE_KEY_ID);
        const draggedObject = JSON.parse(draggedObjectJSON);
        avLoggerDetails(draggedObject);
        // check to see if we accept the dropped type and source
        const droppedObjectType = draggedObject[_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.DRAGGABLE_TYPE];
        const droppedObjectFrom = draggedObject[_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.DRAGGABLE_FROM];
        avLogger(`view ${this.getName()}: drop event from ${droppedObjectFrom} with type ${droppedObjectType}`);
        avLoggerDetails(this.uiConfig.drop);
        if (this.uiConfig.drop) {
            const acceptType = (this.uiConfig.drop.acceptTypes.findIndex((objectType) => objectType === droppedObjectType) >= 0);
            let acceptFrom = true;
            if (acceptType) {
                if (this.uiConfig.drop.acceptFrom) {
                    acceptFrom = (this.uiConfig.drop.acceptFrom.findIndex((from) => from === droppedObjectFrom) >= 0);
                }
                avLoggerDetails(`view ${this.getName()}: accepted type? ${acceptType} and from? ${acceptFrom}`);
                if (acceptType && acceptFrom) {
                    this.eventForwarder.itemDropped(this, draggedObject);
                }
            }
        }
    }
    isShowing() {
        return this.isVisible;
    }
}
AbstractView.DATA_SOURCE = 'data-source';
//# sourceMappingURL=AbstractView.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/DataObjectCollectionView.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/DataObjectCollectionView.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataObjectCollectionView": () => (/* binding */ DataObjectCollectionView)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _AbstractCollectionView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbstractCollectionView */ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractCollectionView.js");
/* harmony import */ var _model_DataObjectFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../model/DataObjectFactory */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectFactory.js");



const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('data-object-collection-view');
class DataObjectCollectionView extends _AbstractCollectionView__WEBPACK_IMPORTED_MODULE_1__.AbstractCollectionView {
    constructor(uiConfig, stateManager, stateName) {
        super(uiConfig, stateName);
        this.stateManager = stateManager;
        // state change listening
        this.stateChanged = this.stateChanged.bind(this);
        // setup state listener
        this.stateManager.addChangeListenerForName(this.collectionName, this);
    }
    setFieldValue(objectId, fieldId, value) {
        throw new Error('Method not implemented.');
    }
    getDisplayedCollection() {
        return [];
        //TODO
    }
    getIdForItemInNamedCollection(name, item) {
        return item.getUniqueId();
    }
    renderDisplayForItemInNamedCollection(containerEl, name, item) {
        throw item.getDescription();
    }
    getItemDescription(from, item) {
        return item.getDescription();
    }
    hasActionPermission(actionName, from, item) {
        return true;
    }
    onDocumentLoaded() {
        super.onDocumentLoaded();
        this.addEventCollectionListener(this);
    }
    getItemInNamedCollection(name, compareWith) {
        return this.stateManager.findItemInState(name, compareWith);
    }
    stateChanged(managerName, name, newValue) {
        logger(`handling state ${name} changed`);
        logger(newValue);
        (this.eventForwarder).collectionChanged(this);
        this.updateViewForNamedCollection(name, newValue);
    }
    stateChangedItemAdded(managerName, name, itemAdded) {
        logger(`handling state ${name} new item added`);
        logger(itemAdded);
        if (this.stateManager && this.collectionName)
            this.updateViewForNamedCollection(name, this.stateManager.getStateByName(name));
    }
    stateChangedItemRemoved(managerName, name, itemRemoved) {
        logger(`handling state ${name} new item removed`);
        logger(itemRemoved);
        if (this.stateManager && this.collectionName)
            this.updateViewForNamedCollection(name, this.stateManager.getStateByName(name));
    }
    stateChangedItemUpdated(managerName, name, itemUpdated, itemNewValue) {
        logger(`handling state ${name} new item updated`);
        logger(itemNewValue);
        if (this.stateManager && this.collectionName)
            this.updateViewForNamedCollection(name, this.stateManager.getStateByName(name));
    }
    render() {
        this.updateViewForNamedCollection(this.collectionName, this.stateManager.getStateByName(this.collectionName));
    }
    show() {
    }
    hide() {
    }
    documentLoaded(view) {
    }
    hideRequested(view) {
    }
    itemDragStarted(view, selectedItem) {
    }
    itemDropped(view, droppedItem) {
    }
    showRequested(view) {
    }
    itemDeselected(view, selectedItem) {
    }
    itemSelected(view, selectedItem) {
    }
    itemAction(view, actionName, selectedItem) {
    }
    itemDeleted(view, selectedItem) {
        this.stateManager.removeItemFromState(this.collectionName, selectedItem, false);
    }
    canSelectItem(view, selectedItem) {
        return true;
    }
    canDeleteItem(view, selectedItem) {
        return true;
    }
    getListenerName() {
        return this.getName();
    }
    filterResults(managerName, name, filterResults) {
    }
    foundResult(managerName, name, foundItem) {
    }
    collectionChanged(view) {
    }
    updateViewForNamedCollection(name, newState) {
        /*
        Convert the state into data objects
         */
        const dataObjs = _model_DataObjectFactory__WEBPACK_IMPORTED_MODULE_2__.DataObjectFactory.getInstance().createDataObjectsFromStateNameAndData(name, newState, true);
        super.updateViewForNamedCollection(name, dataObjs);
    }
}
//# sourceMappingURL=DataObjectCollectionView.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/DefaultPermissionChecker.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/DefaultPermissionChecker.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultPermissionChecker": () => (/* binding */ DefaultPermissionChecker)
/* harmony export */ });
class DefaultPermissionChecker {
    hasPermissionToUpdateItem(item) {
        return true;
    }
    hasPermissionToDeleteItem(item) {
        return true;
    }
}
//# sourceMappingURL=DefaultPermissionChecker.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/DetailViewImplementation.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/DetailViewImplementation.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DetailViewImplementation": () => (/* binding */ DetailViewImplementation)
/* harmony export */ });
/* harmony import */ var _AbstractView__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbstractView */ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractView.js");
/* harmony import */ var _delegate_DetailViewListenerForwarder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../delegate/DetailViewListenerForwarder */ "./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/DetailViewListenerForwarder.js");


class DetailViewImplementation extends _AbstractView__WEBPACK_IMPORTED_MODULE_0__.AbstractView {
    constructor(uiConfig, renderer) {
        super(uiConfig);
        this.currentItem = null;
        this.renderer = renderer;
        const forwarder = new _delegate_DetailViewListenerForwarder__WEBPACK_IMPORTED_MODULE_1__.DetailViewListenerForwarder();
        this.eventForwarder = forwarder;
        this.renderer.setView(this);
        this.renderer.setEventForwarder(forwarder);
    }
    addEventDetailListener(listener) {
        this.eventForwarder.addListener(listener);
    }
    getItemId(name, item) {
        return '';
    }
    getItemDescription(name, item) {
        return '';
    }
    hasActionPermission(actionName, from, item) {
        return true;
    }
    getItem(from, identifier) {
        return this.currentItem;
    }
    clearDisplay() {
        this.renderer.reset();
    }
    clearReadOnly() {
        this.renderer.clearReadOnly();
    }
    setReadOnly() {
        this.renderer.setReadOnly();
    }
    isReadOnly() {
        return this.renderer.isReadOnly();
    }
    createItem(dataObj) {
        return this.renderer.createItem(dataObj);
    }
    displayItem(dataObj) {
        this.currentItem = dataObj;
        if (this.renderer.hasPermissionToUpdateItem(dataObj)) {
            this.renderer.displayItem(dataObj);
        }
        else {
            this.renderer.displayItemReadonly(dataObj);
        }
        this.show();
    }
    hide() {
        this.renderer.hide();
    }
    show() {
        this.renderer.show();
    }
    render() {
        this.displayItem(this.currentItem);
    }
    onDocumentLoaded() {
        this.renderer.onDocumentLoaded();
        super.onDocumentLoaded();
    }
    hasPermissionToDeleteItem(item) {
        return this.renderer.hasPermissionToDeleteItem(item);
    }
    hasPermissionToUpdateItem(item) {
        return this.renderer.hasPermissionToUpdateItem(item);
    }
    handleActionItem(actionName, selectedItem) {
        this.renderer.handleActionItem(actionName, selectedItem);
    }
    isDisplayingItem(dataObj) {
        return this.renderer.isDisplayingItem(dataObj);
    }
    hasChanged() {
        return this.renderer.hasChanged();
    }
    initialise(runtimeConfig) {
        this.renderer.initialise(runtimeConfig);
    }
}
//# sourceMappingURL=DetailViewImplementation.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/item/DefaultFieldPermissionChecker.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/item/DefaultFieldPermissionChecker.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultFieldPermissionChecker": () => (/* binding */ DefaultFieldPermissionChecker)
/* harmony export */ });
class DefaultFieldPermissionChecker {
    hasPermissionToDeleteItem(item) {
        return true;
    }
    hasPermissionToEditField(dataObj, field) {
        return true;
    }
    hasPermissionToUpdateItem(item) {
        return true;
    }
}
//# sourceMappingURL=DefaultFieldPermissionChecker.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/item/DefaultItemView.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/item/DefaultItemView.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultItemView": () => (/* binding */ DefaultItemView)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../model/DataObjectTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectTypeDefs.js");
/* harmony import */ var _alert_AlertListener__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../alert/AlertListener */ "./node_modules/ui-framework-jps/dist/framework/ui/alert/AlertListener.js");
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");
/* harmony import */ var _alert_AlertManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../alert/AlertManager */ "./node_modules/ui-framework-jps/dist/framework/ui/alert/AlertManager.js");
/* harmony import */ var _validation_ValidationManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../validation/ValidationManager */ "./node_modules/ui-framework-jps/dist/framework/ui/validation/ValidationManager.js");
/* harmony import */ var _validation_ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../validation/ValidationTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/ui/validation/ValidationTypeDefs.js");
/* harmony import */ var _factory_FieldInputElementFactory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../factory/FieldInputElementFactory */ "./node_modules/ui-framework-jps/dist/framework/ui/factory/FieldInputElementFactory.js");
/* harmony import */ var _factory_ItemViewElementFactory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../factory/ItemViewElementFactory */ "./node_modules/ui-framework-jps/dist/framework/ui/factory/ItemViewElementFactory.js");
/* harmony import */ var _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../util/BrowserUtil */ "./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js");
/* harmony import */ var _field_TextAreaField__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../field/TextAreaField */ "./node_modules/ui-framework-jps/dist/framework/ui/field/TextAreaField.js");
/* harmony import */ var _field_RadioButtonGroupField__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../field/RadioButtonGroupField */ "./node_modules/ui-framework-jps/dist/framework/ui/field/RadioButtonGroupField.js");
/* harmony import */ var _field_SelectField__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../field/SelectField */ "./node_modules/ui-framework-jps/dist/framework/ui/field/SelectField.js");
/* harmony import */ var _field_ColourInputField__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../field/ColourInputField */ "./node_modules/ui-framework-jps/dist/framework/ui/field/ColourInputField.js");
/* harmony import */ var _field_InputField__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../field/InputField */ "./node_modules/ui-framework-jps/dist/framework/ui/field/InputField.js");
















const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('default-item-view');
const dlogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('default-item-view-detail');
const vlogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('default-item-view-detail-validation');
class DefaultItemView {
    constructor(containerId, dataObjDef, configHelper, permissionChecker, hasExternalControl = false) {
        this.listeners = [];
        this.fieldListeners = [];
        this.uiDef = null;
        this.isVisible = false;
        this.fields = [];
        this.isInitialised = false;
        this.hasChangedBoolean = false;
        this.factoryElements = null;
        this.containerEl = document.getElementById(containerId);
        if (!(this.containerEl))
            throw new Error(`container ${containerId} for Item View ${dataObjDef.id} does not exist`);
        this.map = [];
        this.dataObjDef = dataObjDef;
        this.configHelper = configHelper;
        this.hasExternalControl = hasExternalControl;
        this.permissionChecker = permissionChecker;
        this.currentDataObj = {};
        this.id = (0,uuid__WEBPACK_IMPORTED_MODULE_15__["default"])();
        this.viewMode = _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ViewMode.unset;
        // sub-classes need to create the Item View and it's fields
        // listen to ourselves
        this.addListener(this);
    }
    getFields() {
        return this.fields;
    }
    getViewMode() {
        return this.viewMode;
    }
    getCurrentDataObj() {
        return this.currentDataObj;
    }
    getDataObjectDefinition() {
        return this.dataObjDef;
    }
    cancel() {
        if (this.uiDef) {
            let itemEvent = {
                target: this,
                identifier: this.getId(),
                eventType: _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.CANCELLING
            };
            this.itemViewEvent(this.dataObjDef.displayName, itemEvent);
        }
    }
    delete() {
        if (this.uiDef && !this.isReadOnly()) {
            let itemEvent = {
                target: this,
                identifier: this.getId(),
                eventType: _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.DELETING
            };
            this.itemViewEvent(this.dataObjDef.displayName, itemEvent);
        }
    }
    save() {
        if (this.uiDef && !this.isReadOnly()) {
            let itemEvent = {
                target: this,
                identifier: this.getId(),
                eventType: _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.SAVING
            };
            this.itemViewEvent(this.dataObjDef.displayName, itemEvent);
        }
    }
    hasChanged() {
        return this.hasChangedBoolean;
    }
    getName() {
        return this.dataObjDef.displayName;
    }
    valueChanged(view, field, fieldDef, newValue) {
        this.hasChangedBoolean = true;
        this.setUnsavedMessage();
        logger(`Item View has changed`);
    }
    failedValidation(view, field, currentValue, message) {
        this.hasChangedBoolean = true;
        logger(`Item View has changed`);
    }
    initialise(runtimeConfig) {
        if (this.isInitialised)
            return;
        this.isInitialised = true;
        this._initialise(runtimeConfig);
    }
    addFieldListener(listener) {
        this.fieldListeners.push(listener);
    }
    addListener(listener) {
        this.listeners.push(listener);
    }
    reset() {
        logger(`Resetting Item View`);
        this.clearUnsavedMessage();
        this.viewMode = _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ViewMode.unset;
        this.hasChangedBoolean = false;
        // inform the listeners
        if (this.uiDef) {
            let itemEvent = {
                identifier: this.getId(),
                target: this,
                eventType: _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.RESETTING
            };
            this.informListeners(itemEvent, this.currentDataObj);
        }
        this.currentDataObj = {};
        this._reset();
        // reset all the fields
        this.fields.forEach((field) => {
            field.reset();
        });
        this.hasChangedBoolean = false;
        if (this.containerEl && this.uiDef && (this.uiDef.autoscrollOnNewContent === true))
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_9__["default"].scrollSmoothTo(this.containerEl);
    }
    setIsVisible(isVisible) {
        logger(`Changing visibility to ${isVisible}`);
        this.isVisible = isVisible;
        if (this.uiDef) {
            let eventType = _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.HIDDEN;
            if (this.isVisible) {
                this._visible();
                eventType = _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.SHOWN;
            }
            else {
                this._hidden();
            }
            // inform the listeners
            let itemEvent = {
                identifier: this.getId(),
                target: this,
                eventType: eventType
            };
            this.informListeners(itemEvent, this.currentDataObj);
        }
        if (isVisible && !(this.viewMode === _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ViewMode.displayOnly))
            this.checkFormValidationOnDisplay();
        if (isVisible && (this.viewMode === _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ViewMode.displayOnly))
            this.checkForVisualValidationForDisplayOnly();
    }
    startCreateNew(objectToEdit) {
        this.clearUnsavedMessage();
        logger(`Starting create new`);
        this.reset();
        this.currentDataObj = {};
        if (objectToEdit) {
            this.currentDataObj = objectToEdit;
        }
        this.viewMode = _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ViewMode.create;
        this.hasChangedBoolean = false;
        if (this.uiDef) {
            let eventType = _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.CREATING;
            // inform the listeners
            let itemEvent = {
                identifier: this.getId(),
                target: this,
                eventType: eventType,
                currentDataObj: this.currentDataObj
            };
            this.informListeners(itemEvent, this.currentDataObj);
            this._startCreate();
        }
        this.clearReadOnly();
        if (this.containerEl && this.uiDef && (this.uiDef.autoscrollOnNewContent === true))
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_9__["default"].scrollSmoothTo(this.containerEl);
        return this.currentDataObj;
    }
    startUpdate(objectToEdit) {
        this.clearUnsavedMessage();
        logger(`Starting modify existing on `);
        this.viewMode = _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ViewMode.update;
        this.hasChangedBoolean = false;
        logger(objectToEdit);
        this.currentDataObj = Object.assign({}, objectToEdit); // take a copy
        if (this.uiDef) {
            let eventType = _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.MODIFYING;
            // inform the listeners
            let itemEvent = {
                identifier: this.getId(),
                target: this,
                eventType: eventType,
                currentDataObj: this.currentDataObj
            };
            this.informListeners(itemEvent, this.currentDataObj);
            this._startUpdate();
        }
        this.clearReadOnly();
        if (this.containerEl && this.uiDef && (this.uiDef.autoscrollOnNewContent === true))
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_9__["default"].scrollSmoothTo(this.containerEl);
    }
    displayOnly(objectToView) {
        this.clearUnsavedMessage();
        logger(`Starting display only `);
        logger(objectToView);
        this.viewMode = _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ViewMode.displayOnly;
        this.hasChangedBoolean = false;
        this.currentDataObj = Object.assign({}, objectToView); // take a copy
        if (this.uiDef) {
            let itemEvent = {
                target: this,
                identifier: this.getId(),
                eventType: _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.DISPLAYING_READ_ONLY,
                currentDataObj: this.currentDataObj
            };
            this.itemViewEvent(this.dataObjDef.displayName, itemEvent);
        }
        if (this.uiDef) {
            this._displayOnly();
        }
        this.setReadOnly();
        if (this.containerEl && this.uiDef && (this.uiDef.autoscrollOnNewContent === true))
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_9__["default"].scrollSmoothTo(this.containerEl);
    }
    itemViewEvent(name, event, values) {
        // catch form events for user leaving the Item View
        let shouldCancelChange = false;
        switch (event.eventType) {
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.CANCELLING): {
                logger(`Item View is cancelling`);
                if (this.hasChangedBoolean && !(this.viewMode === _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ViewMode.displayOnly)) {
                    if (this.uiDef) {
                        _alert_AlertManager__WEBPACK_IMPORTED_MODULE_4__.AlertManager.getInstance().startAlert(this, this.uiDef.displayName, `Lose any unsaved changes?`, _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.CANCELLING);
                    }
                }
                else {
                    if (this.uiDef) {
                        let itemEvent = {
                            identifier: this.getId(),
                            target: this,
                            eventType: _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.CANCELLED
                        };
                        this.informListeners(itemEvent, this.currentDataObj);
                    }
                }
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.CANCELLING_ABORTED): {
                logger(`Item View is cancelling - aborted`);
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.CANCELLED): {
                logger(`Item View is cancelled - resetting`);
                // user cancelled the Item View, will become invisible
                this.viewMode = _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ViewMode.displayOnly;
                this.reset(); // reset the Item View state
                this.setReadOnly();
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.DELETING): {
                logger(`Item View is deleting`);
                if (this.uiDef) {
                    _alert_AlertManager__WEBPACK_IMPORTED_MODULE_4__.AlertManager.getInstance().startAlert(this, this.uiDef.displayName, `Are you sure you want to delete this information?`, _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.DELETING);
                }
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.DELETE_ABORTED): {
                logger(`Item View is deleting - aborted`);
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.DELETED): {
                logger(`Item View is deleted - resetting`);
                // user is deleting the object, will become invisible
                this.reset();
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.SAVE_ABORTED): {
                this._saveFinishedOrAborted();
                logger(`Item View save cancelled`);
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.SAVED): {
                this._saveFinishedOrAborted();
                logger(`Item View is saved with data`);
                logger(values);
                this.viewMode = _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ViewMode.update;
                this.hasChangedBoolean = false;
                this.startUpdate(values);
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.SAVING): {
                logger(`Item View is saving, checking validation and storing values`);
                this._saveIsActive();
                if (this.uiDef) {
                    let allFieldsValid = true;
                    // user attempting to save the Item View, lets check the field validation
                    this.fields.forEach((field) => {
                        const currentValue = field.getValue();
                        if (!field.isValid()) {
                            vlogger(`Field ${field.getId()} is invalid`);
                            field.setInvalid(`${field.getName()} has an invalid format or is required.`);
                            allFieldsValid = false;
                        }
                        else {
                            // does the field fulfil any rules from the Validation manager
                            const response = _validation_ValidationManager__WEBPACK_IMPORTED_MODULE_5__.ValidationManager.getInstance().applyRulesToTargetField(this, this.viewMode, field.getFieldDefinition(), _validation_ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_6__.ConditionResponse.invalid);
                            if (response.ruleFailed) {
                                if (response.message)
                                    field.setInvalid(response.message);
                                vlogger(`Field ${field.getId()} is invalid from validation manager with message ${response.message}`);
                                allFieldsValid = false;
                            }
                            else {
                                this.setFieldValueToDataObject(this.currentDataObj, field, currentValue);
                            }
                        }
                    });
                    // is every field valid?
                    if (!allFieldsValid) {
                        logger(`Item View is saving, checking validation - FAILED`);
                        let itemEvent = {
                            identifier: this.getId(),
                            target: this,
                            eventType: _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.SAVE_ABORTED
                        };
                        this.informListeners(itemEvent, this.currentDataObj);
                        shouldCancelChange = true;
                    }
                    else {
                        logger(`formatted data object is`);
                        const formattedDataObject = this.getFormattedDataObject();
                        let itemEvent = {
                            identifier: this.getId(),
                            target: this,
                            eventType: _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.SAVED
                        };
                        this.informListeners(itemEvent, formattedDataObject);
                    }
                    break;
                }
            }
        }
        return shouldCancelChange;
    }
    getId() {
        return this.id;
    }
    getFieldFromDataFieldId(dataFieldId) {
        let result = undefined;
        dlogger(`Finding field for attribute ${dataFieldId} `);
        const mapItem = this.map.find((mapItem) => mapItem.attributeId === dataFieldId);
        if (mapItem) {
            dlogger(`Mapped attribute ${mapItem.attributeId} to field ${mapItem.fieldId}`);
            // find the field with that id
            result = this.fields.find((field) => field.getId() === mapItem.attributeId);
        }
        return result;
    }
    alertCompleted(event) {
        logger(`Handling alert completed`);
        logger(event);
        if (event.context && this.uiDef) {
            switch (event.context) {
                case (_CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.CANCELLING): {
                    if (event.outcome === _alert_AlertListener__WEBPACK_IMPORTED_MODULE_2__.AlertType.confirmed) {
                        let itemEvent = {
                            identifier: this.getId(),
                            target: this,
                            eventType: _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.CANCELLED
                        };
                        this.informListeners(itemEvent, this.currentDataObj);
                    }
                    else {
                        let itemEvent = {
                            identifier: this.getId(),
                            target: this,
                            eventType: _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.CANCELLING_ABORTED
                        };
                        this.informListeners(itemEvent, this.currentDataObj);
                    }
                    break;
                }
                case (_CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.DELETING): {
                    if (event.outcome === _alert_AlertListener__WEBPACK_IMPORTED_MODULE_2__.AlertType.confirmed) {
                        let itemEvent = {
                            identifier: this.getId(),
                            target: this,
                            eventType: _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.DELETED
                        };
                        this.informListeners(itemEvent, this.currentDataObj);
                    }
                    else {
                        let itemEvent = {
                            identifier: this.getId(),
                            target: this,
                            eventType: _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ItemEventType.DELETE_ABORTED
                        };
                        this.informListeners(itemEvent, this.currentDataObj);
                    }
                    break;
                }
            }
        }
    }
    clearReadOnly() {
        this.fields.forEach((field) => {
            if (this.currentDataObj) {
                if (this.permissionChecker.hasPermissionToEditField(this.currentDataObj, field)) {
                    field.clearReadOnly();
                }
            }
            else {
                field.clearReadOnly();
            }
        });
        this.enableButtons();
    }
    setReadOnly() {
        this.fields.forEach((field) => {
            field.setReadOnly();
        });
        this.disableButtons();
    }
    isDisplayingItem(dataObj) {
        if (this.currentDataObj) {
            return this._isSameObjectAsDisplayed(dataObj);
        }
        return false;
    }
    isReadOnly() {
        return (this.viewMode === _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.ViewMode.displayOnly);
    }
    getElementIdForField(fieldId) {
        return _factory_FieldInputElementFactory__WEBPACK_IMPORTED_MODULE_7__.FieldInputElementFactory.getElementIdForFieldId(this, fieldId);
    }
    getFormattedDataObject() {
        logger(`Getting current formatted data`);
        let formattedResult = {};
        this.dataObjDef.fields.forEach((fieldDef) => {
            let fieldValue = this.currentDataObj[fieldDef.id];
            if (fieldDef.derivedValue) {
                if (!fieldDef.derivedValue.onlyForDisplay()) {
                    formattedResult[fieldDef.id] = this.getFormattedFieldValue(fieldDef);
                }
            }
            else {
                formattedResult[fieldDef.id] = this.getFormattedFieldValue(fieldDef);
            }
        });
        logger(formattedResult);
        return formattedResult;
    }
    informListeners(event, dataObj) {
        this.listeners.forEach((listener) => listener.itemViewEvent(this.dataObjDef.displayName, event, dataObj));
    }
    findFieldUiConfig(fieldDef) {
        dlogger(`Finding field UI Config for field ${fieldDef.displayName}`);
        let result = null;
        if (this.uiDef) {
            let index = 0;
            while (index < this.uiDef.fieldGroups.length) {
                const fieldGroup = this.uiDef.fieldGroups[index];
                result = fieldGroup.fields.find((uiConfig) => uiConfig.field.id === fieldDef.id);
                if (result) {
                    dlogger(`Finding field UI Config for field ${fieldDef.displayName} - Found`);
                    break;
                }
                index++;
            }
        }
        return result;
    }
    checkForVisualValidationForDisplayOnly() {
        logger(`Checking display validation for display only`);
        this.fields.forEach((field) => {
            field.show();
            let response = _validation_ValidationManager__WEBPACK_IMPORTED_MODULE_5__.ValidationManager.getInstance().applyRulesToTargetField(this, this.viewMode, field.getFieldDefinition(), _validation_ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_6__.ConditionResponse.hide);
            if (response.ruleFailed) {
                field.hide();
                vlogger(`Field ${field.getId()} is hidden from validation manager with message ${response.message}`);
            }
        });
    }
    checkFormValidationOnDisplay() {
        logger(`Checking display validation`);
        this.fields.forEach((field) => {
            field.show();
            const currentValue = field.getValue();
            if (!field.isValid()) {
                logger(`Field ${field.getId()} is invalid`);
                field.setInvalid(`${field.getName()} has an invalid format or is required.`);
            }
            else {
                // does the field fulfil any rules from the Validation manager
                let response = _validation_ValidationManager__WEBPACK_IMPORTED_MODULE_5__.ValidationManager.getInstance().applyRulesToTargetField(this, this.viewMode, field.getFieldDefinition(), _validation_ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_6__.ConditionResponse.invalid);
                if (response.ruleFailed) {
                    if (response.message)
                        field.setInvalid(response.message);
                    vlogger(`Field ${field.getId()} is invalid from validation manager with message ${response.message}`);
                }
                response = _validation_ValidationManager__WEBPACK_IMPORTED_MODULE_5__.ValidationManager.getInstance().applyRulesToTargetField(this, this.viewMode, field.getFieldDefinition(), _validation_ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_6__.ConditionResponse.hide);
                if (response.ruleFailed) {
                    field.hide();
                    vlogger(`Field ${field.getId()} is hidden from validation manager with message ${response.message}`);
                }
            }
        });
    }
    __getFactoryElements() {
        // @ts-ignore
        return _factory_ItemViewElementFactory__WEBPACK_IMPORTED_MODULE_8__.ItemViewElementFactory.getInstance().createFormElements(this, this.listeners, this.uiDef, this.fieldListeners);
    }
    __buildUIElements() {
        // now we need to create all the Item View elements from the ui definition
        this.factoryElements = this.__getFactoryElements();
        logger(this.factoryElements);
        // create field elements for each field element, and the basic map
        logger(`Converting field input elements to Field objects`);
        this.factoryElements.fields.forEach((fieldEl) => {
            fieldEl.addEventListener('keyup', (event) => {
                dlogger(`key up in Item View ${this.getName()}`);
                this.hasChangedBoolean = true;
                this.setUnsavedMessage();
            });
            this.setupFieldObject(fieldEl);
        });
        logger(`Converting field text area elements to Field objects`);
        this.factoryElements.textFields.forEach((fieldEl) => {
            fieldEl.addEventListener('keyup', (event) => {
                dlogger(`key up in Item View ${this.getName()}`);
                this.hasChangedBoolean = true;
                this.setUnsavedMessage();
            });
            this.setupFieldObject(fieldEl);
        });
        logger(`Converting field select elements to Field objects`);
        this.factoryElements.selectFields.forEach((fieldEl) => {
            fieldEl.addEventListener('change', (event) => {
                dlogger(`change in Item View ${this.getName()}`);
                this.hasChangedBoolean = true;
                this.setUnsavedMessage();
            });
            this.setupFieldObject(fieldEl);
        });
        logger(`Converting field rbg elements to Field objects`);
        this.factoryElements.radioButtonGroups.forEach((rbg) => {
            this.setupFieldObject(rbg.container, rbg.radioButtons);
            rbg.radioButtons.forEach((radioButton) => {
                radioButton.addEventListener('change', (event) => {
                    dlogger(`radio button change in Item View ${this.getName()}`);
                    this.hasChangedBoolean = true;
                    this.setUnsavedMessage();
                });
            });
        });
        logger(`Converting field composite elements to Field objects`);
        if (this.factoryElements.compositeFields) {
            this.factoryElements.compositeFields.forEach((composite) => {
                this.setupFieldObject(composite.displayElement);
                composite.actionButtons.forEach((button) => {
                    button.addEventListener('change', (event) => {
                        dlogger(`button change in Item View ${this.getName()}`);
                        this.hasChangedBoolean = true;
                        this.setUnsavedMessage();
                    });
                });
            });
        }
        logger(`Converting field composite array elements to Field objects`);
        if (this.factoryElements.compositeArrayFields) {
            this.factoryElements.compositeArrayFields.forEach((composite) => {
                this.setupFieldObject(composite.displayElement);
                composite.actionButtons.forEach((button) => {
                    button.addEventListener('change', (event) => {
                        dlogger(`button change in Item View ${this.getName()}`);
                        this.hasChangedBoolean = true;
                        this.setUnsavedMessage();
                    });
                });
            });
        }
        logger(`Converting field linked elements to Field objects`);
        if (this.factoryElements.linkedFields) {
            this.factoryElements.linkedFields.forEach((linked) => {
                this.setupFieldObject(linked.displayElement);
                linked.actionButtons.forEach((button) => {
                    button.addEventListener('change', (event) => {
                        dlogger(`button change in Item View ${this.getName()}`);
                        this.hasChangedBoolean = true;
                        this.setUnsavedMessage();
                    });
                });
            });
        }
        logger(`Converting field linked array elements to Field objects`);
        if (this.factoryElements.linkedArrayFields) {
            this.factoryElements.linkedArrayFields.forEach((linked) => {
                this.setupFieldObject(linked.displayElement);
                linked.actionButtons.forEach((button) => {
                    button.addEventListener('change', (event) => {
                        dlogger(`button change in Item View ${this.getName()}`);
                        this.hasChangedBoolean = true;
                        this.setUnsavedMessage();
                    });
                });
            });
        }
        logger(`field/data map is `);
        logger(this.map);
        logger('fields are');
        logger(this.fields);
    }
    _initialise(runtimeConfig) {
        logger(`Initialising`);
        // ok, so given a Data Object definition we are going to create the Item View ui config
        this.uiDef = this.configHelper.generateConfig(this.dataObjDef, runtimeConfig);
        logger(this.uiDef);
        this.__buildUIElements();
    }
    _reset() {
        this.clearUnsavedMessage();
    }
    validateField(fieldDef) {
        const field = this.getFieldFromDataFieldId(fieldDef.id);
        if (field) {
            field.validate();
            if (this.currentDataObj) {
                if (!this.permissionChecker.hasPermissionToEditField(this.currentDataObj, field)) {
                    field.setReadOnly();
                }
                else {
                    field.clearReadOnly();
                }
            }
        }
    }
    renderField(fieldDef, currentValue) {
        let result = currentValue;
        const field = this.getFieldFromDataFieldId(fieldDef.id);
        if (field) {
            result = field.render(result);
        }
        return result;
    }
    __preDisplayCurrentDataObject(dataObj) {
    }
    /* methods to be implemented in the subclass */
    _startCreate() {
        var _a, _b, _c, _d;
        this.clearUnsavedMessage();
        // we have a new object, there might be some values to generate
        this.dataObjDef.fields.forEach((fieldDef) => {
            if (fieldDef.generator && fieldDef.generator.onCreation) {
                let fieldValue = fieldDef.generator.generator.generate(fieldDef, true);
                dlogger(`Setting default values for ${fieldDef.displayName} to ${fieldValue}`);
                this.currentDataObj[fieldDef.id] = fieldValue;
            }
        });
        this.__preDisplayCurrentDataObject(this.currentDataObj);
        this.dataObjDef.fields.forEach((fieldDef) => {
            let fieldValue = this.currentDataObj[fieldDef.id];
            if (fieldValue) {
                fieldValue = this.renderField(fieldDef, fieldValue);
            }
            this.setFieldValueFromDataObject(fieldDef, fieldValue);
            // run the validation to let the user know what is required
            this.validateField(fieldDef);
        });
        // delete button can go
        if (this.factoryElements && ((_a = this.factoryElements.buttons) === null || _a === void 0 ? void 0 : _a.deleteButton))
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_9__["default"].addAttributes((_b = this.factoryElements.buttons) === null || _b === void 0 ? void 0 : _b.deleteButton, [{
                    name: 'style',
                    value: 'display:none'
                }]);
        if (this.factoryElements && ((_c = this.factoryElements.buttons) === null || _c === void 0 ? void 0 : _c.saveButton))
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_9__["default"].removeAttributes((_d = this.factoryElements.buttons) === null || _d === void 0 ? void 0 : _d.saveButton, ['style']);
    }
    _startUpdate() {
        var _a, _b, _c, _d, _e, _f;
        this.clearUnsavedMessage();
        // we have an existing object, there might be some values to generate
        logger(this.currentDataObj);
        this.__preDisplayCurrentDataObject(this.currentDataObj);
        this.dataObjDef.fields.forEach((fieldDef) => {
            if (fieldDef.generator && fieldDef.generator.onModify) {
                let fieldValue = fieldDef.generator.generator.generate(fieldDef, false);
                dlogger(`Setting default modified values for ${fieldDef.displayName} to ${fieldValue}`);
                this.currentDataObj[fieldDef.id] = fieldValue;
            }
            let fieldValue = this.currentDataObj[fieldDef.id];
            if (fieldValue)
                fieldValue = this.renderField(fieldDef, fieldValue);
            this.setFieldValueFromDataObject(fieldDef, fieldValue);
            this.validateField(fieldDef);
        });
        // delete button make visible again
        if (this.factoryElements && this.permissionChecker.hasPermissionToDeleteItem(this.currentDataObj) && ((_a = this.factoryElements.buttons) === null || _a === void 0 ? void 0 : _a.deleteButton)) {
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_9__["default"].removeAttributes((_b = this.factoryElements.buttons) === null || _b === void 0 ? void 0 : _b.deleteButton, ['style']);
        }
        else {
            // delete button can go
            if (this.factoryElements && ((_c = this.factoryElements.buttons) === null || _c === void 0 ? void 0 : _c.deleteButton))
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_9__["default"].addAttributes((_d = this.factoryElements.buttons) === null || _d === void 0 ? void 0 : _d.deleteButton, [{
                        name: 'style',
                        value: 'display:none'
                    }]);
        }
        if (this.factoryElements && ((_e = this.factoryElements.buttons) === null || _e === void 0 ? void 0 : _e.saveButton))
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_9__["default"].removeAttributes((_f = this.factoryElements.buttons) === null || _f === void 0 ? void 0 : _f.saveButton, ['style']);
    }
    _displayOnly() {
        var _a, _b, _c, _d;
        this.clearUnsavedMessage();
        // we have an existing object, there might be some values to generate
        logger(this.currentDataObj);
        this.__preDisplayCurrentDataObject(this.currentDataObj);
        this.dataObjDef.fields.forEach((fieldDef) => {
            let fieldValue = this.currentDataObj[fieldDef.id];
            if (fieldValue)
                fieldValue = this.renderField(fieldDef, fieldValue);
            if (fieldDef.derivedValue) {
            }
            this.setFieldValueFromDataObject(fieldDef, fieldValue);
        });
        // delete button can go
        if (this.factoryElements && ((_a = this.factoryElements.buttons) === null || _a === void 0 ? void 0 : _a.deleteButton))
            if (this.factoryElements)
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_9__["default"].addAttributes((_b = this.factoryElements.buttons) === null || _b === void 0 ? void 0 : _b.deleteButton, [{
                        name: 'style',
                        value: 'display:none'
                    }]);
        // save button can go
        if (this.factoryElements && ((_c = this.factoryElements.buttons) === null || _c === void 0 ? void 0 : _c.saveButton))
            if (this.factoryElements)
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_9__["default"].addAttributes((_d = this.factoryElements.buttons) === null || _d === void 0 ? void 0 : _d.saveButton, [{
                        name: 'style',
                        value: 'display:none'
                    }]);
    }
    _visible() {
        var _a;
        if (this.factoryElements)
            (_a = this.containerEl) === null || _a === void 0 ? void 0 : _a.appendChild(this.factoryElements.top);
    }
    setFieldValueToDataObject(dataObj, field, currentValue) {
        // find the attribute id from the map
        const mapItem = this.map.find((mapItem) => mapItem.attributeId === field.getId());
        if (mapItem) {
            dlogger(`Mapped field ${mapItem.fieldId} to attribute ${mapItem.attributeId} with value ${currentValue}`);
            this.currentDataObj[mapItem.attributeId] = currentValue;
        }
        else {
            logger(`Mapped field ${field.getId()} to attribute NOT FOUND`);
        }
    }
    setFieldValueFromDataObject(fieldDef, currentValue) {
        const field = this.getFieldFromDataFieldId(fieldDef.id);
        // find the field id from the map
        if (field) {
            if (currentValue) {
                field.setValue(currentValue);
            }
            else {
                if (fieldDef.derivedValue) {
                    field.setValue('');
                }
                else {
                    field.clearValue();
                }
            }
        }
    }
    getFormattedFieldValue(fieldDef) {
        let result = null;
        const mapItem = this.map.find((mapItem) => mapItem.attributeId === fieldDef.id);
        if (mapItem) {
            dlogger(`Mapped attribute ${mapItem.attributeId} to field ${mapItem.fieldId} with for getting formatted value`);
            // find the field with that id
            const field = this.fields.find((field) => field.getId() === mapItem.attributeId);
            if (field) {
                result = field.getFormattedValue();
            }
        }
        return result;
    }
    _isSameObjectAsDisplayed(dataObj) {
        // we can only be sure for objects with keys
        let isSameObject = false;
        dlogger(`is same object as current`);
        dlogger(dataObj);
        dlogger(this.currentDataObj);
        this.dataObjDef.fields.every((field) => {
            var _a;
            if (field.isKey) {
                const currentObjId = (_a = this.getFieldFromDataFieldId(field.id)) === null || _a === void 0 ? void 0 : _a.getValue();
                const suppliedObjId = dataObj[field.id];
                dlogger(`is same object id ${suppliedObjId} as current ${currentObjId}`);
                if ((currentObjId && !suppliedObjId) || (currentObjId && !suppliedObjId)) {
                    isSameObject = false;
                }
                if ((currentObjId && suppliedObjId) && (currentObjId == suppliedObjId)) {
                    isSameObject = true;
                }
                return false;
            }
            return true;
        });
        return isSameObject;
    }
    enableButtons() {
        var _a, _b, _c, _d;
        if (this.factoryElements && this.uiDef) {
            if ((_a = this.factoryElements.buttons) === null || _a === void 0 ? void 0 : _a.deleteButton) {
                (_b = this.factoryElements.buttons) === null || _b === void 0 ? void 0 : _b.deleteButton.removeAttribute('disabled');
            }
            //if (this.factoryElements.buttons?.cancelButton) this.factoryElements.buttons?.cancelButton.removeAttribute('disabled');
            if ((_c = this.factoryElements.buttons) === null || _c === void 0 ? void 0 : _c.saveButton) {
                (_d = this.factoryElements.buttons) === null || _d === void 0 ? void 0 : _d.saveButton.removeAttribute('disabled');
                // if (this.uiDef.submitButton) { // @ts-ignore
                //     this.factoryElements.submitButton.innerText = this.uiDef.submitButton.text;
                // }
            }
        }
    }
    disableButtons() {
        var _a, _b;
        if (this.factoryElements) {
            if ((_a = this.factoryElements.buttons) === null || _a === void 0 ? void 0 : _a.deleteButton) {
                this.factoryElements.buttons.deleteButton.setAttribute('disabled', 'true');
            }
            //if (this.factoryElements.buttons?.cancelButton) this.factoryElements.buttons.cancelButton.setAttribute('disabled', 'true');
            if ((_b = this.factoryElements.buttons) === null || _b === void 0 ? void 0 : _b.saveButton)
                this.factoryElements.buttons.saveButton.setAttribute('disabled', 'true');
        }
    }
    _saveFinishedOrAborted() {
        dlogger(`save is finished or aborted`);
        this.enableButtons();
        this.clearUnsavedMessage();
    }
    _saveIsActive() {
        var _a;
        dlogger(`save is active`);
        this.disableButtons();
        if (this.factoryElements && this.uiDef) {
            if (this.uiDef.activeSave && this.uiDef.saveButton && ((_a = this.factoryElements.buttons) === null || _a === void 0 ? void 0 : _a.saveButton)) {
                dlogger(`save is active ${this.uiDef.activeSave}`);
                // this.factoryElements.submitButton.innerHTML = this.uiDef.activeSave + this.uiDef.submitButton.text;
            }
        }
    }
    _hidden() {
        if (this.factoryElements) {
            if (this.containerEl) {
                if (this.isInitialised) {
                    if (this.containerEl.contains(this.factoryElements.top)) {
                        this.containerEl.removeChild(this.factoryElements.top);
                    }
                }
            }
        }
    }
    setupFieldObject(fieldEl, subElements = []) {
        // get the data-id field from the field element
        const dataId = fieldEl.getAttribute(_CommonTypes__WEBPACK_IMPORTED_MODULE_3__.DATA_ID_ATTRIBUTE);
        const fieldId = fieldEl.getAttribute('id');
        dlogger(`Converting field input element ${fieldId} with data-id of ${dataId}`);
        if (dataId && fieldId) {
            // find the corresponding field definition
            const index = this.dataObjDef.fields.findIndex((value) => value.id === dataId);
            const fieldDef = this.dataObjDef.fields.find((value) => value.id === dataId);
            if (fieldDef) {
                dlogger(`Converting field input element ${fieldId} with data-id of ${dataId} field definition is`);
                logger(fieldDef);
                // find the corresponding ui definition
                const fieldUIConfig = this.findFieldUiConfig(fieldDef);
                dlogger(`Converting field input element ${fieldId} with data-id of ${dataId} field ui config is`);
                logger(fieldUIConfig);
                if (fieldUIConfig) {
                    if (this.uiDef) {
                        let field;
                        switch (fieldUIConfig.elementType) {
                            case _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.UIFieldType.textarea: {
                                field = new _field_TextAreaField__WEBPACK_IMPORTED_MODULE_10__.TextAreaField(this, fieldUIConfig, fieldDef, fieldEl);
                                break;
                            }
                            case _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.UIFieldType.radioGroup: {
                                field = new _field_RadioButtonGroupField__WEBPACK_IMPORTED_MODULE_11__.RadioButtonGroupField(this, fieldUIConfig, fieldDef, fieldEl, subElements);
                                break;
                            }
                            case _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.UIFieldType.select: {
                                field = new _field_SelectField__WEBPACK_IMPORTED_MODULE_12__.SelectField(this, fieldUIConfig, fieldDef, fieldEl);
                                break;
                            }
                            case _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.UIFieldType.composite: {
                                field = new _field_SelectField__WEBPACK_IMPORTED_MODULE_12__.SelectField(this, fieldUIConfig, fieldDef, fieldEl);
                                break;
                            }
                            case _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.UIFieldType.list: {
                                field = new _field_SelectField__WEBPACK_IMPORTED_MODULE_12__.SelectField(this, fieldUIConfig, fieldDef, fieldEl);
                                break;
                            }
                            case _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.UIFieldType.linked: {
                                field = new _field_SelectField__WEBPACK_IMPORTED_MODULE_12__.SelectField(this, fieldUIConfig, fieldDef, fieldEl);
                                break;
                            }
                            case _CommonTypes__WEBPACK_IMPORTED_MODULE_3__.UIFieldType.linkedList: {
                                field = new _field_SelectField__WEBPACK_IMPORTED_MODULE_12__.SelectField(this, fieldUIConfig, fieldDef, fieldEl);
                                break;
                            }
                            default: {
                                if (fieldDef.type === _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_1__.FieldType.colour) {
                                    field = new _field_ColourInputField__WEBPACK_IMPORTED_MODULE_13__.ColourInputField(this, fieldUIConfig, fieldDef, fieldEl);
                                }
                                else {
                                    field = new _field_InputField__WEBPACK_IMPORTED_MODULE_14__.InputField(this, fieldUIConfig, fieldDef, fieldEl);
                                }
                                break;
                            }
                        }
                        this.fields.push(field);
                        field.addFieldListener(this);
                        this.map.push({ attributeId: dataId, fieldId: fieldId });
                    }
                }
            }
            else {
                dlogger(`Converting field input element ${fieldId} with data-id of ${dataId} field definition is NOT FOUND`);
            }
        }
    }
    clearUnsavedMessage() {
        if (this.factoryElements && this.factoryElements.unsavedMessage)
            this.factoryElements.unsavedMessage.innerHTML = '';
    }
    setUnsavedMessage() {
        if (this.factoryElements && this.uiDef && this.uiDef.unsavedChanges && this.uiDef.unsavedChanges.innerHTML) {
            if (this.factoryElements.unsavedMessage)
                this.factoryElements.unsavedMessage.innerHTML = this.uiDef.unsavedChanges.innerHTML;
        }
        else if (this.factoryElements) {
            if (this.factoryElements.unsavedMessage)
                this.factoryElements.unsavedMessage.innerHTML = 'Pending changes to save';
        }
        this.listeners.forEach((listener) => listener.itemViewHasChanged(this.dataObjDef.displayName));
    }
    getFieldValue(fieldId) {
        let result = null;
        const field = this.getFieldFromDataFieldId(fieldId);
        if (field) {
            result = field.getValue();
        }
        return result;
    }
    setFieldValue(fieldId, newValue, fireChanges = true) {
        const field = this.getFieldFromDataFieldId(fieldId);
        if (field) {
            if (fireChanges)
                this.setChanged();
            field.setValue(newValue);
        }
    }
    clearFieldReadOnly(fieldId) {
        const field = this.getFieldFromDataFieldId(fieldId);
        if (field) {
            field.clearReadOnly();
        }
    }
    setFieldReadOnly(fieldId) {
        const field = this.getFieldFromDataFieldId(fieldId);
        if (field) {
            field.setReadOnly();
        }
    }
    clearFieldInvalid(fieldId) {
        const field = this.getFieldFromDataFieldId(fieldId);
        if (field) {
            field.setValid();
        }
    }
    setFieldInvalid(fieldId, message) {
        const field = this.getFieldFromDataFieldId(fieldId);
        if (field) {
            field.setInvalid(message);
        }
    }
    itemViewHasChanged(name) { }
    setChanged() {
        this.hasChangedBoolean = true;
        this.setUnsavedMessage();
    }
    fieldAction(name, event) {
    }
    scrollToField(fieldId) {
        const el = this.getFieldElement(fieldId);
        if (el) {
            if (this.containerEl)
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_9__["default"].scrollToElementInContainer(this.containerEl, el);
        }
    }
    scrollToTop() {
        if (this.containerEl) {
            $(this.containerEl).animate({ scrollTop: 0 }, "fast");
        }
    }
    isAutoScroll() {
        let result = false;
        if (this.uiDef) {
            if (this.uiDef.autoscrollOnNewContent === true)
                result = true;
        }
        return result;
    }
    getFieldElement(fieldId) {
        let result = null;
        const elId = this.getElementIdForField(fieldId);
        if (elId) {
            result = document.getElementById(elId);
        }
        return result;
    }
    getContainerElement() {
        return this.containerEl;
    }
}
//# sourceMappingURL=DefaultItemView.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/CarouselViewRenderer.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/CarouselViewRenderer.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CarouselViewRenderer": () => (/* binding */ CarouselViewRenderer)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/BrowserUtil */ "./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js");
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");



const avLogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('carousel-renderer');
class CarouselViewRenderer {
    constructor(view, eventHandler, config) {
        this.lastRenderedContainer = null;
        this.lastRenderedCollectionName = null;
        this.lastRenderedCollection = null;
        this.previousWindowWidth = 0;
        this.view = view;
        this.eventHandler = eventHandler;
        this.config = config;
    }
    removeDisplayElementForCollectionItem(containerEl, collectionName, item) {
        throw new Error('Method not implemented.');
    }
    updateDisplayElementForCollectionItem(containerEl, collectionName, item) {
        throw new Error('Method not implemented.');
    }
    insertDisplayElementForCollectionItem(containerEl, collectionName, item) {
        throw new Error('Method not implemented.');
    }
    onDocumentLoaded() {
        // we need to track window resizing
        this.previousWindowWidth = window.innerWidth;
        window.addEventListener('resize', (event) => {
            const newWindowWidth = window.innerWidth;
            let reRenderRequired = false;
            if (newWindowWidth < this.previousWindowWidth) {
                if (this.previousWindowWidth > _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.SCREEN_WIDTH_LARGE) {
                    if (newWindowWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.SCREEN_WIDTH_LARGE) {
                        // need to re-render carousel
                        reRenderRequired = true;
                        avLogger(`window reduced and is now smaller or equal to large`);
                    }
                }
                if (this.previousWindowWidth > _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.SCREEN_WIDTH_MEDIUM) {
                    if (newWindowWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.SCREEN_WIDTH_MEDIUM) {
                        // need to re-render carousel
                        reRenderRequired = true;
                        avLogger(`window reduced and is now smaller or equal to medium`);
                    }
                }
                if (this.previousWindowWidth > _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.SCREEN_WIDTH_SMALL) {
                    if (newWindowWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.SCREEN_WIDTH_SMALL) {
                        // need to re-render carousel
                        reRenderRequired = true;
                        avLogger(`window reduced and is now smaller or equal to small`);
                    }
                }
            }
            else {
                if (this.previousWindowWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.SCREEN_WIDTH_SMALL) {
                    if (newWindowWidth > _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.SCREEN_WIDTH_SMALL) {
                        // need to re-render carousel
                        avLogger(`window increased and is now larger than small`);
                        reRenderRequired = true;
                    }
                }
                if (this.previousWindowWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.SCREEN_WIDTH_MEDIUM) {
                    if (newWindowWidth > _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.SCREEN_WIDTH_MEDIUM) {
                        avLogger(`window increased and is now larger than medium`);
                        // need to re-render carousel
                        reRenderRequired = true;
                    }
                }
                if (this.previousWindowWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.SCREEN_WIDTH_LARGE) {
                    if (newWindowWidth > _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.SCREEN_WIDTH_LARGE) {
                        avLogger(`window increased and is now larger than large`);
                        // need to re-render carousel
                        reRenderRequired = true;
                    }
                }
            }
            this.previousWindowWidth = newWindowWidth;
            if (this.lastRenderedContainer && this.lastRenderedCollection && this.lastRenderedCollectionName && reRenderRequired) {
                this.setDisplayElementsForCollectionInContainer(this.lastRenderedContainer, this.lastRenderedCollectionName, this.lastRenderedCollection);
            }
        });
    }
    createDisplayElementForCollectionItem(collectionName, item) {
        const dataSourceKeyId = this.view.getDataSourceKeyId();
        const resultDataKeyId = this.view.getIdForItemInNamedCollection(collectionName, item);
        const canDeleteItem = this.view.hasPermissionToDeleteItemInNamedCollection(collectionName, item);
        avLogger(`view ${this.view.getName()}: creating carousel item`);
        avLogger(item);
        const collectionConfig = this.view.getCollectionUIConfig();
        let childEl = document.createElement(collectionConfig.resultsElement.type);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(childEl, collectionConfig.resultsElement.classes);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(childEl, collectionConfig.resultsElement.attributes);
        childEl.setAttribute(collectionConfig.keyId, resultDataKeyId);
        childEl.setAttribute(dataSourceKeyId, collectionConfig.viewConfig.dataSourceId);
        if (collectionConfig.detail.background) {
            let backgroundEl = document.createElement(collectionConfig.detail.background.type);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(backgroundEl, collectionConfig.detail.background.classes);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(backgroundEl, collectionConfig.detail.background.attributes);
            backgroundEl.setAttribute(collectionConfig.keyId, resultDataKeyId);
            backgroundEl.setAttribute(dataSourceKeyId, collectionConfig.viewConfig.dataSourceId);
            childEl.appendChild(backgroundEl);
            this.view.renderBackgroundForItemInNamedCollection(backgroundEl, collectionName, item);
        }
        // the content may be structured
        let textEl = childEl;
        if (collectionConfig.detail.containerClasses) {
            let contentEl = document.createElement('div');
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(contentEl, collectionConfig.detail.containerClasses);
            contentEl.setAttribute(collectionConfig.keyId, resultDataKeyId);
            contentEl.setAttribute(dataSourceKeyId, collectionConfig.viewConfig.dataSourceId);
            textEl = document.createElement(collectionConfig.detail.textElement.type);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(textEl, collectionConfig.detail.textElement.type);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(textEl, collectionConfig.detail.textElement.attributes);
            textEl.setAttribute(collectionConfig.keyId, resultDataKeyId);
            textEl.setAttribute(dataSourceKeyId, collectionConfig.viewConfig.dataSourceId);
            contentEl.appendChild(textEl);
            if (collectionConfig.extraActions || collectionConfig.detail.delete) {
                let buttonsEl = document.createElement(this.config.actionContainer.type);
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(buttonsEl, this.config.actionContainer.classes);
                contentEl.appendChild(buttonsEl);
                if (collectionConfig.extraActions) {
                    collectionConfig.extraActions.forEach((extraAction) => {
                        const hasPermissionForAction = this.view.hasPermissionForActionOnItemInNamedCollection(extraAction.name, collectionName, item);
                        if (hasPermissionForAction) {
                            let action = document.createElement('button');
                            action.setAttribute('type', 'button');
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(action, extraAction.button.classes);
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(action, extraAction.button.attributes);
                            if (extraAction.button.text) {
                                action.innerHTML = extraAction.button.text;
                            }
                            if (extraAction.button.iconClasses) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, extraAction.button.iconClasses);
                                iconEl.setAttribute(collectionConfig.keyId, resultDataKeyId);
                                iconEl.setAttribute(dataSourceKeyId, collectionConfig.viewConfig.dataSourceId);
                                iconEl.setAttribute(_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.EXTRA_ACTION_ATTRIBUTE_NAME, extraAction.name);
                                action.appendChild(iconEl);
                            }
                            action.setAttribute(collectionConfig.keyId, resultDataKeyId);
                            action.setAttribute(dataSourceKeyId, collectionConfig.viewConfig.dataSourceId);
                            action.setAttribute(_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.EXTRA_ACTION_ATTRIBUTE_NAME, extraAction.name);
                            action.addEventListener('click', (event) => {
                                event.preventDefault();
                                event.stopPropagation();
                                this.eventHandler.eventActionClicked(event);
                            });
                            buttonsEl.appendChild(action);
                        }
                    });
                }
                if (collectionConfig.detail.delete && collectionConfig && canDeleteItem) {
                    let deleteButtonEl = document.createElement('button');
                    deleteButtonEl.setAttribute('type', 'button');
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(deleteButtonEl, collectionConfig.detail.delete.classes);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(deleteButtonEl, collectionConfig.detail.delete.attributes);
                    if (collectionConfig.detail.delete.text) {
                        deleteButtonEl.innerHTML = collectionConfig.detail.delete.text;
                    }
                    if (collectionConfig.detail.delete.iconClasses) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, collectionConfig.detail.delete.iconClasses);
                        iconEl.setAttribute(collectionConfig.keyId, resultDataKeyId);
                        iconEl.setAttribute(dataSourceKeyId, collectionConfig.viewConfig.dataSourceId);
                        deleteButtonEl.appendChild(iconEl);
                    }
                    deleteButtonEl.setAttribute(collectionConfig.keyId, resultDataKeyId);
                    deleteButtonEl.setAttribute(dataSourceKeyId, collectionConfig.viewConfig.dataSourceId);
                    deleteButtonEl.addEventListener('click', (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        this.eventHandler.eventDeleteClickItem(event);
                    });
                    buttonsEl.appendChild(deleteButtonEl);
                }
            }
            childEl.appendChild(contentEl);
            if (collectionConfig.detail.drag) {
                childEl.setAttribute('draggable', 'true');
                childEl.addEventListener('dragstart', this.eventHandler.eventStartDrag);
            }
            // add selection actions
            if (collectionConfig.detail.select) {
                childEl.addEventListener('click', this.eventHandler.eventClickItem);
            }
        }
        // add the key ids for selection
        textEl.setAttribute(collectionConfig.keyId, resultDataKeyId);
        textEl.setAttribute(dataSourceKeyId, collectionConfig.viewConfig.dataSourceId);
        const displayText = this.view.renderDisplayForItemInNamedCollection(textEl, collectionName, item);
        // add icons
        // add modifiers for patient state
        if (collectionConfig.modifiers) {
            const modifier = this.view.getModifierForItemInNamedCollection(collectionName, item);
            const secondModifier = this.view.getSecondaryModifierForItemInNamedCollection(collectionName, item);
            switch (modifier) {
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.Modifier.normal: {
                    avLogger(`view ${this.view.getName()}: normal item`);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(childEl, collectionConfig.modifiers.normal);
                    if (collectionConfig.icons && collectionConfig.icons.normal) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, collectionConfig.icons.normal);
                        iconEl.setAttribute(collectionConfig.keyId, resultDataKeyId);
                        iconEl.setAttribute(dataSourceKeyId, collectionConfig.viewConfig.dataSourceId);
                        textEl.appendChild(iconEl);
                    }
                    switch (secondModifier) {
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.Modifier.warning: {
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].removeClasses(childEl, collectionConfig.modifiers.normal);
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(childEl, collectionConfig.modifiers.warning);
                            if (collectionConfig.icons && collectionConfig.icons.warning) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, collectionConfig.icons.warning);
                                iconEl.setAttribute(collectionConfig.keyId, resultDataKeyId);
                                iconEl.setAttribute(dataSourceKeyId, collectionConfig.viewConfig.dataSourceId);
                                textEl.appendChild(iconEl);
                            }
                            break;
                        }
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.Modifier.active: {
                            if (collectionConfig.icons && collectionConfig.icons.active) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, collectionConfig.icons.active);
                                iconEl.setAttribute(collectionConfig.keyId, resultDataKeyId);
                                iconEl.setAttribute(dataSourceKeyId, collectionConfig.viewConfig.dataSourceId);
                                textEl.appendChild(iconEl);
                            }
                        }
                    }
                    break;
                }
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.Modifier.active: {
                    avLogger(`view ${this.view.getName()}: active item`);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(childEl, collectionConfig.modifiers.active);
                    if (collectionConfig.icons && collectionConfig.icons.active) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, collectionConfig.icons.active);
                        iconEl.setAttribute(collectionConfig.keyId, resultDataKeyId);
                        iconEl.setAttribute(dataSourceKeyId, collectionConfig.viewConfig.dataSourceId);
                        textEl.appendChild(iconEl);
                    }
                    switch (secondModifier) {
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.Modifier.warning: {
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].removeClasses(childEl, collectionConfig.modifiers.active);
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(childEl, collectionConfig.modifiers.warning);
                            if (collectionConfig.icons && collectionConfig.icons.warning) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, collectionConfig.icons.warning);
                                iconEl.setAttribute(collectionConfig.keyId, resultDataKeyId);
                                iconEl.setAttribute(dataSourceKeyId, collectionConfig.viewConfig.dataSourceId);
                                textEl.appendChild(iconEl);
                            }
                            break;
                        }
                    }
                    break;
                }
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.Modifier.inactive: {
                    avLogger(`view ${this.view.getName()}: inactive item`);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(childEl, collectionConfig.modifiers.inactive);
                    if (collectionConfig.icons && collectionConfig.icons.inactive) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, collectionConfig.icons.inactive);
                        iconEl.setAttribute(collectionConfig.keyId, resultDataKeyId);
                        iconEl.setAttribute(dataSourceKeyId, collectionConfig.viewConfig.dataSourceId);
                        textEl.appendChild(iconEl);
                    }
                    switch (secondModifier) {
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.Modifier.warning: {
                            if (collectionConfig.icons && collectionConfig.icons.warning) {
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].removeClasses(childEl, collectionConfig.modifiers.inactive);
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(childEl, collectionConfig.modifiers.warning);
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, collectionConfig.icons.warning);
                                iconEl.setAttribute(collectionConfig.keyId, resultDataKeyId);
                                iconEl.setAttribute(dataSourceKeyId, collectionConfig.viewConfig.dataSourceId);
                                textEl.appendChild(iconEl);
                            }
                            break;
                        }
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.Modifier.active: {
                            if (collectionConfig.icons && collectionConfig.icons.active) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, collectionConfig.icons.active);
                                iconEl.setAttribute(collectionConfig.keyId, resultDataKeyId);
                                iconEl.setAttribute(dataSourceKeyId, collectionConfig.viewConfig.dataSourceId);
                                textEl.appendChild(iconEl);
                            }
                            break;
                        }
                    }
                    break;
                }
            }
        }
        return childEl;
    }
    setDisplayElementsForCollectionInContainer(containerEl, collectionName, newState) {
        avLogger(`view ${this.view.getName()}: creating carousel results`);
        avLogger(newState);
        // remove the previous items from list
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].removeAllChildren(containerEl);
        // need to break the items up by row, and the last row is active (assumes increasing time order)
        const numberOfResults = newState.length;
        // number of items per row depends on view port
        let itemsPerRow = this.config.itemsPerRow.xlarge;
        if (window.innerWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.SCREEN_WIDTH_LARGE) {
            itemsPerRow = this.config.itemsPerRow.large;
        }
        if (window.innerWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.SCREEN_WIDTH_MEDIUM) {
            itemsPerRow = this.config.itemsPerRow.medium;
        }
        if (window.innerWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.SCREEN_WIDTH_SMALL) {
            itemsPerRow = this.config.itemsPerRow.small;
        }
        const numberOfRows = Math.ceil(numberOfResults / itemsPerRow);
        avLogger(`view ${this.view.getName()}: creating carousel with number of results per row of ${itemsPerRow} with rows ${numberOfRows}`);
        for (let rowIndex = 0; rowIndex < numberOfRows; rowIndex++) {
            // create the row
            let rowContainerEl = document.createElement(this.config.rowContainer.type);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(rowContainerEl, this.config.rowContainer.classes);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(rowContainerEl, this.config.rowContainer.attributes);
            //browserUtil.addAttributes(rowContainerEl,[{name:'style',value:'display:block'}]);
            let rowEl = document.createElement(this.config.row.type);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(rowEl, this.config.row.classes);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(rowEl, this.config.row.attributes);
            rowContainerEl.appendChild(rowEl);
            // if this the active row?
            if (((rowIndex === 0) && this.config.activeRowPosition === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.RowPosition.first) ||
                ((rowIndex === (numberOfRows - 1)) && this.config.activeRowPosition === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_2__.RowPosition.last)) {
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(rowContainerEl, this.config.activeRow.classes);
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(rowContainerEl, this.config.activeRow.attributes);
            }
            let itemIndex = rowIndex * itemsPerRow;
            while (itemIndex < ((rowIndex + 1) * itemsPerRow) && (itemIndex < numberOfResults)) {
                avLogger(`rowIndex ${rowIndex} item index ${itemIndex}`);
                const item = newState[itemIndex];
                let itemContainerEl = rowEl;
                if (this.config.multipleItemsPerRowContainer) {
                    itemContainerEl = document.createElement(this.config.multipleItemsPerRowContainer.type);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(itemContainerEl, this.config.multipleItemsPerRowContainer.classes);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(itemContainerEl, this.config.multipleItemsPerRowContainer.attributes);
                    rowEl.appendChild(itemContainerEl);
                }
                const itemEl = this.createDisplayElementForCollectionItem(collectionName, item);
                itemContainerEl.appendChild(itemEl);
                itemIndex++;
            }
            containerEl.appendChild(rowContainerEl);
        }
        if (!_util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].isMobileDevice())
            $('[data-toggle="tooltip"]').tooltip();
        this.lastRenderedContainer = containerEl;
        this.lastRenderedCollectionName = collectionName;
        this.lastRenderedCollection = newState;
    }
}
//# sourceMappingURL=CarouselViewRenderer.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/CarouselViewRendererUsingContext.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/CarouselViewRendererUsingContext.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CarouselViewRendererUsingContext": () => (/* binding */ CarouselViewRendererUsingContext)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/BrowserUtil */ "./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js");
/* harmony import */ var _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../context/ContextualInformationHelper */ "./node_modules/ui-framework-jps/dist/framework/ui/context/ContextualInformationHelper.js");




const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('carousel-renderer');
class CarouselViewRendererUsingContext {
    constructor(view, eventHandler, config) {
        this.lastRenderedContainer = null;
        this.lastRenderedCollectionName = null;
        this.lastRenderedCollection = null;
        this.previousWindowWidth = 0;
        this.view = view;
        this.eventHandler = eventHandler;
        this.config = config;
    }
    onDocumentLoaded() {
        // we need to track window resizing
        this.previousWindowWidth = window.innerWidth;
        window.addEventListener('resize', (event) => {
            const newWindowWidth = window.innerWidth;
            let reRenderRequired = false;
            if (newWindowWidth < this.previousWindowWidth) {
                if (this.previousWindowWidth > _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.SCREEN_WIDTH_LARGE) {
                    if (newWindowWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.SCREEN_WIDTH_LARGE) {
                        // need to re-render carousel
                        reRenderRequired = true;
                        logger(`window reduced and is now smaller or equal to large`);
                    }
                }
                if (this.previousWindowWidth > _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.SCREEN_WIDTH_MEDIUM) {
                    if (newWindowWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.SCREEN_WIDTH_MEDIUM) {
                        // need to re-render carousel
                        reRenderRequired = true;
                        logger(`window reduced and is now smaller or equal to medium`);
                    }
                }
                if (this.previousWindowWidth > _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.SCREEN_WIDTH_SMALL) {
                    if (newWindowWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.SCREEN_WIDTH_SMALL) {
                        // need to re-render carousel
                        reRenderRequired = true;
                        logger(`window reduced and is now smaller or equal to small`);
                    }
                }
            }
            else {
                if (this.previousWindowWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.SCREEN_WIDTH_SMALL) {
                    if (newWindowWidth > _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.SCREEN_WIDTH_SMALL) {
                        // need to re-render carousel
                        logger(`window increased and is now larger than small`);
                        reRenderRequired = true;
                    }
                }
                if (this.previousWindowWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.SCREEN_WIDTH_MEDIUM) {
                    if (newWindowWidth > _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.SCREEN_WIDTH_MEDIUM) {
                        logger(`window increased and is now larger than medium`);
                        // need to re-render carousel
                        reRenderRequired = true;
                    }
                }
                if (this.previousWindowWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.SCREEN_WIDTH_LARGE) {
                    if (newWindowWidth > _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.SCREEN_WIDTH_LARGE) {
                        logger(`window increased and is now larger than large`);
                        // need to re-render carousel
                        reRenderRequired = true;
                    }
                }
            }
            this.previousWindowWidth = newWindowWidth;
            if (this.lastRenderedContainer && this.lastRenderedCollection && this.lastRenderedCollectionName && reRenderRequired) {
                this.setDisplayElementsForCollectionInContainer(this.lastRenderedContainer, this.lastRenderedCollectionName, this.lastRenderedCollection);
            }
        });
    }
    createDisplayElementForCollectionItem(collectionName, item) {
        const canDeleteItem = this.view.hasPermissionToDeleteItemInNamedCollection(collectionName, item);
        logger(`view ${this.view.getName()}: creating carousel item`);
        logger(item);
        const collectionConfig = this.view.getCollectionUIConfig();
        let childEl = document.createElement(collectionConfig.resultsElement.type);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(childEl, collectionConfig.resultsElement.classes);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(childEl, collectionConfig.resultsElement.attributes);
        if (collectionConfig.detail.background) {
            let backgroundEl = document.createElement(collectionConfig.detail.background.type);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(backgroundEl, collectionConfig.detail.background.classes);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(backgroundEl, collectionConfig.detail.background.attributes);
            childEl.appendChild(backgroundEl);
            this.view.renderBackgroundForItemInNamedCollection(backgroundEl, collectionName, item);
        }
        // the content may be structured
        let textEl = childEl;
        if (collectionConfig.detail.containerClasses) {
            let contentEl = document.createElement('div');
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(contentEl, collectionConfig.detail.containerClasses);
            textEl = document.createElement(collectionConfig.detail.textElement.type);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(textEl, collectionConfig.detail.textElement.type);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(textEl, collectionConfig.detail.textElement.attributes);
            contentEl.appendChild(textEl);
            if (collectionConfig.extraActions || collectionConfig.detail.delete) {
                let buttonsEl = document.createElement(this.config.actionContainer.type);
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(buttonsEl, this.config.actionContainer.classes);
                contentEl.appendChild(buttonsEl);
                if (collectionConfig.extraActions) {
                    collectionConfig.extraActions.forEach((extraAction) => {
                        const hasPermissionForAction = this.view.hasPermissionForActionOnItemInNamedCollection(extraAction.name, collectionName, item);
                        if (hasPermissionForAction) {
                            let action = document.createElement('button');
                            action.setAttribute('type', 'button');
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(action, extraAction.button.classes);
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(action, extraAction.button.attributes);
                            if (extraAction.button.text) {
                                action.innerHTML = extraAction.button.text;
                            }
                            if (extraAction.button.iconClasses) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, extraAction.button.iconClasses);
                                iconEl.setAttribute(_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.EXTRA_ACTION_ATTRIBUTE_NAME, extraAction.name);
                                action.appendChild(iconEl);
                            }
                            action.setAttribute(_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.EXTRA_ACTION_ATTRIBUTE_NAME, extraAction.name);
                            action.addEventListener('click', (event) => {
                                event.preventDefault();
                                event.stopPropagation();
                                this.eventHandler.eventActionClicked(event);
                            });
                            buttonsEl.appendChild(action);
                        }
                    });
                }
                if (collectionConfig.detail.delete && collectionConfig && canDeleteItem) {
                    let deleteButtonEl = document.createElement('button');
                    deleteButtonEl.setAttribute('type', 'button');
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(deleteButtonEl, collectionConfig.detail.delete.classes);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(deleteButtonEl, collectionConfig.detail.delete.attributes);
                    if (collectionConfig.detail.delete.text) {
                        deleteButtonEl.innerHTML = collectionConfig.detail.delete.text;
                    }
                    if (collectionConfig.detail.delete.iconClasses) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, collectionConfig.detail.delete.iconClasses);
                        deleteButtonEl.appendChild(iconEl);
                    }
                    deleteButtonEl.addEventListener('click', (event) => {
                        event.preventDefault();
                        event.stopPropagation();
                        this.eventHandler.eventDeleteClickItem(event);
                    });
                    buttonsEl.appendChild(deleteButtonEl);
                }
            }
            childEl.appendChild(contentEl);
            if (collectionConfig.detail.drag) {
                childEl.setAttribute('draggable', 'true');
                childEl.addEventListener('dragstart', this.eventHandler.eventStartDrag);
            }
            // add selection actions
            if (collectionConfig.detail.select) {
                childEl.addEventListener('click', this.eventHandler.eventClickItem);
            }
        }
        const displayText = this.view.renderDisplayForItemInNamedCollection(textEl, collectionName, item);
        // add icons
        // add modifiers for patient state
        if (collectionConfig.modifiers) {
            const modifier = this.view.getModifierForItemInNamedCollection(collectionName, item);
            const secondModifier = this.view.getSecondaryModifierForItemInNamedCollection(collectionName, item);
            switch (modifier) {
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.normal: {
                    logger(`view ${this.view.getName()}: normal item`);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(childEl, collectionConfig.modifiers.normal);
                    if (collectionConfig.icons && collectionConfig.icons.normal) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, collectionConfig.icons.normal);
                        textEl.appendChild(iconEl);
                    }
                    switch (secondModifier) {
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.warning: {
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].removeClasses(childEl, collectionConfig.modifiers.normal);
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(childEl, collectionConfig.modifiers.warning);
                            if (collectionConfig.icons && collectionConfig.icons.warning) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, collectionConfig.icons.warning);
                                textEl.appendChild(iconEl);
                            }
                            break;
                        }
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.active: {
                            if (collectionConfig.icons && collectionConfig.icons.active) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, collectionConfig.icons.active);
                                textEl.appendChild(iconEl);
                            }
                        }
                    }
                    break;
                }
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.active: {
                    logger(`view ${this.view.getName()}: active item`);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(childEl, collectionConfig.modifiers.active);
                    if (collectionConfig.icons && collectionConfig.icons.active) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, collectionConfig.icons.active);
                        textEl.appendChild(iconEl);
                    }
                    switch (secondModifier) {
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.warning: {
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].removeClasses(childEl, collectionConfig.modifiers.active);
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(childEl, collectionConfig.modifiers.warning);
                            if (collectionConfig.icons && collectionConfig.icons.warning) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, collectionConfig.icons.warning);
                                textEl.appendChild(iconEl);
                            }
                            break;
                        }
                    }
                    break;
                }
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.inactive: {
                    logger(`view ${this.view.getName()}: inactive item`);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(childEl, collectionConfig.modifiers.inactive);
                    if (collectionConfig.icons && collectionConfig.icons.inactive) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, collectionConfig.icons.inactive);
                        textEl.appendChild(iconEl);
                    }
                    switch (secondModifier) {
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.warning: {
                            if (collectionConfig.icons && collectionConfig.icons.warning) {
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].removeClasses(childEl, collectionConfig.modifiers.inactive);
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(childEl, collectionConfig.modifiers.warning);
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, collectionConfig.icons.warning);
                                textEl.appendChild(iconEl);
                            }
                            break;
                        }
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.active: {
                            if (collectionConfig.icons && collectionConfig.icons.active) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, collectionConfig.icons.active);
                                textEl.appendChild(iconEl);
                            }
                            break;
                        }
                    }
                    break;
                }
            }
        }
        return childEl;
    }
    setDisplayElementsForCollectionInContainer(containerEl, collectionName, newState) {
        logger(`view ${this.view.getName()}: creating carousel results`);
        logger(newState);
        // remove the previous items from list
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].removeAllChildren(containerEl);
        // need to break the items up by row, and the last row is active (assumes increasing time order)
        const numberOfResults = newState.length;
        // number of items per row depends on view port
        let itemsPerRow = this.config.itemsPerRow.xlarge;
        if (window.innerWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.SCREEN_WIDTH_LARGE) {
            itemsPerRow = this.config.itemsPerRow.large;
        }
        if (window.innerWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.SCREEN_WIDTH_MEDIUM) {
            itemsPerRow = this.config.itemsPerRow.medium;
        }
        if (window.innerWidth <= _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.SCREEN_WIDTH_SMALL) {
            itemsPerRow = this.config.itemsPerRow.small;
        }
        const numberOfRows = Math.ceil(numberOfResults / itemsPerRow);
        logger(`view ${this.view.getName()}: creating carousel with number of results per row of ${itemsPerRow} with rows ${numberOfRows}`);
        for (let rowIndex = 0; rowIndex < numberOfRows; rowIndex++) {
            // create the row
            let rowContainerEl = document.createElement(this.config.rowContainer.type);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(rowContainerEl, this.config.rowContainer.classes);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(rowContainerEl, this.config.rowContainer.attributes);
            //browserUtil.addAttributes(rowContainerEl,[{name:'style',value:'display:block'}]);
            let rowEl = document.createElement(this.config.row.type);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(rowEl, this.config.row.classes);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(rowEl, this.config.row.attributes);
            rowContainerEl.appendChild(rowEl);
            // if this the active row?
            if (((rowIndex === 0) && this.config.activeRowPosition === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.RowPosition.first) ||
                ((rowIndex === (numberOfRows - 1)) && this.config.activeRowPosition === _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.RowPosition.last)) {
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(rowContainerEl, this.config.activeRow.classes);
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(rowContainerEl, this.config.activeRow.attributes);
            }
            let itemIndex = rowIndex * itemsPerRow;
            while (itemIndex < ((rowIndex + 1) * itemsPerRow) && (itemIndex < numberOfResults)) {
                logger(`rowIndex ${rowIndex} item index ${itemIndex}`);
                const item = newState[itemIndex];
                let itemContainerEl = rowEl;
                if (this.config.multipleItemsPerRowContainer) {
                    itemContainerEl = document.createElement(this.config.multipleItemsPerRowContainer.type);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(itemContainerEl, this.config.multipleItemsPerRowContainer.classes);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(itemContainerEl, this.config.multipleItemsPerRowContainer.attributes);
                    rowEl.appendChild(itemContainerEl);
                }
                const itemEl = this.createDisplayElementForCollectionItem(collectionName, item);
                itemContainerEl.appendChild(itemEl);
                _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_3__.ContextualInformationHelper.getInstance().addContextToElement(this.view.getName(), collectionName, item, itemEl, true, _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_3__.TogglePlacement.bottom);
                itemEl.addEventListener('contextmenu', _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_3__.ContextualInformationHelper.getInstance().handleContextMenu);
                itemIndex++;
            }
            containerEl.appendChild(rowContainerEl);
        }
        if (!_util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].isMobileDevice())
            $('[data-toggle="tooltip"]').tooltip();
        this.lastRenderedContainer = containerEl;
        this.lastRenderedCollectionName = collectionName;
        this.lastRenderedCollection = newState;
    }
    insertDisplayElementForCollectionItem(containerEl, collectionName, item) {
    }
    removeDisplayElementForCollectionItem(containerEl, collectionName, item) {
    }
    updateDisplayElementForCollectionItem(containerEl, collectionName, item) {
    }
}
//# sourceMappingURL=CarouselViewRendererUsingContext.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/CollectionRendererHelper.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/CollectionRendererHelper.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CollectionRendererHelper": () => (/* binding */ CollectionRendererHelper)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);

const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('collection-renderer-helper');
class CollectionRendererHelper {
    constructor(view, renderer) {
        this.view = view;
        this.renderer = renderer;
    }
    insertDisplayElementForCollectionItem(containerEl, collectionName, item) {
        logger(`view ${this.view.getName()}: inserting result`);
        const childEl = this.renderer.createDisplayElementForCollectionItem(collectionName, item);
        const firstChildEl = containerEl.firstChild;
        if (firstChildEl) {
            containerEl.insertBefore(childEl, firstChildEl);
        }
        else {
            containerEl.appendChild(childEl);
        }
    }
    removeDisplayElementForCollectionItem(containerEl, collectionName, item) {
        const resultDataKeyId = this.view.getIdForItemInNamedCollection(collectionName, item);
        const uiConfig = this.view.getCollectionUIConfig();
        const querySelector = `${uiConfig.resultsElement.type}[${uiConfig.keyId}="${resultDataKeyId}"]`;
        logger(`view ${this.view.getName()}: removing result with query selector "${querySelector}"`);
        const childEl = containerEl.querySelector(querySelector);
        if (childEl) {
            containerEl.removeChild(childEl);
        }
    }
    updateDisplayElementForCollectionItem(containerEl, collectionName, item) {
        const resultDataKeyId = this.view.getIdForItemInNamedCollection(collectionName, item);
        const uiConfig = this.view.getCollectionUIConfig();
        const querySelector = `${uiConfig.resultsElement.type}[${uiConfig.keyId}="${resultDataKeyId}"]`;
        logger(`view ${this.view.getName()}: updating result with query selector "${querySelector}"`);
        const oldChildEl = containerEl.querySelector(querySelector);
        if (oldChildEl) {
            const newChildEl = this.renderer.createDisplayElementForCollectionItem(collectionName, item);
            containerEl.insertBefore(newChildEl, oldChildEl);
            containerEl.removeChild(oldChildEl);
        }
        else {
            this.insertDisplayElementForCollectionItem(containerEl, collectionName, item);
        }
    }
}
//# sourceMappingURL=CollectionRendererHelper.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/FormDetailViewRenderer.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/FormDetailViewRenderer.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FormDetailViewRenderer": () => (/* binding */ FormDetailViewRenderer)
/* harmony export */ });
/* harmony import */ var _form_BasicFormImplementation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../form/BasicFormImplementation */ "./node_modules/ui-framework-jps/dist/framework/ui/form/BasicFormImplementation.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _CommonTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");
/* harmony import */ var _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../util/BrowserUtil */ "./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js");




const logger = debug__WEBPACK_IMPORTED_MODULE_1___default()('form-detail-view-renderer');
class FormDetailViewRenderer {
    constructor(containerId, objDef, permissionChecker, configHelper, hasExternalControl = false) {
        this.form = null;
        this.containerId = containerId;
        this.objDef = objDef;
        this.currentItem = {};
        this.isNewItem = false;
        this.forwarder = null;
        this.view = null;
        this.permissionChecker = permissionChecker;
        this.configHelper = configHelper;
        this.hasExternalControl = hasExternalControl;
    }
    isShowing() {
        if (this.view) {
            return this.view.isShowing();
        }
        return true;
    }
    hasActionPermission(actionName, from, item) {
        return true;
    }
    setEventForwarder(forwarder) {
        this.forwarder = forwarder;
    }
    setView(view) {
        this.view = view;
    }
    onDocumentLoaded() {
        this.form = new _form_BasicFormImplementation__WEBPACK_IMPORTED_MODULE_0__.BasicFormImplementation(this.containerId, this.objDef, this.configHelper, this.permissionChecker, this.hasExternalControl);
        this.form.addListener(this);
    }
    reset() {
        if (this.form)
            this.form.reset();
    }
    initialise(runtimeConfig) {
        if (this.form)
            this.form.initialise(runtimeConfig);
    }
    displayItemReadonly(dataObject) {
        var _a, _b;
        this.isNewItem = false;
        if (this.form)
            this.form.displayOnly(dataObject);
        if ((_a = this.form) === null || _a === void 0 ? void 0 : _a.isAutoScroll())
            (_b = this.form) === null || _b === void 0 ? void 0 : _b.scrollToTop();
    }
    getName() {
        return this.objDef.displayName;
    }
    setContainedBy(container) {
        throw new Error("Method not implemented.");
    }
    addEventListener(listener) {
        throw new Error("Method not implemented.");
    }
    hasChanged() {
        let result = false;
        if (this.form)
            result = this.form.hasChanged();
        return result;
    }
    getUIConfig() {
        throw new Error("Method not implemented.");
    }
    getDataSourceKeyId() {
        throw new Error("Method not implemented.");
    }
    clearDisplay() {
        var _a, _b;
        this.isNewItem = false;
        if (this.form)
            this.form.reset();
        if ((_a = this.form) === null || _a === void 0 ? void 0 : _a.isAutoScroll())
            (_b = this.form) === null || _b === void 0 ? void 0 : _b.scrollToTop();
    }
    clearReadOnly() {
        if (this.form)
            this.form.clearReadOnly();
    }
    setReadOnly() {
        if (this.form)
            this.form.setReadOnly();
    }
    isReadOnly() {
        let result = false;
        if (this.form)
            result = this.form.isReadOnly();
        return result;
    }
    createItem(dataObj) {
        var _a, _b, _c;
        this.currentItem = {};
        logger(`Creating new item with form ${(_a = this.form) === null || _a === void 0 ? void 0 : _a.getId()}`);
        if (this.form) {
            this.isNewItem = true;
            this.currentItem = this.form.startCreateNew(dataObj);
        }
        if (!_util_BrowserUtil__WEBPACK_IMPORTED_MODULE_3__["default"].isMobileDevice())
            $('[data-toggle="tooltip"]').tooltip();
        if ((_b = this.form) === null || _b === void 0 ? void 0 : _b.isAutoScroll())
            (_c = this.form) === null || _c === void 0 ? void 0 : _c.scrollToTop();
        return this.currentItem;
    }
    displayItem(dataObj) {
        var _a, _b;
        this.currentItem = dataObj;
        this.isNewItem = false;
        if (this.hasPermissionToUpdateItem(dataObj)) {
            if (this.form)
                this.form.startUpdate(dataObj);
        }
        else {
            if (this.form)
                this.form.displayOnly(dataObj);
        }
        if (!_util_BrowserUtil__WEBPACK_IMPORTED_MODULE_3__["default"].isMobileDevice())
            $('[data-toggle="tooltip"]').tooltip();
        if ((_a = this.form) === null || _a === void 0 ? void 0 : _a.isAutoScroll())
            (_b = this.form) === null || _b === void 0 ? void 0 : _b.scrollToTop();
    }
    hide() {
        if (this.form)
            this.form.setIsVisible(false);
    }
    show() {
        var _a, _b;
        if (this.form)
            this.form.setIsVisible(true);
        if ((_a = this.form) === null || _a === void 0 ? void 0 : _a.isAutoScroll())
            (_b = this.form) === null || _b === void 0 ? void 0 : _b.scrollToTop();
    }
    render() {
        this.displayItem(this.currentItem);
        this.show();
    }
    hasPermissionToDeleteItem(item) {
        return this.permissionChecker.hasPermissionToDeleteItem(item);
    }
    hasPermissionToUpdateItem(item) {
        return this.permissionChecker.hasPermissionToUpdateItem(item);
    }
    getForm() {
        return this.form;
    }
    handleActionItem(actionName, selectedItem) {
    }
    isDisplayingItem(dataObj) {
        let result = false;
        if (this.currentItem) {
            if (this.form) {
                result = this.form.isDisplayingItem(dataObj);
            }
        }
        return result;
    }
    itemViewEvent(name, event, formValues) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        // catch form events for user leaving the form
        switch (event.eventType) {
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.CANCELLING): {
                logger(`Form is cancelling`);
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.CANCELLING_ABORTED): {
                logger(`Form is cancelling - aborted`);
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.CANCELLED): {
                logger(`Form is cancelled - resetting`);
                this.currentItem = formValues;
                if (this.forwarder && this.view)
                    this.forwarder.cancelled(this.view, this.currentItem);
                if ((_a = this.form) === null || _a === void 0 ? void 0 : _a.isAutoScroll())
                    (_b = this.form) === null || _b === void 0 ? void 0 : _b.scrollToTop();
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.DELETING): {
                logger(`Form is deleting`);
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.DELETE_ABORTED): {
                logger(`Form is deleting - aborted`);
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.DELETED): {
                logger(`Form is deleted - resetting`);
                this.currentItem = formValues;
                if (this.forwarder && this.view)
                    this.forwarder.deletedItem(this.view, this.currentItem);
                if ((_c = this.form) === null || _c === void 0 ? void 0 : _c.isAutoScroll())
                    (_d = this.form) === null || _d === void 0 ? void 0 : _d.scrollToTop();
                // user is deleting the object, will become invisible
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.SAVE_ABORTED): {
                if ((_e = this.form) === null || _e === void 0 ? void 0 : _e.isAutoScroll())
                    (_f = this.form) === null || _f === void 0 ? void 0 : _f.scrollToTop();
                logger(`Form save cancelled`);
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.SAVED): {
                logger(`Form is saved with data`);
                if (this.form) {
                    let formattedObj = (_g = this.form) === null || _g === void 0 ? void 0 : _g.getFormattedDataObject();
                    if (this.isNewItem) {
                        if (this.forwarder && this.view)
                            this.forwarder.saveNewItem(this.view, formattedObj);
                    }
                    else {
                        if (this.forwarder && this.view)
                            this.forwarder.updateItem(this.view, formattedObj);
                    }
                    this.isNewItem = false;
                    if (this.form.isAutoScroll())
                        (_h = this.form) === null || _h === void 0 ? void 0 : _h.scrollToTop();
                }
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.SAVING): {
                logger(`Form is saving`);
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.COMPOSITE_EDIT): {
                logger(`Composite field edit ${event.fieldId}`);
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.COMPOSITE_ARRAY_EDIT): {
                logger(`Composite field array edit ${event.fieldId}`);
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.LINKED_EDIT): {
                logger(`Linked field edit ${event.fieldId}`);
                break;
            }
            case (_CommonTypes__WEBPACK_IMPORTED_MODULE_2__.ItemEventType.LINKED_ARRAY_EDIT): {
                logger(`Linked array field edit ${event.fieldId}`);
                break;
            }
        }
        return false;
    }
    getItemDescription(from, item) {
        return "";
    }
    getItemId(from, item) {
        return "";
    }
    itemViewHasChanged(name) {
    }
    fieldAction(name, event) {
    }
}
//# sourceMappingURL=FormDetailViewRenderer.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/ListViewRenderer.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/ListViewRenderer.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ListViewRenderer": () => (/* binding */ ListViewRenderer)
/* harmony export */ });
/* harmony import */ var _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../util/BrowserUtil */ "./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js");
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _CollectionRendererHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CollectionRendererHelper */ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/CollectionRendererHelper.js");




const avLogger = debug__WEBPACK_IMPORTED_MODULE_2___default()('list-view-renderer');
class ListViewRenderer {
    constructor(view, eventHandler) {
        this.view = view;
        this.eventHandler = eventHandler;
        this.helper = new _CollectionRendererHelper__WEBPACK_IMPORTED_MODULE_3__.CollectionRendererHelper(view, this);
    }
    removeDisplayElementForCollectionItem(containerEl, collectionName, item) {
        this.helper.removeDisplayElementForCollectionItem(containerEl, collectionName, item);
    }
    updateDisplayElementForCollectionItem(containerEl, collectionName, item) {
        this.helper.updateDisplayElementForCollectionItem(containerEl, collectionName, item);
    }
    insertDisplayElementForCollectionItem(containerEl, collectionName, item) {
        this.helper.insertDisplayElementForCollectionItem(containerEl, collectionName, item);
    }
    createDisplayElementForCollectionItem(collectionName, item) {
        const canDeleteItem = this.view.hasPermissionToDeleteItemInNamedCollection(collectionName, item);
        const uiConfig = this.view.getCollectionUIConfig();
        const dataSourceKeyId = this.view.getDataSourceKeyId();
        avLogger(`view ${this.view.getName()}: creating List item`);
        avLogger(item);
        const resultDataKeyId = this.view.getIdForItemInNamedCollection(collectionName, item);
        let childEl = document.createElement(uiConfig.resultsElement.type);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(childEl, uiConfig.resultsElement.classes);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(childEl, uiConfig.resultsElement.attributes);
        childEl.setAttribute(uiConfig.keyId, resultDataKeyId);
        childEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
        // the content may be structured
        let textEl = childEl;
        if (uiConfig.detail.containerClasses) {
            let contentEl = document.createElement('div');
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(contentEl, uiConfig.detail.containerClasses);
            contentEl.setAttribute(uiConfig.keyId, resultDataKeyId);
            contentEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
            textEl = document.createElement(uiConfig.detail.textElement.type);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(textEl, uiConfig.detail.textElement.classes);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(textEl, uiConfig.detail.textElement.attributes);
            textEl.setAttribute(uiConfig.keyId, resultDataKeyId);
            textEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
            contentEl.appendChild(textEl);
            if (uiConfig.detail.background) {
                let imgEl = document.createElement(uiConfig.detail.background.type);
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(imgEl, uiConfig.detail.background.classes);
                imgEl.setAttribute('src', this.view.getBackgroundImageForItemInNamedCollection(collectionName, item));
                childEl.appendChild(imgEl);
            }
            let buttonsEl = document.createElement('div');
            contentEl.appendChild(buttonsEl);
            if (uiConfig.detail.badge) {
                const badgeValue = this.view.getBadgeValueForItemInNamedCollection(collectionName, item);
                if (badgeValue > 0) {
                    let badgeEl = document.createElement(uiConfig.detail.badge.type);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(badgeEl, uiConfig.detail.badge.classes);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(badgeEl, uiConfig.detail.badge.attributes);
                    badgeEl.setAttribute(uiConfig.keyId, resultDataKeyId);
                    badgeEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
                    buttonsEl.appendChild(badgeEl);
                    badgeEl.innerHTML = `&nbsp;&nbsp;&nbsp;${badgeValue}&nbsp;&nbsp;&nbsp;`;
                }
            }
            if (uiConfig.detail.secondBadge) {
                const badgeValue = this.view.getSecondaryBadgeValueForItemInNamedCollection(collectionName, item);
                if (badgeValue > 0) {
                    let badgeEl = document.createElement(uiConfig.detail.secondBadge.type);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(badgeEl, uiConfig.detail.secondBadge.classes);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(badgeEl, uiConfig.detail.secondBadge.attributes);
                    badgeEl.setAttribute(uiConfig.keyId, resultDataKeyId);
                    badgeEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
                    buttonsEl.appendChild(badgeEl);
                    badgeEl.innerHTML = `&nbsp;&nbsp;&nbsp;${badgeValue}&nbsp;&nbsp;&nbsp;`;
                }
            }
            if (uiConfig.detail.thirdBadge) {
                const badgeValue = this.view.getTertiaryBadgeValueForItemInNamedCollection(collectionName, item);
                if (badgeValue > 0) {
                    let badgeEl = document.createElement(uiConfig.detail.thirdBadge.type);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(badgeEl, uiConfig.detail.thirdBadge.classes);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(badgeEl, uiConfig.detail.thirdBadge.attributes);
                    badgeEl.setAttribute(uiConfig.keyId, resultDataKeyId);
                    badgeEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
                    buttonsEl.appendChild(badgeEl);
                    badgeEl.innerHTML = `&nbsp;&nbsp;&nbsp;${badgeValue}&nbsp;&nbsp;&nbsp;`;
                }
            }
            if (uiConfig.extraActions) {
                uiConfig.extraActions.forEach((extraAction) => {
                    const hasPermissionForAction = this.view.hasPermissionForActionOnItemInNamedCollection(extraAction.name, collectionName, item);
                    if (hasPermissionForAction) {
                        let action = document.createElement('button');
                        action.setAttribute('type', 'button');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(action, extraAction.button.classes);
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(action, extraAction.button.attributes);
                        if (extraAction.button.text) {
                            action.innerHTML = extraAction.button.text;
                        }
                        if (extraAction.button.iconClasses) {
                            let iconEl = document.createElement('i');
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(iconEl, extraAction.button.iconClasses);
                            iconEl.setAttribute(uiConfig.keyId, resultDataKeyId);
                            iconEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
                            iconEl.setAttribute(_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.EXTRA_ACTION_ATTRIBUTE_NAME, extraAction.name);
                            action.appendChild(iconEl);
                        }
                        action.setAttribute(uiConfig.keyId, resultDataKeyId);
                        action.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
                        action.setAttribute(_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.EXTRA_ACTION_ATTRIBUTE_NAME, extraAction.name);
                        action.addEventListener('click', (event) => {
                            event.preventDefault();
                            event.stopPropagation();
                            this.eventHandler.eventActionClicked(event);
                        });
                        buttonsEl.appendChild(action);
                    }
                });
            }
            if (uiConfig.detail.delete && canDeleteItem) {
                let deleteButtonEl = document.createElement('button');
                deleteButtonEl.setAttribute('type', 'button');
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(deleteButtonEl, uiConfig.detail.delete.classes);
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addAttributes(deleteButtonEl, uiConfig.detail.delete.attributes);
                if (uiConfig.detail.delete.text) {
                    deleteButtonEl.innerHTML = uiConfig.detail.delete.text;
                }
                if (uiConfig.detail.delete.iconClasses) {
                    let iconEl = document.createElement('i');
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(iconEl, uiConfig.detail.delete.iconClasses);
                    iconEl.setAttribute(uiConfig.keyId, resultDataKeyId);
                    iconEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
                    deleteButtonEl.appendChild(iconEl);
                }
                deleteButtonEl.setAttribute(uiConfig.keyId, resultDataKeyId);
                deleteButtonEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
                deleteButtonEl.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    this.eventHandler.eventDeleteClickItem(event);
                });
                buttonsEl.appendChild(deleteButtonEl);
            }
            childEl.appendChild(contentEl);
            if (uiConfig.detail.drag) {
                childEl.setAttribute('draggable', 'true');
                childEl.addEventListener('dragstart', this.eventHandler.eventStartDrag);
            }
            // add selection actions
            if (uiConfig.detail.select) {
                childEl.addEventListener('click', this.eventHandler.eventClickItem);
            }
        }
        // add the key ids for selection
        textEl.setAttribute(uiConfig.keyId, resultDataKeyId);
        textEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
        this.view.renderDisplayForItemInNamedCollection(textEl, collectionName, item);
        // add icons
        const icons = this.view.getItemIcons(collectionName, item);
        icons.forEach((icon) => {
            let iconEl = document.createElement('i');
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(iconEl, icon);
            iconEl.setAttribute(uiConfig.keyId, resultDataKeyId);
            iconEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
            if (this.view.prependItemIcons(collectionName, item)) {
                textEl.prepend(iconEl);
            }
            else {
                textEl.append(iconEl);
            }
        });
        // add modifiers for patient state
        if (uiConfig.modifiers) {
            const modifier = this.view.getModifierForItemInNamedCollection(collectionName, item);
            const secondModifier = this.view.getSecondaryModifierForItemInNamedCollection(collectionName, item);
            switch (modifier) {
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.normal: {
                    avLogger(`view ${this.view.getName()}: normal item`);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(childEl, uiConfig.modifiers.normal);
                    if (uiConfig.icons && uiConfig.icons.normal) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(iconEl, uiConfig.icons.normal);
                        iconEl.setAttribute(uiConfig.keyId, resultDataKeyId);
                        iconEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
                        textEl.appendChild(iconEl);
                    }
                    switch (secondModifier) {
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.warning: {
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].removeClasses(childEl, uiConfig.modifiers.normal);
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(childEl, uiConfig.modifiers.warning);
                            if (uiConfig.icons && uiConfig.icons.warning) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(iconEl, uiConfig.icons.warning);
                                iconEl.setAttribute(uiConfig.keyId, resultDataKeyId);
                                iconEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
                                textEl.appendChild(iconEl);
                            }
                            break;
                        }
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.active: {
                            if (uiConfig.icons && uiConfig.icons.active) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(iconEl, uiConfig.icons.active);
                                iconEl.setAttribute(uiConfig.keyId, resultDataKeyId);
                                iconEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
                                textEl.appendChild(iconEl);
                            }
                        }
                    }
                    break;
                }
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.active: {
                    avLogger(`view ${this.view.getName()}: active item`);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(childEl, uiConfig.modifiers.active);
                    if (uiConfig.icons && uiConfig.icons.active) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(iconEl, uiConfig.icons.active);
                        iconEl.setAttribute(uiConfig.keyId, resultDataKeyId);
                        iconEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
                        textEl.appendChild(iconEl);
                    }
                    switch (secondModifier) {
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.warning: {
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].removeClasses(childEl, uiConfig.modifiers.active);
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(childEl, uiConfig.modifiers.warning);
                            if (uiConfig.icons && uiConfig.icons.warning) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(iconEl, uiConfig.icons.warning);
                                iconEl.setAttribute(uiConfig.keyId, resultDataKeyId);
                                iconEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
                                textEl.appendChild(iconEl);
                            }
                            break;
                        }
                    }
                    break;
                }
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.inactive: {
                    avLogger(`view ${this.view.getName()}: inactive item`);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(childEl, uiConfig.modifiers.inactive);
                    if (uiConfig.icons && uiConfig.icons.inactive) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(iconEl, uiConfig.icons.inactive);
                        iconEl.setAttribute(uiConfig.keyId, resultDataKeyId);
                        iconEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
                        textEl.appendChild(iconEl);
                    }
                    switch (secondModifier) {
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.warning: {
                            if (uiConfig.icons && uiConfig.icons.warning) {
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].removeClasses(childEl, uiConfig.modifiers.inactive);
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(childEl, uiConfig.modifiers.warning);
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(iconEl, uiConfig.icons.warning);
                                iconEl.setAttribute(uiConfig.keyId, resultDataKeyId);
                                iconEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
                                textEl.appendChild(iconEl);
                            }
                            break;
                        }
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.active: {
                            if (uiConfig.icons && uiConfig.icons.active) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(iconEl, uiConfig.icons.active);
                                iconEl.setAttribute(uiConfig.keyId, resultDataKeyId);
                                iconEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
                                textEl.appendChild(iconEl);
                            }
                            break;
                        }
                    }
                    break;
                }
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.warning: {
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].removeClasses(childEl, uiConfig.modifiers.normal);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(childEl, uiConfig.modifiers.warning);
                    if (uiConfig.icons && uiConfig.icons.warning) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].addClasses(iconEl, uiConfig.icons.warning);
                        iconEl.setAttribute(uiConfig.keyId, resultDataKeyId);
                        iconEl.setAttribute(dataSourceKeyId, uiConfig.viewConfig.dataSourceId);
                        textEl.appendChild(iconEl);
                    }
                    break;
                }
            }
        }
        return childEl;
    }
    setDisplayElementsForCollectionInContainer(containerEl, collectionName, newState) {
        avLogger(`view ${this.view.getName()}: creating Results`);
        avLogger(newState);
        // remove the previous items from list
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].removeAllChildren(containerEl);
        // add the new children
        newState.map((item, index) => {
            const childEl = this.createDisplayElementForCollectionItem(collectionName, item);
            // add draggable actions
            avLogger(`view ${this.view.getName()}:  Adding child ${this.view.getIdForItemInNamedCollection(collectionName, item)}`);
            containerEl.appendChild(childEl);
        });
        if (!_util_BrowserUtil__WEBPACK_IMPORTED_MODULE_0__["default"].isMobileDevice())
            $('[data-toggle="tooltip"]').tooltip();
    }
    onDocumentLoaded() {
    }
}
//# sourceMappingURL=ListViewRenderer.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/ListViewRendererUsingContext.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/ListViewRendererUsingContext.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ListViewRendererUsingContext": () => (/* binding */ ListViewRendererUsingContext)
/* harmony export */ });
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../util/BrowserUtil */ "./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js");
/* harmony import */ var _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../context/ContextualInformationHelper */ "./node_modules/ui-framework-jps/dist/framework/ui/context/ContextualInformationHelper.js");




const logger = debug__WEBPACK_IMPORTED_MODULE_0___default()('list-view-renderer-with-context');
const paginationLogger = debug__WEBPACK_IMPORTED_MODULE_0___default()('list-view-renderer-with-context:pagination');
class ListViewRendererUsingContext {
    constructor(view, eventHandler, runtimeConfig) {
        this.stateBuffer = [];
        this.currentPage = 0;
        this.observer = null;
        this.currentObservedTarget = null;
        this.view = view;
        this.eventHandler = eventHandler;
        this.runtimeConfig = runtimeConfig;
        this.renderNextPage = this.renderNextPage.bind(this);
    }
    createDisplayElementForCollectionItem(collectionName, item) {
        const canDeleteItem = this.view.hasPermissionToDeleteItemInNamedCollection(collectionName, item);
        const uiConfig = this.view.getCollectionUIConfig();
        logger(`view ${this.view.getName()}: creating List item`);
        logger(item);
        const resultDataKeyId = this.view.getIdForItemInNamedCollection(collectionName, item);
        let childEl = document.createElement(uiConfig.resultsElement.type);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(childEl, uiConfig.resultsElement.classes);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(childEl, uiConfig.resultsElement.attributes);
        // the content may be structured
        let textEl = childEl;
        if (uiConfig.detail.containerClasses) {
            let contentEl = document.createElement('div');
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(contentEl, uiConfig.detail.containerClasses);
            textEl = document.createElement(uiConfig.detail.textElement.type);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(textEl, uiConfig.detail.textElement.classes);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(textEl, uiConfig.detail.textElement.attributes);
            contentEl.appendChild(textEl);
            if (uiConfig.detail.background) {
                let imgEl = document.createElement(uiConfig.detail.background.type);
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(imgEl, uiConfig.detail.background.classes);
                imgEl.setAttribute('src', this.view.getBackgroundImageForItemInNamedCollection(collectionName, item));
                childEl.appendChild(imgEl);
            }
            let buttonsEl = document.createElement('div');
            contentEl.appendChild(buttonsEl);
            if (uiConfig.detail.badge) {
                const badgeValue = this.view.getBadgeValueForItemInNamedCollection(collectionName, item);
                if (badgeValue > 0) {
                    let badgeEl = document.createElement(uiConfig.detail.badge.type);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(badgeEl, uiConfig.detail.badge.classes);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(badgeEl, uiConfig.detail.badge.attributes);
                    buttonsEl.appendChild(badgeEl);
                    badgeEl.innerHTML = `&nbsp;&nbsp;&nbsp;${badgeValue}&nbsp;&nbsp;&nbsp;`;
                }
            }
            if (uiConfig.detail.secondBadge) {
                const badgeValue = this.view.getSecondaryBadgeValueForItemInNamedCollection(collectionName, item);
                if (badgeValue > 0) {
                    let badgeEl = document.createElement(uiConfig.detail.secondBadge.type);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(badgeEl, uiConfig.detail.secondBadge.classes);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(badgeEl, uiConfig.detail.secondBadge.attributes);
                    buttonsEl.appendChild(badgeEl);
                    badgeEl.innerHTML = `&nbsp;&nbsp;&nbsp;${badgeValue}&nbsp;&nbsp;&nbsp;`;
                }
            }
            if (uiConfig.detail.thirdBadge) {
                const badgeValue = this.view.getTertiaryBadgeValueForItemInNamedCollection(collectionName, item);
                if (badgeValue > 0) {
                    let badgeEl = document.createElement(uiConfig.detail.thirdBadge.type);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(badgeEl, uiConfig.detail.thirdBadge.classes);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(badgeEl, uiConfig.detail.thirdBadge.attributes);
                    buttonsEl.appendChild(badgeEl);
                    badgeEl.innerHTML = `&nbsp;&nbsp;&nbsp;${badgeValue}&nbsp;&nbsp;&nbsp;`;
                }
            }
            if (uiConfig.extraActions) {
                uiConfig.extraActions.forEach((extraAction) => {
                    const hasPermissionForAction = this.view.hasPermissionForActionOnItemInNamedCollection(extraAction.name, collectionName, item);
                    if (hasPermissionForAction) {
                        let action = document.createElement('button');
                        action.setAttribute('type', 'button');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(action, extraAction.button.classes);
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(action, extraAction.button.attributes);
                        if (extraAction.button.text) {
                            action.innerHTML = extraAction.button.text;
                        }
                        if (extraAction.button.iconClasses) {
                            let iconEl = document.createElement('i');
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, extraAction.button.iconClasses);
                            iconEl.setAttribute(_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.EXTRA_ACTION_ATTRIBUTE_NAME, extraAction.name);
                            action.appendChild(iconEl);
                        }
                        action.setAttribute(_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.EXTRA_ACTION_ATTRIBUTE_NAME, extraAction.name);
                        action.addEventListener('click', (event) => {
                            event.preventDefault();
                            event.stopPropagation();
                            this.eventHandler.eventActionClicked(event);
                        });
                        buttonsEl.appendChild(action);
                    }
                });
            }
            if (uiConfig.detail.delete && canDeleteItem) {
                let deleteButtonEl = document.createElement('button');
                deleteButtonEl.setAttribute('type', 'button');
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(deleteButtonEl, uiConfig.detail.delete.classes);
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addAttributes(deleteButtonEl, uiConfig.detail.delete.attributes);
                if (uiConfig.detail.delete.text) {
                    deleteButtonEl.innerHTML = uiConfig.detail.delete.text;
                }
                if (uiConfig.detail.delete.iconClasses) {
                    let iconEl = document.createElement('i');
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, uiConfig.detail.delete.iconClasses);
                    deleteButtonEl.appendChild(iconEl);
                }
                deleteButtonEl.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    this.eventHandler.eventDeleteClickItem(event);
                });
                buttonsEl.appendChild(deleteButtonEl);
            }
            childEl.appendChild(contentEl);
            if (uiConfig.detail.drag) {
                childEl.setAttribute('draggable', 'true');
                childEl.addEventListener('dragstart', this.eventHandler.eventStartDrag);
            }
            // add selection actions
            if (uiConfig.detail.select) {
                childEl.addEventListener('click', this.eventHandler.eventClickItem);
            }
        }
        // add the key ids for selection
        this.view.renderDisplayForItemInNamedCollection(textEl, collectionName, item);
        // add icons
        const icons = this.view.getItemIcons(collectionName, item);
        icons.forEach((icon) => {
            let iconEl = document.createElement('i');
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, icon);
            if (this.view.prependItemIcons(collectionName, item)) {
                textEl.prepend(iconEl);
            }
            else {
                textEl.append(iconEl);
            }
        });
        // add modifiers for patient state
        if (uiConfig.modifiers) {
            const modifier = this.view.getModifierForItemInNamedCollection(collectionName, item);
            const secondModifier = this.view.getSecondaryModifierForItemInNamedCollection(collectionName, item);
            switch (modifier) {
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.normal: {
                    logger(`view ${this.view.getName()}: normal item`);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(childEl, uiConfig.modifiers.normal);
                    if (uiConfig.icons && uiConfig.icons.normal) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, uiConfig.icons.normal);
                        textEl.appendChild(iconEl);
                    }
                    switch (secondModifier) {
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.warning: {
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].removeClasses(childEl, uiConfig.modifiers.normal);
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(childEl, uiConfig.modifiers.warning);
                            if (uiConfig.icons && uiConfig.icons.warning) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, uiConfig.icons.warning);
                                textEl.appendChild(iconEl);
                            }
                            break;
                        }
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.active: {
                            if (uiConfig.icons && uiConfig.icons.active) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, uiConfig.icons.active);
                                textEl.appendChild(iconEl);
                            }
                        }
                    }
                    break;
                }
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.active: {
                    logger(`view ${this.view.getName()}: active item`);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(childEl, uiConfig.modifiers.active);
                    if (uiConfig.icons && uiConfig.icons.active) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, uiConfig.icons.active);
                        textEl.appendChild(iconEl);
                    }
                    switch (secondModifier) {
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.warning: {
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].removeClasses(childEl, uiConfig.modifiers.active);
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(childEl, uiConfig.modifiers.warning);
                            if (uiConfig.icons && uiConfig.icons.warning) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, uiConfig.icons.warning);
                                textEl.appendChild(iconEl);
                            }
                            break;
                        }
                    }
                    break;
                }
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.inactive: {
                    logger(`view ${this.view.getName()}: inactive item`);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(childEl, uiConfig.modifiers.inactive);
                    if (uiConfig.icons && uiConfig.icons.inactive) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, uiConfig.icons.inactive);
                        textEl.appendChild(iconEl);
                    }
                    switch (secondModifier) {
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.warning: {
                            if (uiConfig.icons && uiConfig.icons.warning) {
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].removeClasses(childEl, uiConfig.modifiers.inactive);
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(childEl, uiConfig.modifiers.warning);
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, uiConfig.icons.warning);
                                textEl.appendChild(iconEl);
                            }
                            break;
                        }
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.active: {
                            if (uiConfig.icons && uiConfig.icons.active) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, uiConfig.icons.active);
                                textEl.appendChild(iconEl);
                            }
                            break;
                        }
                    }
                    break;
                }
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_1__.Modifier.warning: {
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].removeClasses(childEl, uiConfig.modifiers.normal);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(childEl, uiConfig.modifiers.warning);
                    if (uiConfig.icons && uiConfig.icons.warning) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].addClasses(iconEl, uiConfig.icons.warning);
                        textEl.appendChild(iconEl);
                    }
                    break;
                }
            }
        }
        return childEl;
    }
    setDisplayElementsForCollectionInContainer(containerEl, collectionName, newState) {
        this.currentPage = 0;
        this.stateBuffer = newState;
        this.containerEl = containerEl;
        this.collectionName = collectionName;
        this.setDisplayElementsForCollectionInContainerForNextPage(containerEl, collectionName, newState);
    }
    setDisplayElementsForCollectionInContainerForNextPage(containerEl, collectionName, newState) {
        paginationLogger(`view ${this.view.getName()}: creating Results`);
        logger(newState);
        this.currentPage++;
        let isLazyLoading = false;
        let itemPageSize = this.stateBuffer.length;
        if (this.runtimeConfig) {
            itemPageSize = this.runtimeConfig.lazyLoadPageSize;
            isLazyLoading = true;
        }
        else {
            if (itemPageSize > 50) {
                this.runtimeConfig = {
                    lazyLoadPageSize: 50
                };
                itemPageSize = 50;
                isLazyLoading = true;
            }
        }
        // remove the previous items from list
        if (this.currentPage === 1) {
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].removeAllChildren(containerEl);
        }
        const startItemIndex = (this.currentPage - 1) * itemPageSize;
        let endItemIndex = (this.currentPage * itemPageSize);
        if (this.stateBuffer.length < endItemIndex) {
            endItemIndex = this.stateBuffer.length;
        }
        paginationLogger(`loading items from ${startItemIndex} to ${endItemIndex}`);
        // add the new children
        let lastChildEl;
        for (let index = startItemIndex; index < endItemIndex; index++) {
            const item = this.stateBuffer[index];
            lastChildEl = _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_3__.ContextualInformationHelper.getInstance().insertDisplayElementForCollectionItem(this.view, this, containerEl, collectionName, item);
        }
        ;
        paginationLogger(`Is lazy loading? ${isLazyLoading} and current page count is ${this.currentPage} with page size ${itemPageSize}`);
        if (isLazyLoading && (this.stateBuffer.length > (this.currentPage * itemPageSize))) {
            if (lastChildEl) {
                this.currentObservedTarget = lastChildEl;
                if (this.observer === null) {
                    paginationLogger(`Creating new observer`);
                    // put an observer on the last child
                    this.observer = new IntersectionObserver(this.renderNextPage); //,{root:this.containerEl,threshold:0.0});
                }
                this.observer.observe(lastChildEl);
            }
        }
        if (!_util_BrowserUtil__WEBPACK_IMPORTED_MODULE_2__["default"].isMobileDevice())
            $('[data-toggle="tooltip"]').tooltip();
    }
    renderNextPage(entries) {
        if (entries[0].intersectionRatio <= 0)
            return;
        paginationLogger('rendering next page');
        if (this.observer && this.currentObservedTarget) {
            paginationLogger('unobserving current target');
            paginationLogger(this.currentObservedTarget);
            this.observer.unobserve(this.currentObservedTarget);
            this.currentObservedTarget = null;
        }
        if (this.containerEl && this.collectionName)
            this.setDisplayElementsForCollectionInContainerForNextPage(this.containerEl, this.collectionName, this.stateBuffer);
    }
    onDocumentLoaded() {
    }
    insertDisplayElementForCollectionItem(containerEl, collectionName, item) {
        _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_3__.ContextualInformationHelper.getInstance().insertDisplayElementForCollectionItem(this.view, this, containerEl, collectionName, item, true);
    }
    removeDisplayElementForCollectionItem(containerEl, collectionName, item) {
        _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_3__.ContextualInformationHelper.getInstance().removeDisplayElementForCollectionItem(this.view, this, containerEl, collectionName, item);
    }
    updateDisplayElementForCollectionItem(containerEl, collectionName, item) {
        _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_3__.ContextualInformationHelper.getInstance().updateDisplayElementForCollectionItem(this.view, this, containerEl, collectionName, item);
    }
}
//# sourceMappingURL=ListViewRendererUsingContext.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/TabularViewRendererUsingContext.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/TabularViewRendererUsingContext.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TabularViewRendererUsingContext": () => (/* binding */ TabularViewRendererUsingContext)
/* harmony export */ });
/* harmony import */ var _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../util/BrowserUtil */ "./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../context/ContextualInformationHelper */ "./node_modules/ui-framework-jps/dist/framework/ui/context/ContextualInformationHelper.js");
/* harmony import */ var _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../model/DataObjectTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectTypeDefs.js");





const logger = debug__WEBPACK_IMPORTED_MODULE_2___default()('tabular-view-renderer-with-context');
const paginationLogger = debug__WEBPACK_IMPORTED_MODULE_2___default()('tabular-view-renderer-with-context:pagination');
const loggerEvent = debug__WEBPACK_IMPORTED_MODULE_2___default()('tabular-view-renderer-with-context-event');
class TabularViewRendererUsingContext {
    constructor(view, eventHandler, tableConfig) {
        this.tableBodyEl = null;
        this.stateBuffer = [];
        this.currentPage = 0;
        this.observer = null;
        this.currentObservedTarget = null;
        this.view = view;
        this.eventHandler = eventHandler;
        this.tableConfig = tableConfig;
        this.renderNextPage = this.renderNextPage.bind(this);
    }
    insertDisplayElementForCollectionItem(containerEl, collectionName, item) {
        if (this.tableBodyEl)
            _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_3__.ContextualInformationHelper.getInstance().insertDisplayElementForCollectionItem(this.view, this, this.tableBodyEl, collectionName, item, true);
    }
    removeDisplayElementForCollectionItem(containerEl, collectionName, item) {
        if (this.tableBodyEl)
            _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_3__.ContextualInformationHelper.getInstance().removeDisplayElementForCollectionItem(this.view, this, this.tableBodyEl, collectionName, item);
    }
    updateDisplayElementForCollectionItem(containerEl, collectionName, item) {
        if (this.tableBodyEl)
            _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_3__.ContextualInformationHelper.getInstance().updateDisplayElementForCollectionItem(this.view, this, this.tableBodyEl, collectionName, item);
    }
    createDisplayElementForCollectionItem(collectionName, item) {
        const canDeleteItem = this.view.hasPermissionToDeleteItemInNamedCollection(collectionName, item);
        const uiConfig = this.view.getCollectionUIConfig();
        logger(`view ${this.view.getName()}: creating table row item`);
        logger(item);
        const resultDataKeyId = this.view.getIdForItemInNamedCollection(collectionName, item);
        let tableRowEl = document.createElement(uiConfig.resultsElement.type);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(tableRowEl, uiConfig.resultsElement.classes);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(tableRowEl, uiConfig.resultsElement.attributes);
        let editableFields = [];
        if (this.tableConfig.editableFields) {
            editableFields = this.tableConfig.editableFields;
        }
        // we need to build the row from the displayed item values using the renderer if present
        this.tableConfig.columns.forEach((column, index) => {
            // is the column editable?
            const foundIndex = editableFields.findIndex((editableField) => editableField === column.field.id);
            const isEditable = (foundIndex >= 0);
            const fieldValue = column.getValue(column, item[column.field.id]);
            const fieldDataType = column.field.type;
            let tdEl = document.createElement('td');
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(tdEl, column.elementClasses);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(tdEl, column.elementAttributes);
            if ((index + 1) === this.tableConfig.itemDetailColumn) {
                // this column is different and can have many components
                // the content may be structured
                if (uiConfig.detail.containerClasses) {
                    let contentEl = document.createElement('div');
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(contentEl, uiConfig.detail.containerClasses);
                    let textEl = document.createElement(uiConfig.detail.textElement.type);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(textEl, uiConfig.detail.textElement.classes);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(textEl, uiConfig.detail.textElement.attributes);
                    // add the key ids for selection
                    this.view.renderDisplayForItemInNamedCollection(textEl, collectionName, item);
                    contentEl.appendChild(textEl);
                    if (uiConfig.detail.background) {
                        let imgEl = document.createElement(uiConfig.detail.background.type);
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(imgEl, uiConfig.detail.background.classes);
                        imgEl.setAttribute('src', this.view.getBackgroundImageForItemInNamedCollection(collectionName, item));
                        contentEl.appendChild(imgEl);
                    }
                    if (uiConfig.detail.badge) {
                        const badgeValue = this.view.getBadgeValueForItemInNamedCollection(collectionName, item);
                        if (badgeValue > 0) {
                            let badgeEl = document.createElement(uiConfig.detail.badge.type);
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(badgeEl, uiConfig.detail.badge.classes);
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(badgeEl, uiConfig.detail.badge.attributes);
                            contentEl.appendChild(badgeEl);
                            badgeEl.innerHTML = `&nbsp;&nbsp;&nbsp;${badgeValue}&nbsp;&nbsp;&nbsp;`;
                        }
                    }
                    // add icons
                    const icons = this.view.getItemIcons(collectionName, item);
                    icons.forEach((icon) => {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, icon);
                        if (this.view.prependItemIcons(collectionName, item)) {
                            contentEl.prepend(iconEl);
                        }
                        else {
                            contentEl.append(iconEl);
                        }
                    });
                    tdEl.appendChild(contentEl);
                }
            }
            else {
                switch (fieldDataType) {
                    case _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_4__.FieldType.colour: {
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(tdEl, [{ name: "style", value: `background-color:${fieldValue}` }]);
                        tdEl.innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;';
                        break;
                    }
                    case _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_4__.FieldType.boolean: {
                        let checkboxEl = document.createElement('input');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(checkboxEl, [{ name: 'type', value: 'checkbox' }]);
                        logger(`Field type is boolean, with value ${fieldValue}`);
                        if (fieldValue) {
                            checkboxEl.checked = true;
                        }
                        tdEl.appendChild(checkboxEl);
                        if (isEditable) {
                            checkboxEl.addEventListener('change', (event) => {
                                loggerEvent(`Checkbox with field ${column.field.id} changed to value ${checkboxEl.checked}`);
                                const fieldId = column.field.id;
                                const context = _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_3__.ContextualInformationHelper.getInstance().findContextFromEvent(event);
                                if (context) {
                                    this.view.setFieldValue(context.identifier, fieldId, checkboxEl.checked);
                                }
                            });
                            checkboxEl.addEventListener('click', (event) => {
                                loggerEvent(`Checkbox with field ${column.field.id} clicked to value ${checkboxEl.checked}`);
                                const fieldId = column.field.id;
                                const context = _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_3__.ContextualInformationHelper.getInstance().findContextFromEvent(event);
                                if (context) {
                                    this.view.setFieldValue(context.identifier, fieldId, checkboxEl.checked);
                                }
                            });
                        }
                        else {
                            checkboxEl.disabled = true;
                        }
                        break;
                    }
                    case _model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_4__.FieldType.text: {
                        if (isEditable) {
                            let textEl = document.createElement('input');
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(textEl, [{ name: 'type', value: 'text' }]);
                            if (fieldValue) {
                                textEl.value = fieldValue;
                            }
                            tdEl.appendChild(textEl);
                            textEl.addEventListener('blur', (event) => {
                                loggerEvent(`Checkbox with field ${column.field.id} changed to value ${textEl.value}`);
                                const fieldId = column.field.id;
                                const context = _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_3__.ContextualInformationHelper.getInstance().findContextFromEvent(event);
                                if (context) {
                                    this.view.setFieldValue(context.identifier, fieldId, textEl.value);
                                }
                            });
                            break;
                        }
                    }
                    default: {
                        if (fieldValue) {
                            tdEl.innerText = fieldValue;
                        }
                        else {
                            tdEl.innerText = '';
                        }
                    }
                }
            }
            tableRowEl.appendChild(tdEl);
        });
        // we add an extra column for any actions or the delete function
        if (this.tableConfig.actionColumn) {
            // create the extra table column
            let tdEl = document.createElement('td');
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(tdEl, this.tableConfig.actionColumn.element.classes);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(tdEl, this.tableConfig.actionColumn.element.attributes);
            if (uiConfig.extraActions) {
                uiConfig.extraActions.forEach((extraAction) => {
                    const hasPermissionForAction = this.view.hasPermissionForActionOnItemInNamedCollection(extraAction.name, collectionName, item);
                    if (hasPermissionForAction) {
                        let action = document.createElement('button');
                        action.setAttribute('type', 'button');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(action, extraAction.button.classes);
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(action, extraAction.button.attributes);
                        if (extraAction.button.text) {
                            action.innerHTML = extraAction.button.text;
                        }
                        if (extraAction.button.iconClasses) {
                            let iconEl = document.createElement('i');
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, extraAction.button.iconClasses);
                            iconEl.setAttribute(_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.EXTRA_ACTION_ATTRIBUTE_NAME, extraAction.name);
                            action.appendChild(iconEl);
                        }
                        action.setAttribute(_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.EXTRA_ACTION_ATTRIBUTE_NAME, extraAction.name);
                        action.addEventListener('click', (event) => {
                            event.preventDefault();
                            event.stopPropagation();
                            this.eventHandler.eventActionClicked(event);
                        });
                        tdEl.appendChild(action);
                    }
                });
            }
            if (uiConfig.detail.delete && canDeleteItem) {
                let deleteButtonEl = document.createElement('button');
                deleteButtonEl.setAttribute('type', 'button');
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(deleteButtonEl, uiConfig.detail.delete.classes);
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(deleteButtonEl, uiConfig.detail.delete.attributes);
                if (uiConfig.detail.delete.text) {
                    deleteButtonEl.innerHTML = uiConfig.detail.delete.text;
                }
                if (uiConfig.detail.delete.iconClasses) {
                    let iconEl = document.createElement('i');
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, uiConfig.detail.delete.iconClasses);
                    deleteButtonEl.appendChild(iconEl);
                }
                deleteButtonEl.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    this.eventHandler.eventDeleteClickItem(event);
                });
                tdEl.appendChild(deleteButtonEl);
            }
            tableRowEl.appendChild(tdEl);
        }
        if (uiConfig.detail.drag) {
            tableRowEl.setAttribute('draggable', 'true');
            tableRowEl.addEventListener('dragstart', this.eventHandler.eventStartDrag);
        }
        // add selection actions
        if (uiConfig.detail.select) {
            tableRowEl.addEventListener('click', this.eventHandler.eventClickItem);
        }
        // add modifiers for patient state
        if (uiConfig.modifiers) {
            const modifier = this.view.getModifierForItemInNamedCollection(collectionName, item);
            const secondModifier = this.view.getSecondaryModifierForItemInNamedCollection(collectionName, item);
            switch (modifier) {
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.Modifier.normal: {
                    logger(`view ${this.view.getName()}: normal item`);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(tableRowEl, uiConfig.modifiers.normal);
                    if (uiConfig.icons && uiConfig.icons.normal) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, uiConfig.icons.normal);
                        //textEl.appendChild(iconEl);
                    }
                    switch (secondModifier) {
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.Modifier.warning: {
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].removeClasses(tableRowEl, uiConfig.modifiers.normal);
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(tableRowEl, uiConfig.modifiers.warning);
                            if (uiConfig.icons && uiConfig.icons.warning) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, uiConfig.icons.warning);
                                //textEl.appendChild(iconEl);
                            }
                            break;
                        }
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.Modifier.active: {
                            if (uiConfig.icons && uiConfig.icons.active) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, uiConfig.icons.active);
                                //textEl.appendChild(iconEl);
                            }
                        }
                    }
                    break;
                }
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.Modifier.active: {
                    logger(`view ${this.view.getName()}: active item`);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].removeClasses(tableRowEl, uiConfig.modifiers.normal);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(tableRowEl, uiConfig.modifiers.active);
                    if (uiConfig.icons && uiConfig.icons.active) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, uiConfig.icons.active);
                        //textEl.appendChild(iconEl);
                    }
                    switch (secondModifier) {
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.Modifier.warning: {
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].removeClasses(tableRowEl, uiConfig.modifiers.active);
                            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(tableRowEl, uiConfig.modifiers.warning);
                            if (uiConfig.icons && uiConfig.icons.warning) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, uiConfig.icons.warning);
                                //textEl.appendChild(iconEl);
                            }
                            break;
                        }
                    }
                    break;
                }
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.Modifier.inactive: {
                    logger(`view ${this.view.getName()}: inactive item`);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].removeClasses(tableRowEl, uiConfig.modifiers.normal);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(tableRowEl, uiConfig.modifiers.inactive);
                    if (uiConfig.icons && uiConfig.icons.inactive) {
                        let iconEl = document.createElement('i');
                        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, uiConfig.icons.inactive);
                        //textEl.appendChild(iconEl);
                    }
                    switch (secondModifier) {
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.Modifier.warning: {
                            if (uiConfig.icons && uiConfig.icons.warning) {
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].removeClasses(tableRowEl, uiConfig.modifiers.inactive);
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(tableRowEl, uiConfig.modifiers.warning);
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, uiConfig.icons.warning);
                                //textEl.appendChild(iconEl);
                            }
                            break;
                        }
                        case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.Modifier.active: {
                            if (uiConfig.icons && uiConfig.icons.active) {
                                let iconEl = document.createElement('i');
                                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(iconEl, uiConfig.icons.active);
                                //textEl.appendChild(iconEl);
                            }
                            break;
                        }
                    }
                    break;
                }
                case _ConfigurationTypes__WEBPACK_IMPORTED_MODULE_0__.Modifier.warning: {
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].removeClasses(tableRowEl, uiConfig.modifiers.normal);
                    _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(tableRowEl, uiConfig.modifiers.warning);
                    break;
                }
            }
        }
        return tableRowEl;
    }
    onDocumentLoaded() {
    }
    setDisplayElementsForCollectionInContainer(containerEl, collectionName, newState) {
        this.currentPage = 0;
        this.stateBuffer = newState;
        this.containerEl = containerEl;
        this.collectionName = collectionName;
        this.tableBodyEl = null;
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].removeAllChildren(containerEl);
        // create the table
        let tableEl = document.createElement(this.tableConfig.table.type);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(tableEl, this.tableConfig.table.classes);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(tableEl, this.tableConfig.table.attributes);
        // create the headers
        let tableHeaderEl = document.createElement(this.tableConfig.header.type);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(tableHeaderEl, this.tableConfig.header.classes);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(tableHeaderEl, this.tableConfig.header.attributes);
        // create the column headers
        this.tableConfig.headerColumns.forEach((header) => {
            let thEl = document.createElement(header.element.type);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(thEl, header.element.classes);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(thEl, header.element.attributes);
            if (header.element.innerHTML)
                thEl.innerHTML = header.element.innerHTML;
            tableHeaderEl.appendChild(thEl);
        });
        // create the action column header (if one)
        if (this.tableConfig.actionColumn) {
            let thEl = document.createElement(this.tableConfig.actionColumn.element.type);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(thEl, this.tableConfig.actionColumn.element.classes);
            _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(thEl, this.tableConfig.actionColumn.element.attributes);
            if (this.tableConfig.actionColumn.element.innerHTML)
                thEl.innerHTML = this.tableConfig.actionColumn.element.innerHTML;
            tableHeaderEl.appendChild(thEl);
        }
        tableEl.appendChild(tableHeaderEl);
        // create the table body
        this.tableBodyEl = document.createElement(this.tableConfig.body.type);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addClasses(this.tableBodyEl, this.tableConfig.body.classes);
        _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].addAttributes(this.tableBodyEl, this.tableConfig.body.attributes);
        this.setDisplayElementsForCollectionInContainerForNextPage(containerEl, collectionName, newState);
        tableEl.appendChild(this.tableBodyEl);
        containerEl.appendChild(tableEl);
    }
    setDisplayElementsForCollectionInContainerForNextPage(containerEl, collectionName, newState) {
        paginationLogger(`view ${this.view.getName()}: creating Results`);
        logger(newState);
        this.currentPage++;
        let isLazyLoading = false;
        let itemPageSize = this.stateBuffer.length;
        if (this.tableConfig && this.tableConfig.lazyLoadPageSize) {
            itemPageSize = this.tableConfig.lazyLoadPageSize;
            isLazyLoading = true;
        }
        else {
            if (itemPageSize > 50) {
                this.tableConfig.lazyLoadPageSize = 50;
                itemPageSize = 50;
                isLazyLoading = true;
            }
        }
        // remove the previous items from list
        if (this.currentPage === 1) {
            if (this.tableBodyEl)
                _util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].removeAllChildren(this.tableBodyEl);
        }
        const startItemIndex = (this.currentPage - 1) * itemPageSize;
        let endItemIndex = (this.currentPage * itemPageSize);
        if (this.stateBuffer.length < endItemIndex) {
            endItemIndex = this.stateBuffer.length;
        }
        paginationLogger(`loading items from ${startItemIndex} to ${endItemIndex}`);
        // add the new children
        let lastChildEl;
        for (let index = startItemIndex; index < endItemIndex; index++) {
            const item = this.stateBuffer[index];
            if (this.tableBodyEl)
                lastChildEl = _context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_3__.ContextualInformationHelper.getInstance().insertDisplayElementForCollectionItem(this.view, this, this.tableBodyEl, collectionName, item);
        }
        ;
        paginationLogger(`Is lazy loading? ${isLazyLoading} and current page count is ${this.currentPage} with page size ${itemPageSize}`);
        if (isLazyLoading && (this.stateBuffer.length > (this.currentPage * itemPageSize))) {
            if (lastChildEl) {
                this.currentObservedTarget = lastChildEl;
                if (this.observer === null) {
                    paginationLogger(`Creating new observer`);
                    // put an observer on the last child
                    this.observer = new IntersectionObserver(this.renderNextPage); //,{root:this.containerEl,threshold:0.0});
                }
                this.observer.observe(lastChildEl);
            }
        }
        if (!_util_BrowserUtil__WEBPACK_IMPORTED_MODULE_1__["default"].isMobileDevice())
            $('[data-toggle="tooltip"]').tooltip();
    }
    renderNextPage(entries) {
        if (entries[0].intersectionRatio <= 0)
            return;
        paginationLogger('rendering next page');
        if (this.observer && this.currentObservedTarget) {
            paginationLogger('unobserving current target');
            paginationLogger(this.currentObservedTarget);
            this.observer.unobserve(this.currentObservedTarget);
            this.currentObservedTarget = null;
        }
        if (this.containerEl && this.collectionName) {
            this.setDisplayElementsForCollectionInContainerForNextPage(this.containerEl, this.collectionName, this.stateBuffer);
        }
    }
}
//# sourceMappingURL=TabularViewRendererUsingContext.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js":
/*!**************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getElementOffset": () => (/* binding */ getElementOffset),
/* harmony export */   "BrowserUtil": () => (/* binding */ BrowserUtil),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Returns an element's position relative to the whole document (page).
 *
 * If the element does not exist, returns O/O (top-left window corner).
 *
 * @example getOffset(document.getElementById('#element'));
 *
 * @param el
 * @see https://stackoverflow.com/a/28222246/2391795
 */
const getElementOffset = (el) => {
    const rect = el === null || el === void 0 ? void 0 : el.getBoundingClientRect();
    return {
        left: ((rect === null || rect === void 0 ? void 0 : rect.left) || 0) + (window === null || window === void 0 ? void 0 : window.scrollX),
        top: ((rect === null || rect === void 0 ? void 0 : rect.top) || 0) + (window === null || window === void 0 ? void 0 : window.scrollY),
    };
};
class BrowserUtil {
    constructor() {
    }
    scrollSmoothToId(elementId) {
        const element = document.getElementById(elementId);
        if (element !== null) {
            element.scrollIntoView({
                block: 'start',
                behavior: 'smooth',
            });
        }
    }
    scrollToBottomNow(element) {
        if (element) {
            element.scrollTop = element.scrollHeight - element.clientHeight + 100;
        }
    }
    scrollToBottomSmooth(element) {
        if (element) {
            element.scrollIntoView({
                behavior: 'smooth',
            });
            element.scrollTop = element.scrollHeight - element.clientHeight + 100;
        }
    }
    scrollToElementInContainer(container, element) {
        container.scrollIntoView({
            behavior: 'smooth',
        });
        container.scrollTop = element.offsetTop;
    }
    scrollSmoothTo(element) {
        element.scrollIntoView({
            block: 'start',
            behavior: 'smooth',
            inline: 'nearest'
        });
    }
    /*
    document.getElementById("yourDivID").scrollIntoView({behavior: "smooth", block: "start", inline: "nearest"})
     */
    scrollTo(element) {
        element.scrollIntoView({
            block: 'start',
        });
    }
    removeAllChildren(element) {
        if (element && element.firstChild) {
            while (element.firstChild) {
                const lastChild = element.lastChild;
                if (lastChild)
                    element.removeChild(lastChild);
            }
        }
    }
    addRemoveClasses(element, classesText = undefined, isAdding = true) {
        if (classesText) {
            const classes = classesText.split(' ');
            classes.forEach((classValue) => {
                if (classValue.trim().length > 0) {
                    if (isAdding) {
                        element.classList.add(classValue);
                    }
                    else {
                        element.classList.remove(classValue);
                    }
                }
            });
        }
    }
    removeClasses(element, classesText = undefined) {
        this.addRemoveClasses(element, classesText, false);
    }
    addClasses(element, classesText = undefined) {
        this.addRemoveClasses(element, classesText, true);
    }
    addAttributes(element, attributes) {
        if (attributes) {
            attributes.forEach((attribute) => {
                element.setAttribute(attribute.name, attribute.value);
            });
        }
    }
    removeAttributes(element, attributes) {
        attributes.forEach((attribute) => {
            element.removeAttribute(attribute);
        });
    }
    allElementsFromPoint(x, y) {
        var element, elements = [];
        var old_visibility = [];
        while (true) {
            element = document.elementFromPoint(x, y);
            if (!element || element === document.documentElement) {
                break;
            }
            elements.push(element);
            // @ts-ignore
            old_visibility.push(element.style.visibility);
            // @ts-ignore
            element.style.visibility = 'hidden'; // Temporarily hide the element (without changing the layout)
        }
        for (var k = 0; k < elements.length; k++) {
            // @ts-ignore
            elements[k].style.visibility = old_visibility[k];
        }
        elements.reverse();
        return elements;
    }
    isMobileDevice() {
        if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
            return true;
        }
        else {
            return false;
        }
    }
}
const browserUtil = new BrowserUtil();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (browserUtil);
//# sourceMappingURL=BrowserUtil.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/util/DurationFunctions.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/util/DurationFunctions.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addDurations": () => (/* binding */ addDurations)
/* harmony export */ });
function addDurations(duration1, duration2) {
    const durationRegexp = /^(\d+:)?[0-5]?\d:[0-5]\d$/;
    // check both are valid durations
    const duration1Valid = durationRegexp.test(duration1);
    const duration2Valid = durationRegexp.test(duration2);
    if (duration1Valid && duration2Valid) {
        // split them into seconds, minutes, and hours
        const duration1Components = duration1.split(':');
        const duration2Components = duration2.split(':');
        let carry = 0;
        // add the seconds (last elements in each)
        const duration1Seconds = parseInt(duration1Components[duration1Components.length - 1]);
        const duration2Seconds = parseInt(duration2Components[duration2Components.length - 1]);
        let sumSeconds = duration1Seconds + duration2Seconds;
        if (sumSeconds >= 60) {
            carry = 1;
            sumSeconds -= 60;
        }
        const duration1Minutes = parseInt(duration1Components[duration1Components.length - 2]);
        const duration2Minutes = parseInt(duration2Components[duration2Components.length - 2]);
        let sumMinutes = duration1Minutes + duration2Minutes + carry;
        if (sumMinutes >= 60) {
            carry = 1;
            sumMinutes -= 60;
        }
        // do we have hours?
        let duration1Hours = 0;
        if (duration1Components.length == 3) {
            duration1Hours = parseInt(duration1Components[0]);
        }
        let duration2Hours = 0;
        if (duration2Components.length == 3) {
            duration2Hours = parseInt(duration2Components[0]);
        }
        let sumHours = duration1Hours + duration2Hours + carry;
        return `${(sumHours > 0) ? sumHours + ':' : ''}${(sumMinutes < 10) ? '0' + sumMinutes : sumMinutes}:${(sumSeconds < 10) ? '0' + sumSeconds : sumSeconds}`;
    }
    else {
        return '00:00';
    }
}
//# sourceMappingURL=DurationFunctions.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/util/EqualityFunctions.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/util/EqualityFunctions.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isSame": () => (/* binding */ isSame),
/* harmony export */   "isSameMongo": () => (/* binding */ isSameMongo),
/* harmony export */   "isSameUsername": () => (/* binding */ isSameUsername),
/* harmony export */   "isSameRoom": () => (/* binding */ isSameRoom)
/* harmony export */ });
function isSame(item1, item2) {
    return (item1.id === item2.id);
}
function isSameMongo(item1, item2) {
    return (item1._id === item2._id);
}
function isSameUsername(item1, item2) {
    return (item1.username === item2.username);
}
function isSameRoom(item1, item2) {
    return (item1.roomName === item2.roomName);
}
//# sourceMappingURL=EqualityFunctions.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/framework/util/MiscFunctions.js":
/*!****************************************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/framework/util/MiscFunctions.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "truncateString": () => (/* binding */ truncateString),
/* harmony export */   "convertSingleHexToNumber": () => (/* binding */ convertSingleHexToNumber),
/* harmony export */   "convertHexToNumber": () => (/* binding */ convertHexToNumber),
/* harmony export */   "isHexValueDark": () => (/* binding */ isHexValueDark),
/* harmony export */   "copyObject": () => (/* binding */ copyObject)
/* harmony export */ });
function truncateString(str, num) {
    // If the length of str is less than or equal to num
    // just return str--don't truncate it.
    if (str.length <= num) {
        return str;
    }
    // Return str truncated with '...' concatenated to the end of str.
    return str.slice(0, num) + '...';
}
function convertSingleHexToNumber(singleHexValue) {
    let value = parseInt(singleHexValue);
    if (isNaN(value)) {
        switch (singleHexValue) {
            case 'a': {
                value = 11;
                break;
            }
            case 'b': {
                value = 12;
                break;
            }
            case 'c': {
                value = 13;
                break;
            }
            case 'd': {
                value = 14;
                break;
            }
            case 'e': {
                value = 15;
                break;
            }
            case 'f': {
                value = 16;
                break;
            }
        }
    }
    return value;
}
function convertHexToNumber(hexValue) {
    let value = 0;
    let firstHexDigit = hexValue.substr(1, 1);
    let tensHexDigit = hexValue.substr(0, 1);
    value = 10 * convertSingleHexToNumber(tensHexDigit) + convertSingleHexToNumber(firstHexDigit);
    return value;
}
function isHexValueDark(hexValue) {
    let result = false;
    // we are dark if the equivalent rgb value is < 125 for each value
    hexValue = hexValue.toLowerCase();
    if (hexValue.length < 7)
        return false;
    let redHex = hexValue.substr(1, 2);
    let greenHex = hexValue.substr(3, 2);
    let blueHex = hexValue.substr(5, 2);
    let redValue = convertHexToNumber(redHex);
    let greenValue = convertHexToNumber(greenHex);
    let blueValue = convertHexToNumber(blueHex);
    if ((redValue < 125) && (greenValue < 125) && (blueValue < 125)) {
        result = true;
    }
    return result;
}
function copyObject(obj) {
    return JSON.parse(JSON.stringify(obj));
}
//# sourceMappingURL=MiscFunctions.js.map

/***/ }),

/***/ "./node_modules/ui-framework-jps/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/ui-framework-jps/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComparisonType": () => (/* reexport safe */ _framework_CommonTypes__WEBPACK_IMPORTED_MODULE_0__.ComparisonType),
/* harmony export */   "ViewMode": () => (/* reexport safe */ _framework_CommonTypes__WEBPACK_IMPORTED_MODULE_0__.ViewMode),
/* harmony export */   "UIFieldType": () => (/* reexport safe */ _framework_CommonTypes__WEBPACK_IMPORTED_MODULE_0__.UIFieldType),
/* harmony export */   "defaultGetValue": () => (/* reexport safe */ _framework_CommonTypes__WEBPACK_IMPORTED_MODULE_0__.defaultGetValue),
/* harmony export */   "DATA_ID_ATTRIBUTE": () => (/* reexport safe */ _framework_CommonTypes__WEBPACK_IMPORTED_MODULE_0__.DATA_ID_ATTRIBUTE),
/* harmony export */   "DRAGGABLE_TYPE": () => (/* reexport safe */ _framework_CommonTypes__WEBPACK_IMPORTED_MODULE_0__.DRAGGABLE_TYPE),
/* harmony export */   "DRAGGABLE_KEY_ID": () => (/* reexport safe */ _framework_CommonTypes__WEBPACK_IMPORTED_MODULE_0__.DRAGGABLE_KEY_ID),
/* harmony export */   "DRAGGABLE_FROM": () => (/* reexport safe */ _framework_CommonTypes__WEBPACK_IMPORTED_MODULE_0__.DRAGGABLE_FROM),
/* harmony export */   "ItemEventType": () => (/* reexport safe */ _framework_CommonTypes__WEBPACK_IMPORTED_MODULE_0__.ItemEventType),
/* harmony export */   "AbstractFieldOperations": () => (/* reexport safe */ _framework_model_AbstractFieldOperations__WEBPACK_IMPORTED_MODULE_1__.AbstractFieldOperations),
/* harmony export */   "DefaultDataObject": () => (/* reexport safe */ _framework_model_DefaultDataObject__WEBPACK_IMPORTED_MODULE_2__.DefaultDataObject),
/* harmony export */   "DefaultDataObjectStringifier": () => (/* reexport safe */ _framework_model_DefaultDataObjectStringifier__WEBPACK_IMPORTED_MODULE_3__.DefaultDataObjectStringifier),
/* harmony export */   "DataObjectPersistenceManager": () => (/* reexport safe */ _framework_model_DataObjectPersistenceManager__WEBPACK_IMPORTED_MODULE_4__.DataObjectPersistenceManager),
/* harmony export */   "DefinitionNotFoundError": () => (/* reexport safe */ _framework_model_DefinitionNotFoundError__WEBPACK_IMPORTED_MODULE_5__.DefinitionNotFoundError),
/* harmony export */   "InvalidValueError": () => (/* reexport safe */ _framework_model_InvalidValueError__WEBPACK_IMPORTED_MODULE_6__.InvalidValueError),
/* harmony export */   "BasicFieldOperations": () => (/* reexport safe */ _framework_model_BasicFieldOperations__WEBPACK_IMPORTED_MODULE_7__.BasicFieldOperations),
/* harmony export */   "BasicObjectDefinitionFactory": () => (/* reexport safe */ _framework_model_BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_8__.BasicObjectDefinitionFactory),
/* harmony export */   "FIELD_ModifiedOn": () => (/* reexport safe */ _framework_model_BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_8__.FIELD_ModifiedOn),
/* harmony export */   "FIELD_CreatedOn": () => (/* reexport safe */ _framework_model_BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_8__.FIELD_CreatedOn),
/* harmony export */   "FIELD_ID": () => (/* reexport safe */ _framework_model_BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_8__.FIELD_ID),
/* harmony export */   "FIELD_CreatedBy": () => (/* reexport safe */ _framework_model_BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_8__.FIELD_CreatedBy),
/* harmony export */   "FIELD_CreatedBy_Desc": () => (/* reexport safe */ _framework_model_BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_8__.FIELD_CreatedBy_Desc),
/* harmony export */   "FIELD_CreatedOn_Desc": () => (/* reexport safe */ _framework_model_BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_8__.FIELD_CreatedOn_Desc),
/* harmony export */   "FIELD_ModifiedBy": () => (/* reexport safe */ _framework_model_BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_8__.FIELD_ModifiedBy),
/* harmony export */   "FIELD_ModifiedBy_Desc": () => (/* reexport safe */ _framework_model_BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_8__.FIELD_ModifiedBy_Desc),
/* harmony export */   "FIELD_ModifiedOn_Desc": () => (/* reexport safe */ _framework_model_BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_8__.FIELD_ModifiedOn_Desc),
/* harmony export */   "DataObjectController": () => (/* reexport safe */ _framework_model_DataObjectController__WEBPACK_IMPORTED_MODULE_9__.DataObjectController),
/* harmony export */   "FieldType": () => (/* reexport safe */ _framework_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_10__.FieldType),
/* harmony export */   "ObjectDefinitionRegistry": () => (/* reexport safe */ _framework_model_ObjectDefinitionRegistry__WEBPACK_IMPORTED_MODULE_11__.ObjectDefinitionRegistry),
/* harmony export */   "ApiUtil": () => (/* reexport safe */ _framework_network_ApiUtil__WEBPACK_IMPORTED_MODULE_12__.ApiUtil),
/* harmony export */   "DownloadManager": () => (/* reexport safe */ _framework_network_DownloadManager__WEBPACK_IMPORTED_MODULE_13__.DownloadManager),
/* harmony export */   "OfflineManager": () => (/* reexport safe */ _framework_network_OfflineManager__WEBPACK_IMPORTED_MODULE_14__.OfflineManager),
/* harmony export */   "RequestType": () => (/* reexport safe */ _framework_network_Types__WEBPACK_IMPORTED_MODULE_15__.RequestType),
/* harmony export */   "queueType": () => (/* reexport safe */ _framework_network_Types__WEBPACK_IMPORTED_MODULE_15__.queueType),
/* harmony export */   "NotificationType": () => (/* reexport safe */ _framework_notification_NotificationManager__WEBPACK_IMPORTED_MODULE_16__.NotificationType),
/* harmony export */   "NotificationManager": () => (/* reexport safe */ _framework_notification_NotificationManager__WEBPACK_IMPORTED_MODULE_16__.NotificationManager),
/* harmony export */   "SecurityManager": () => (/* reexport safe */ _framework_security_SecurityManager__WEBPACK_IMPORTED_MODULE_17__.SecurityManager),
/* harmony export */   "ChatManager": () => (/* reexport safe */ _framework_socket_ChatManager__WEBPACK_IMPORTED_MODULE_18__.ChatManager),
/* harmony export */   "NotificationController": () => (/* reexport safe */ _framework_socket_NotificationController__WEBPACK_IMPORTED_MODULE_19__.NotificationController),
/* harmony export */   "DataChangeType": () => (/* reexport safe */ _framework_socket_SocketListener__WEBPACK_IMPORTED_MODULE_20__.DataChangeType),
/* harmony export */   "SocketManager": () => (/* reexport safe */ _framework_socket_SocketManager__WEBPACK_IMPORTED_MODULE_21__.SocketManager),
/* harmony export */   "Priority": () => (/* reexport safe */ _framework_socket_Types__WEBPACK_IMPORTED_MODULE_22__.Priority),
/* harmony export */   "InviteType": () => (/* reexport safe */ _framework_socket_Types__WEBPACK_IMPORTED_MODULE_22__.InviteType),
/* harmony export */   "AbstractStateManager": () => (/* reexport safe */ _framework_state_implementation_AbstractStateManager__WEBPACK_IMPORTED_MODULE_23__.AbstractStateManager),
/* harmony export */   "AggregateStateManager": () => (/* reexport safe */ _framework_state_implementation_AggregateStateManager__WEBPACK_IMPORTED_MODULE_24__.AggregateStateManager),
/* harmony export */   "AsyncStateManagerWrapper": () => (/* reexport safe */ _framework_state_helper_AsyncStateManagerWrapper__WEBPACK_IMPORTED_MODULE_25__.AsyncStateManagerWrapper),
/* harmony export */   "BrowserStorageStateManager": () => (/* reexport safe */ _framework_state_implementation_BrowserStorageStateManager__WEBPACK_IMPORTED_MODULE_26__.BrowserStorageStateManager),
/* harmony export */   "EncryptedBrowserStorageStateManager": () => (/* reexport safe */ _framework_state_implementation_EncryptedBrowserStorageStateManager__WEBPACK_IMPORTED_MODULE_27__.EncryptedBrowserStorageStateManager),
/* harmony export */   "EncryptedIndexedDBStateManager": () => (/* reexport safe */ _framework_state_implementation_EncryptedIndexedDBStateManager__WEBPACK_IMPORTED_MODULE_28__.EncryptedIndexedDBStateManager),
/* harmony export */   "GraphQLApiStateManager": () => (/* reexport safe */ _framework_state_implementation_GraphQLApiStateManager__WEBPACK_IMPORTED_MODULE_29__.GraphQLApiStateManager),
/* harmony export */   "IndexedDBStateManager": () => (/* reexport safe */ _framework_state_implementation_IndexedDBStateManager__WEBPACK_IMPORTED_MODULE_30__.IndexedDBStateManager),
/* harmony export */   "PersistentLocalCache": () => (/* reexport safe */ _framework_state_helper_PersistentLocalCache__WEBPACK_IMPORTED_MODULE_31__.PersistentLocalCache),
/* harmony export */   "RESTApiStateManager": () => (/* reexport safe */ _framework_state_implementation_RESTApiStateManager__WEBPACK_IMPORTED_MODULE_32__.RESTApiStateManager),
/* harmony export */   "MemoryBufferStateManager": () => (/* reexport safe */ _framework_state_implementation_MemoryBufferStateManager__WEBPACK_IMPORTED_MODULE_33__.MemoryBufferStateManager),
/* harmony export */   "StateManagerType": () => (/* reexport safe */ _framework_state_interface_StateManager__WEBPACK_IMPORTED_MODULE_34__.StateManagerType),
/* harmony export */   "StateContextDelegate": () => (/* reexport safe */ _framework_state_delegate_StateContextDelegate__WEBPACK_IMPORTED_MODULE_35__.StateContextDelegate),
/* harmony export */   "DefaultStateContextSupplier": () => (/* reexport safe */ _framework_state_helper_DefaultStateContextSupplier__WEBPACK_IMPORTED_MODULE_36__.DefaultStateContextSupplier),
/* harmony export */   "StateTimingManager": () => (/* reexport safe */ _framework_state_helper_StateTimingManager__WEBPACK_IMPORTED_MODULE_37__.StateTimingManager),
/* harmony export */   "jsxCreateFragment": () => (/* reexport safe */ _framework_jsx_JSXParser__WEBPACK_IMPORTED_MODULE_38__.jsxCreateFragment),
/* harmony export */   "jsxCreateElement": () => (/* reexport safe */ _framework_jsx_JSXParser__WEBPACK_IMPORTED_MODULE_38__.jsxCreateElement),
/* harmony export */   "Modifier": () => (/* reexport safe */ _framework_ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_39__.Modifier),
/* harmony export */   "KeyType": () => (/* reexport safe */ _framework_ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_39__.KeyType),
/* harmony export */   "SidebarLocation": () => (/* reexport safe */ _framework_ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_39__.SidebarLocation),
/* harmony export */   "RowPosition": () => (/* reexport safe */ _framework_ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_39__.RowPosition),
/* harmony export */   "ActionType": () => (/* reexport safe */ _framework_ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_39__.ActionType),
/* harmony export */   "SCREEN_WIDTH_LARGE": () => (/* reexport safe */ _framework_ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_39__.SCREEN_WIDTH_LARGE),
/* harmony export */   "SCREEN_WIDTH_SMALL": () => (/* reexport safe */ _framework_ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_39__.SCREEN_WIDTH_SMALL),
/* harmony export */   "SCREEN_WIDTH_MEDIUM": () => (/* reexport safe */ _framework_ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_39__.SCREEN_WIDTH_MEDIUM),
/* harmony export */   "ElementLocation": () => (/* reexport safe */ _framework_ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_39__.ElementLocation),
/* harmony export */   "CollectionViewSorterDirection": () => (/* reexport safe */ _framework_ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_39__.CollectionViewSorterDirection),
/* harmony export */   "MatchLogicType": () => (/* reexport safe */ _framework_ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_39__.MatchLogicType),
/* harmony export */   "AlertType": () => (/* reexport safe */ _framework_ui_alert_AlertListener__WEBPACK_IMPORTED_MODULE_40__.AlertType),
/* harmony export */   "AlertManager": () => (/* reexport safe */ _framework_ui_alert_AlertManager__WEBPACK_IMPORTED_MODULE_41__.AlertManager),
/* harmony export */   "FileUploadType": () => (/* reexport safe */ _framework_ui_file_upload_FileUploadListener__WEBPACK_IMPORTED_MODULE_42__.FileUploadType),
/* harmony export */   "FileUploadManager": () => (/* reexport safe */ _framework_ui_file_upload_FileUploadManager__WEBPACK_IMPORTED_MODULE_43__.FileUploadManager),
/* harmony export */   "CollectionUIConfigController": () => (/* reexport safe */ _framework_ui_config_CollectionUIConfigController__WEBPACK_IMPORTED_MODULE_44__.CollectionUIConfigController),
/* harmony export */   "BlockedUserView": () => (/* reexport safe */ _framework_ui_chat_BlockedUserView__WEBPACK_IMPORTED_MODULE_45__.BlockedUserView),
/* harmony export */   "ChatLogDetailView": () => (/* reexport safe */ _framework_ui_chat_ChatLogDetailView__WEBPACK_IMPORTED_MODULE_46__.ChatLogDetailView),
/* harmony export */   "ChatLogsView": () => (/* reexport safe */ _framework_ui_chat_ChatLogsView__WEBPACK_IMPORTED_MODULE_47__.ChatLogsView),
/* harmony export */   "ChatRoomsSidebar": () => (/* reexport safe */ _framework_ui_chat_ChatRoomsSidebar__WEBPACK_IMPORTED_MODULE_48__.ChatRoomsSidebar),
/* harmony export */   "STATE_NAMES": () => (/* reexport safe */ _framework_ui_chat_ChatTypes__WEBPACK_IMPORTED_MODULE_49__.STATE_NAMES),
/* harmony export */   "DRAGGABLE": () => (/* reexport safe */ _framework_ui_chat_ChatTypes__WEBPACK_IMPORTED_MODULE_49__.DRAGGABLE),
/* harmony export */   "VIEW_NAME": () => (/* reexport safe */ _framework_ui_chat_ChatTypes__WEBPACK_IMPORTED_MODULE_49__.VIEW_NAME),
/* harmony export */   "FavouriteUserView": () => (/* reexport safe */ _framework_ui_chat_FavouriteUserView__WEBPACK_IMPORTED_MODULE_50__.FavouriteUserView),
/* harmony export */   "UserSearchSidebar": () => (/* reexport safe */ _framework_ui_chat_UserSearchSidebar__WEBPACK_IMPORTED_MODULE_51__.UserSearchSidebar),
/* harmony export */   "UserSearchView": () => (/* reexport safe */ _framework_ui_chat_UserSearchView__WEBPACK_IMPORTED_MODULE_52__.UserSearchView),
/* harmony export */   "SidebarViewContainer": () => (/* reexport safe */ _framework_ui_container_SidebarViewContainer__WEBPACK_IMPORTED_MODULE_53__.SidebarViewContainer),
/* harmony export */   "TabularViewContainer": () => (/* reexport safe */ _framework_ui_container_TabularViewContainer__WEBPACK_IMPORTED_MODULE_54__.TabularViewContainer),
/* harmony export */   "ContextualInformationHelper": () => (/* reexport safe */ _framework_ui_context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_55__.ContextualInformationHelper),
/* harmony export */   "ItemViewElementFactory": () => (/* reexport safe */ _framework_ui_factory_ItemViewElementFactory__WEBPACK_IMPORTED_MODULE_56__.ItemViewElementFactory),
/* harmony export */   "BasicFormImplementation": () => (/* reexport safe */ _framework_ui_form_BasicFormImplementation__WEBPACK_IMPORTED_MODULE_57__.BasicFormImplementation),
/* harmony export */   "AbstractField": () => (/* reexport safe */ _framework_ui_field_AbstractField__WEBPACK_IMPORTED_MODULE_58__.AbstractField),
/* harmony export */   "InputField": () => (/* reexport safe */ _framework_ui_field_InputField__WEBPACK_IMPORTED_MODULE_59__.InputField),
/* harmony export */   "TextAreaField": () => (/* reexport safe */ _framework_ui_field_TextAreaField__WEBPACK_IMPORTED_MODULE_60__.TextAreaField),
/* harmony export */   "SelectField": () => (/* reexport safe */ _framework_ui_field_SelectField__WEBPACK_IMPORTED_MODULE_61__.SelectField),
/* harmony export */   "RadioButtonGroupField": () => (/* reexport safe */ _framework_ui_field_RadioButtonGroupField__WEBPACK_IMPORTED_MODULE_62__.RadioButtonGroupField),
/* harmony export */   "ColourInputField": () => (/* reexport safe */ _framework_ui_field_ColourInputField__WEBPACK_IMPORTED_MODULE_63__.ColourInputField),
/* harmony export */   "ConditionResponse": () => (/* reexport safe */ _framework_ui_validation_ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_64__.ConditionResponse),
/* harmony export */   "MultipleConditionLogic": () => (/* reexport safe */ _framework_ui_validation_ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_64__.MultipleConditionLogic),
/* harmony export */   "ValidationManager": () => (/* reexport safe */ _framework_ui_validation_ValidationManager__WEBPACK_IMPORTED_MODULE_65__.ValidationManager),
/* harmony export */   "ValidationHelperFunctions": () => (/* reexport safe */ _framework_ui_validation_ValidationHelperFunctions__WEBPACK_IMPORTED_MODULE_66__.ValidationHelperFunctions),
/* harmony export */   "BootstrapFormConfigHelper": () => (/* reexport safe */ _framework_ui_helper_BootstrapFormConfigHelper__WEBPACK_IMPORTED_MODULE_67__.BootstrapFormConfigHelper),
/* harmony export */   "FormConfigHelperFunctions": () => (/* reexport safe */ _framework_ui_helper_FormConfigHelperFunctions__WEBPACK_IMPORTED_MODULE_68__.FormConfigHelperFunctions),
/* harmony export */   "BootstrapTableConfigHelper": () => (/* reexport safe */ _framework_ui_helper_BootstrapTableConfigHelper__WEBPACK_IMPORTED_MODULE_69__.BootstrapTableConfigHelper),
/* harmony export */   "LimitedChoiceTextRenderer": () => (/* reexport safe */ _framework_ui_helper_LimitedChoiceTextRenderer__WEBPACK_IMPORTED_MODULE_70__.LimitedChoiceTextRenderer),
/* harmony export */   "LinkedCollectionDetailController": () => (/* reexport safe */ _framework_ui_helper_LinkedCollectionDetailController__WEBPACK_IMPORTED_MODULE_71__.LinkedCollectionDetailController),
/* harmony export */   "RBGFieldOperations": () => (/* reexport safe */ _framework_ui_helper_RBGFieldOperations__WEBPACK_IMPORTED_MODULE_72__.RBGFieldOperations),
/* harmony export */   "SimpleValueDataSource": () => (/* reexport safe */ _framework_ui_helper_SimpleValueDataSource__WEBPACK_IMPORTED_MODULE_73__.SimpleValueDataSource),
/* harmony export */   "ColourEditor": () => (/* reexport safe */ _framework_ui_helper_ColourEditor__WEBPACK_IMPORTED_MODULE_74__.ColourEditor),
/* harmony export */   "CollectionViewFilterHelper": () => (/* reexport safe */ _framework_ui_helper_CollectionViewFilterHelper__WEBPACK_IMPORTED_MODULE_75__.CollectionViewFilterHelper),
/* harmony export */   "DefaultItemView": () => (/* reexport safe */ _framework_ui_view_item_DefaultItemView__WEBPACK_IMPORTED_MODULE_76__.DefaultItemView),
/* harmony export */   "DefaultFieldPermissionChecker": () => (/* reexport safe */ _framework_ui_view_item_DefaultFieldPermissionChecker__WEBPACK_IMPORTED_MODULE_77__.DefaultFieldPermissionChecker),
/* harmony export */   "AbstractView": () => (/* reexport safe */ _framework_ui_view_implementation_AbstractView__WEBPACK_IMPORTED_MODULE_78__.AbstractView),
/* harmony export */   "AbstractCollectionView": () => (/* reexport safe */ _framework_ui_view_implementation_AbstractCollectionView__WEBPACK_IMPORTED_MODULE_79__.AbstractCollectionView),
/* harmony export */   "AbstractStatefulCollectionView": () => (/* reexport safe */ _framework_ui_view_implementation_AbstractStatefulCollectionView__WEBPACK_IMPORTED_MODULE_80__.AbstractStatefulCollectionView),
/* harmony export */   "DataObjectCollectionView": () => (/* reexport safe */ _framework_ui_view_implementation_DataObjectCollectionView__WEBPACK_IMPORTED_MODULE_81__.DataObjectCollectionView),
/* harmony export */   "DefaultPermissionChecker": () => (/* reexport safe */ _framework_ui_view_implementation_DefaultPermissionChecker__WEBPACK_IMPORTED_MODULE_82__.DefaultPermissionChecker),
/* harmony export */   "DetailViewImplementation": () => (/* reexport safe */ _framework_ui_view_implementation_DetailViewImplementation__WEBPACK_IMPORTED_MODULE_83__.DetailViewImplementation),
/* harmony export */   "CarouselViewRenderer": () => (/* reexport safe */ _framework_ui_view_renderer_CarouselViewRenderer__WEBPACK_IMPORTED_MODULE_84__.CarouselViewRenderer),
/* harmony export */   "CarouselViewRendererUsingContext": () => (/* reexport safe */ _framework_ui_view_renderer_CarouselViewRendererUsingContext__WEBPACK_IMPORTED_MODULE_85__.CarouselViewRendererUsingContext),
/* harmony export */   "FormDetailViewRenderer": () => (/* reexport safe */ _framework_ui_view_renderer_FormDetailViewRenderer__WEBPACK_IMPORTED_MODULE_86__.FormDetailViewRenderer),
/* harmony export */   "ListViewRenderer": () => (/* reexport safe */ _framework_ui_view_renderer_ListViewRenderer__WEBPACK_IMPORTED_MODULE_87__.ListViewRenderer),
/* harmony export */   "ListViewRendererUsingContext": () => (/* reexport safe */ _framework_ui_view_renderer_ListViewRendererUsingContext__WEBPACK_IMPORTED_MODULE_88__.ListViewRendererUsingContext),
/* harmony export */   "TabularViewRendererUsingContext": () => (/* reexport safe */ _framework_ui_view_renderer_TabularViewRendererUsingContext__WEBPACK_IMPORTED_MODULE_89__.TabularViewRendererUsingContext),
/* harmony export */   "ViewListenerForwarder": () => (/* reexport safe */ _framework_ui_view_delegate_ViewListenerForwarder__WEBPACK_IMPORTED_MODULE_90__.ViewListenerForwarder),
/* harmony export */   "DetailViewListenerForwarder": () => (/* reexport safe */ _framework_ui_view_delegate_DetailViewListenerForwarder__WEBPACK_IMPORTED_MODULE_91__.DetailViewListenerForwarder),
/* harmony export */   "CollectionViewListenerForwarder": () => (/* reexport safe */ _framework_ui_view_delegate_CollectionViewListenerForwarder__WEBPACK_IMPORTED_MODULE_92__.CollectionViewListenerForwarder),
/* harmony export */   "CollectionViewEventHandlerDelegate": () => (/* reexport safe */ _framework_ui_view_delegate_CollectionViewEventHandlerDelegate__WEBPACK_IMPORTED_MODULE_93__.CollectionViewEventHandlerDelegate),
/* harmony export */   "CollectionViewEventHandlerDelegateUsingContext": () => (/* reexport safe */ _framework_ui_view_delegate_CollectionViewEventHandlerDelegateUsingContext__WEBPACK_IMPORTED_MODULE_94__.CollectionViewEventHandlerDelegateUsingContext),
/* harmony export */   "truncateString": () => (/* reexport safe */ _framework_util_MiscFunctions__WEBPACK_IMPORTED_MODULE_95__.truncateString),
/* harmony export */   "convertHexToNumber": () => (/* reexport safe */ _framework_util_MiscFunctions__WEBPACK_IMPORTED_MODULE_95__.convertHexToNumber),
/* harmony export */   "convertSingleHexToNumber": () => (/* reexport safe */ _framework_util_MiscFunctions__WEBPACK_IMPORTED_MODULE_95__.convertSingleHexToNumber),
/* harmony export */   "isHexValueDark": () => (/* reexport safe */ _framework_util_MiscFunctions__WEBPACK_IMPORTED_MODULE_95__.isHexValueDark),
/* harmony export */   "copyObject": () => (/* reexport safe */ _framework_util_MiscFunctions__WEBPACK_IMPORTED_MODULE_95__.copyObject),
/* harmony export */   "isSameMongo": () => (/* reexport safe */ _framework_util_EqualityFunctions__WEBPACK_IMPORTED_MODULE_96__.isSameMongo),
/* harmony export */   "isSame": () => (/* reexport safe */ _framework_util_EqualityFunctions__WEBPACK_IMPORTED_MODULE_96__.isSame),
/* harmony export */   "isSameUsername": () => (/* reexport safe */ _framework_util_EqualityFunctions__WEBPACK_IMPORTED_MODULE_96__.isSameUsername),
/* harmony export */   "isSameRoom": () => (/* reexport safe */ _framework_util_EqualityFunctions__WEBPACK_IMPORTED_MODULE_96__.isSameRoom),
/* harmony export */   "addDurations": () => (/* reexport safe */ _framework_util_DurationFunctions__WEBPACK_IMPORTED_MODULE_97__.addDurations),
/* harmony export */   "BrowserUtil": () => (/* reexport safe */ _framework_util_BrowserUtil__WEBPACK_IMPORTED_MODULE_98__.BrowserUtil),
/* harmony export */   "getElementOffset": () => (/* reexport safe */ _framework_util_BrowserUtil__WEBPACK_IMPORTED_MODULE_98__.getElementOffset),
/* harmony export */   "BasicTableRowImplementation": () => (/* reexport safe */ _framework_ui_table_BasicTableRowImplementation__WEBPACK_IMPORTED_MODULE_99__.BasicTableRowImplementation),
/* harmony export */   "KeyBindingManager": () => (/* reexport safe */ _framework_ui_key_binding_manager_KeyBindingManager__WEBPACK_IMPORTED_MODULE_100__.KeyBindingManager)
/* harmony export */ });
/* harmony import */ var _framework_CommonTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./framework/CommonTypes */ "./node_modules/ui-framework-jps/dist/framework/CommonTypes.js");
/* harmony import */ var _framework_model_AbstractFieldOperations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./framework/model/AbstractFieldOperations */ "./node_modules/ui-framework-jps/dist/framework/model/AbstractFieldOperations.js");
/* harmony import */ var _framework_model_DefaultDataObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./framework/model/DefaultDataObject */ "./node_modules/ui-framework-jps/dist/framework/model/DefaultDataObject.js");
/* harmony import */ var _framework_model_DefaultDataObjectStringifier__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./framework/model/DefaultDataObjectStringifier */ "./node_modules/ui-framework-jps/dist/framework/model/DefaultDataObjectStringifier.js");
/* harmony import */ var _framework_model_DataObjectPersistenceManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./framework/model/DataObjectPersistenceManager */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectPersistenceManager.js");
/* harmony import */ var _framework_model_DefinitionNotFoundError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./framework/model/DefinitionNotFoundError */ "./node_modules/ui-framework-jps/dist/framework/model/DefinitionNotFoundError.js");
/* harmony import */ var _framework_model_InvalidValueError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./framework/model/InvalidValueError */ "./node_modules/ui-framework-jps/dist/framework/model/InvalidValueError.js");
/* harmony import */ var _framework_model_BasicFieldOperations__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./framework/model/BasicFieldOperations */ "./node_modules/ui-framework-jps/dist/framework/model/BasicFieldOperations.js");
/* harmony import */ var _framework_model_BasicObjectDefinitionFactory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./framework/model/BasicObjectDefinitionFactory */ "./node_modules/ui-framework-jps/dist/framework/model/BasicObjectDefinitionFactory.js");
/* harmony import */ var _framework_model_DataObjectController__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./framework/model/DataObjectController */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectController.js");
/* harmony import */ var _framework_model_DataObjectTypeDefs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./framework/model/DataObjectTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/model/DataObjectTypeDefs.js");
/* harmony import */ var _framework_model_ObjectDefinitionRegistry__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./framework/model/ObjectDefinitionRegistry */ "./node_modules/ui-framework-jps/dist/framework/model/ObjectDefinitionRegistry.js");
/* harmony import */ var _framework_network_ApiUtil__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./framework/network/ApiUtil */ "./node_modules/ui-framework-jps/dist/framework/network/ApiUtil.js");
/* harmony import */ var _framework_network_DownloadManager__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./framework/network/DownloadManager */ "./node_modules/ui-framework-jps/dist/framework/network/DownloadManager.js");
/* harmony import */ var _framework_network_OfflineManager__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./framework/network/OfflineManager */ "./node_modules/ui-framework-jps/dist/framework/network/OfflineManager.js");
/* harmony import */ var _framework_network_Types__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./framework/network/Types */ "./node_modules/ui-framework-jps/dist/framework/network/Types.js");
/* harmony import */ var _framework_notification_NotificationManager__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./framework/notification/NotificationManager */ "./node_modules/ui-framework-jps/dist/framework/notification/NotificationManager.js");
/* harmony import */ var _framework_security_SecurityManager__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./framework/security/SecurityManager */ "./node_modules/ui-framework-jps/dist/framework/security/SecurityManager.js");
/* harmony import */ var _framework_socket_ChatManager__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./framework/socket/ChatManager */ "./node_modules/ui-framework-jps/dist/framework/socket/ChatManager.js");
/* harmony import */ var _framework_socket_NotificationController__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./framework/socket/NotificationController */ "./node_modules/ui-framework-jps/dist/framework/socket/NotificationController.js");
/* harmony import */ var _framework_socket_SocketListener__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./framework/socket/SocketListener */ "./node_modules/ui-framework-jps/dist/framework/socket/SocketListener.js");
/* harmony import */ var _framework_socket_SocketManager__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./framework/socket/SocketManager */ "./node_modules/ui-framework-jps/dist/framework/socket/SocketManager.js");
/* harmony import */ var _framework_socket_Types__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./framework/socket/Types */ "./node_modules/ui-framework-jps/dist/framework/socket/Types.js");
/* harmony import */ var _framework_state_implementation_AbstractStateManager__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./framework/state/implementation/AbstractStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/AbstractStateManager.js");
/* harmony import */ var _framework_state_implementation_AggregateStateManager__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./framework/state/implementation/AggregateStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/AggregateStateManager.js");
/* harmony import */ var _framework_state_helper_AsyncStateManagerWrapper__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./framework/state/helper/AsyncStateManagerWrapper */ "./node_modules/ui-framework-jps/dist/framework/state/helper/AsyncStateManagerWrapper.js");
/* harmony import */ var _framework_state_implementation_BrowserStorageStateManager__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./framework/state/implementation/BrowserStorageStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/BrowserStorageStateManager.js");
/* harmony import */ var _framework_state_implementation_EncryptedBrowserStorageStateManager__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./framework/state/implementation/EncryptedBrowserStorageStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/EncryptedBrowserStorageStateManager.js");
/* harmony import */ var _framework_state_implementation_EncryptedIndexedDBStateManager__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./framework/state/implementation/EncryptedIndexedDBStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/EncryptedIndexedDBStateManager.js");
/* harmony import */ var _framework_state_implementation_GraphQLApiStateManager__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./framework/state/implementation/GraphQLApiStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/GraphQLApiStateManager.js");
/* harmony import */ var _framework_state_implementation_IndexedDBStateManager__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./framework/state/implementation/IndexedDBStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/IndexedDBStateManager.js");
/* harmony import */ var _framework_state_helper_PersistentLocalCache__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./framework/state/helper/PersistentLocalCache */ "./node_modules/ui-framework-jps/dist/framework/state/helper/PersistentLocalCache.js");
/* harmony import */ var _framework_state_implementation_RESTApiStateManager__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./framework/state/implementation/RESTApiStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/RESTApiStateManager.js");
/* harmony import */ var _framework_state_implementation_MemoryBufferStateManager__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./framework/state/implementation/MemoryBufferStateManager */ "./node_modules/ui-framework-jps/dist/framework/state/implementation/MemoryBufferStateManager.js");
/* harmony import */ var _framework_state_interface_StateManager__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./framework/state/interface/StateManager */ "./node_modules/ui-framework-jps/dist/framework/state/interface/StateManager.js");
/* harmony import */ var _framework_state_delegate_StateContextDelegate__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./framework/state/delegate/StateContextDelegate */ "./node_modules/ui-framework-jps/dist/framework/state/delegate/StateContextDelegate.js");
/* harmony import */ var _framework_state_helper_DefaultStateContextSupplier__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./framework/state/helper/DefaultStateContextSupplier */ "./node_modules/ui-framework-jps/dist/framework/state/helper/DefaultStateContextSupplier.js");
/* harmony import */ var _framework_state_helper_StateTimingManager__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./framework/state/helper/StateTimingManager */ "./node_modules/ui-framework-jps/dist/framework/state/helper/StateTimingManager.js");
/* harmony import */ var _framework_jsx_JSXParser__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./framework/jsx/JSXParser */ "./node_modules/ui-framework-jps/dist/framework/jsx/JSXParser.js");
/* harmony import */ var _framework_ui_ConfigurationTypes__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./framework/ui/ConfigurationTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/ConfigurationTypes.js");
/* harmony import */ var _framework_ui_alert_AlertListener__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./framework/ui/alert/AlertListener */ "./node_modules/ui-framework-jps/dist/framework/ui/alert/AlertListener.js");
/* harmony import */ var _framework_ui_alert_AlertManager__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./framework/ui/alert/AlertManager */ "./node_modules/ui-framework-jps/dist/framework/ui/alert/AlertManager.js");
/* harmony import */ var _framework_ui_file_upload_FileUploadListener__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./framework/ui/file-upload/FileUploadListener */ "./node_modules/ui-framework-jps/dist/framework/ui/file-upload/FileUploadListener.js");
/* harmony import */ var _framework_ui_file_upload_FileUploadManager__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./framework/ui/file-upload/FileUploadManager */ "./node_modules/ui-framework-jps/dist/framework/ui/file-upload/FileUploadManager.js");
/* harmony import */ var _framework_ui_config_CollectionUIConfigController__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./framework/ui/config/CollectionUIConfigController */ "./node_modules/ui-framework-jps/dist/framework/ui/config/CollectionUIConfigController.js");
/* harmony import */ var _framework_ui_chat_BlockedUserView__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./framework/ui/chat/BlockedUserView */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/BlockedUserView.js");
/* harmony import */ var _framework_ui_chat_ChatLogDetailView__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./framework/ui/chat/ChatLogDetailView */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatLogDetailView.js");
/* harmony import */ var _framework_ui_chat_ChatLogsView__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./framework/ui/chat/ChatLogsView */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatLogsView.js");
/* harmony import */ var _framework_ui_chat_ChatRoomsSidebar__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./framework/ui/chat/ChatRoomsSidebar */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatRoomsSidebar.js");
/* harmony import */ var _framework_ui_chat_ChatTypes__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./framework/ui/chat/ChatTypes */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/ChatTypes.js");
/* harmony import */ var _framework_ui_chat_FavouriteUserView__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./framework/ui/chat/FavouriteUserView */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/FavouriteUserView.js");
/* harmony import */ var _framework_ui_chat_UserSearchSidebar__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./framework/ui/chat/UserSearchSidebar */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/UserSearchSidebar.js");
/* harmony import */ var _framework_ui_chat_UserSearchView__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./framework/ui/chat/UserSearchView */ "./node_modules/ui-framework-jps/dist/framework/ui/chat/UserSearchView.js");
/* harmony import */ var _framework_ui_container_SidebarViewContainer__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./framework/ui/container/SidebarViewContainer */ "./node_modules/ui-framework-jps/dist/framework/ui/container/SidebarViewContainer.js");
/* harmony import */ var _framework_ui_container_TabularViewContainer__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./framework/ui/container/TabularViewContainer */ "./node_modules/ui-framework-jps/dist/framework/ui/container/TabularViewContainer.js");
/* harmony import */ var _framework_ui_context_ContextualInformationHelper__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./framework/ui/context/ContextualInformationHelper */ "./node_modules/ui-framework-jps/dist/framework/ui/context/ContextualInformationHelper.js");
/* harmony import */ var _framework_ui_factory_ItemViewElementFactory__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./framework/ui/factory/ItemViewElementFactory */ "./node_modules/ui-framework-jps/dist/framework/ui/factory/ItemViewElementFactory.js");
/* harmony import */ var _framework_ui_form_BasicFormImplementation__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./framework/ui/form/BasicFormImplementation */ "./node_modules/ui-framework-jps/dist/framework/ui/form/BasicFormImplementation.js");
/* harmony import */ var _framework_ui_field_AbstractField__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./framework/ui/field/AbstractField */ "./node_modules/ui-framework-jps/dist/framework/ui/field/AbstractField.js");
/* harmony import */ var _framework_ui_field_InputField__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./framework/ui/field/InputField */ "./node_modules/ui-framework-jps/dist/framework/ui/field/InputField.js");
/* harmony import */ var _framework_ui_field_TextAreaField__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./framework/ui/field/TextAreaField */ "./node_modules/ui-framework-jps/dist/framework/ui/field/TextAreaField.js");
/* harmony import */ var _framework_ui_field_SelectField__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./framework/ui/field/SelectField */ "./node_modules/ui-framework-jps/dist/framework/ui/field/SelectField.js");
/* harmony import */ var _framework_ui_field_RadioButtonGroupField__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./framework/ui/field/RadioButtonGroupField */ "./node_modules/ui-framework-jps/dist/framework/ui/field/RadioButtonGroupField.js");
/* harmony import */ var _framework_ui_field_ColourInputField__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./framework/ui/field/ColourInputField */ "./node_modules/ui-framework-jps/dist/framework/ui/field/ColourInputField.js");
/* harmony import */ var _framework_ui_validation_ValidationTypeDefs__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./framework/ui/validation/ValidationTypeDefs */ "./node_modules/ui-framework-jps/dist/framework/ui/validation/ValidationTypeDefs.js");
/* harmony import */ var _framework_ui_validation_ValidationManager__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./framework/ui/validation/ValidationManager */ "./node_modules/ui-framework-jps/dist/framework/ui/validation/ValidationManager.js");
/* harmony import */ var _framework_ui_validation_ValidationHelperFunctions__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./framework/ui/validation/ValidationHelperFunctions */ "./node_modules/ui-framework-jps/dist/framework/ui/validation/ValidationHelperFunctions.js");
/* harmony import */ var _framework_ui_helper_BootstrapFormConfigHelper__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./framework/ui/helper/BootstrapFormConfigHelper */ "./node_modules/ui-framework-jps/dist/framework/ui/helper/BootstrapFormConfigHelper.js");
/* harmony import */ var _framework_ui_helper_FormConfigHelperFunctions__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./framework/ui/helper/FormConfigHelperFunctions */ "./node_modules/ui-framework-jps/dist/framework/ui/helper/FormConfigHelperFunctions.js");
/* harmony import */ var _framework_ui_helper_BootstrapTableConfigHelper__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./framework/ui/helper/BootstrapTableConfigHelper */ "./node_modules/ui-framework-jps/dist/framework/ui/helper/BootstrapTableConfigHelper.js");
/* harmony import */ var _framework_ui_helper_LimitedChoiceTextRenderer__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./framework/ui/helper/LimitedChoiceTextRenderer */ "./node_modules/ui-framework-jps/dist/framework/ui/helper/LimitedChoiceTextRenderer.js");
/* harmony import */ var _framework_ui_helper_LinkedCollectionDetailController__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./framework/ui/helper/LinkedCollectionDetailController */ "./node_modules/ui-framework-jps/dist/framework/ui/helper/LinkedCollectionDetailController.js");
/* harmony import */ var _framework_ui_helper_RBGFieldOperations__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./framework/ui/helper/RBGFieldOperations */ "./node_modules/ui-framework-jps/dist/framework/ui/helper/RBGFieldOperations.js");
/* harmony import */ var _framework_ui_helper_SimpleValueDataSource__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./framework/ui/helper/SimpleValueDataSource */ "./node_modules/ui-framework-jps/dist/framework/ui/helper/SimpleValueDataSource.js");
/* harmony import */ var _framework_ui_helper_ColourEditor__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./framework/ui/helper/ColourEditor */ "./node_modules/ui-framework-jps/dist/framework/ui/helper/ColourEditor.js");
/* harmony import */ var _framework_ui_helper_CollectionViewFilterHelper__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./framework/ui/helper/CollectionViewFilterHelper */ "./node_modules/ui-framework-jps/dist/framework/ui/helper/CollectionViewFilterHelper.js");
/* harmony import */ var _framework_ui_view_item_DefaultItemView__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./framework/ui/view/item/DefaultItemView */ "./node_modules/ui-framework-jps/dist/framework/ui/view/item/DefaultItemView.js");
/* harmony import */ var _framework_ui_view_item_DefaultFieldPermissionChecker__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./framework/ui/view/item/DefaultFieldPermissionChecker */ "./node_modules/ui-framework-jps/dist/framework/ui/view/item/DefaultFieldPermissionChecker.js");
/* harmony import */ var _framework_ui_view_implementation_AbstractView__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./framework/ui/view/implementation/AbstractView */ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractView.js");
/* harmony import */ var _framework_ui_view_implementation_AbstractCollectionView__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./framework/ui/view/implementation/AbstractCollectionView */ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractCollectionView.js");
/* harmony import */ var _framework_ui_view_implementation_AbstractStatefulCollectionView__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./framework/ui/view/implementation/AbstractStatefulCollectionView */ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/AbstractStatefulCollectionView.js");
/* harmony import */ var _framework_ui_view_implementation_DataObjectCollectionView__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./framework/ui/view/implementation/DataObjectCollectionView */ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/DataObjectCollectionView.js");
/* harmony import */ var _framework_ui_view_implementation_DefaultPermissionChecker__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./framework/ui/view/implementation/DefaultPermissionChecker */ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/DefaultPermissionChecker.js");
/* harmony import */ var _framework_ui_view_implementation_DetailViewImplementation__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./framework/ui/view/implementation/DetailViewImplementation */ "./node_modules/ui-framework-jps/dist/framework/ui/view/implementation/DetailViewImplementation.js");
/* harmony import */ var _framework_ui_view_renderer_CarouselViewRenderer__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./framework/ui/view/renderer/CarouselViewRenderer */ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/CarouselViewRenderer.js");
/* harmony import */ var _framework_ui_view_renderer_CarouselViewRendererUsingContext__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./framework/ui/view/renderer/CarouselViewRendererUsingContext */ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/CarouselViewRendererUsingContext.js");
/* harmony import */ var _framework_ui_view_renderer_FormDetailViewRenderer__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./framework/ui/view/renderer/FormDetailViewRenderer */ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/FormDetailViewRenderer.js");
/* harmony import */ var _framework_ui_view_renderer_ListViewRenderer__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./framework/ui/view/renderer/ListViewRenderer */ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/ListViewRenderer.js");
/* harmony import */ var _framework_ui_view_renderer_ListViewRendererUsingContext__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./framework/ui/view/renderer/ListViewRendererUsingContext */ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/ListViewRendererUsingContext.js");
/* harmony import */ var _framework_ui_view_renderer_TabularViewRendererUsingContext__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./framework/ui/view/renderer/TabularViewRendererUsingContext */ "./node_modules/ui-framework-jps/dist/framework/ui/view/renderer/TabularViewRendererUsingContext.js");
/* harmony import */ var _framework_ui_view_delegate_ViewListenerForwarder__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./framework/ui/view/delegate/ViewListenerForwarder */ "./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/ViewListenerForwarder.js");
/* harmony import */ var _framework_ui_view_delegate_DetailViewListenerForwarder__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./framework/ui/view/delegate/DetailViewListenerForwarder */ "./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/DetailViewListenerForwarder.js");
/* harmony import */ var _framework_ui_view_delegate_CollectionViewListenerForwarder__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./framework/ui/view/delegate/CollectionViewListenerForwarder */ "./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/CollectionViewListenerForwarder.js");
/* harmony import */ var _framework_ui_view_delegate_CollectionViewEventHandlerDelegate__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./framework/ui/view/delegate/CollectionViewEventHandlerDelegate */ "./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/CollectionViewEventHandlerDelegate.js");
/* harmony import */ var _framework_ui_view_delegate_CollectionViewEventHandlerDelegateUsingContext__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./framework/ui/view/delegate/CollectionViewEventHandlerDelegateUsingContext */ "./node_modules/ui-framework-jps/dist/framework/ui/view/delegate/CollectionViewEventHandlerDelegateUsingContext.js");
/* harmony import */ var _framework_util_MiscFunctions__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./framework/util/MiscFunctions */ "./node_modules/ui-framework-jps/dist/framework/util/MiscFunctions.js");
/* harmony import */ var _framework_util_EqualityFunctions__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./framework/util/EqualityFunctions */ "./node_modules/ui-framework-jps/dist/framework/util/EqualityFunctions.js");
/* harmony import */ var _framework_util_DurationFunctions__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./framework/util/DurationFunctions */ "./node_modules/ui-framework-jps/dist/framework/util/DurationFunctions.js");
/* harmony import */ var _framework_util_BrowserUtil__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./framework/util/BrowserUtil */ "./node_modules/ui-framework-jps/dist/framework/util/BrowserUtil.js");
/* harmony import */ var _framework_ui_table_BasicTableRowImplementation__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./framework/ui/table/BasicTableRowImplementation */ "./node_modules/ui-framework-jps/dist/framework/ui/table/BasicTableRowImplementation.js");
/* harmony import */ var _framework_ui_key_binding_manager_KeyBindingManager__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./framework/ui/key-binding-manager/KeyBindingManager */ "./node_modules/ui-framework-jps/dist/framework/ui/key-binding-manager/KeyBindingManager.js");

/* models */











/* network utils */




/* notifications */

/* Security Manager */






/* state management */















/* ui */































































//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/esm-browser/validate.js");

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/esm-browser/stringify.js");



function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rnds);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/esm-browser/regex.js");


function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);

/***/ })

}]);
//# sourceMappingURL=vendor.bundle.js.map